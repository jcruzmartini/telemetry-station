CCS PCH C Compiler, Version 4.104, 5967               19-jun-13 01:48

               Filename: C:\ETA\new\main.lst

               ROM used: 20694 bytes (32%)
                         Largest free fragment is 44006
               RAM used: 849 (21%) at main() level
                         1059 (27%) worst case
               Stack:    8 worst case (6 in main + 2 for interrupts)

*
0000:  GOTO   4A06
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   02A6
0054:  BTFSS  FF0.4
0056:  GOTO   0060
005A:  BTFSC  FF0.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   033A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4610.h> 
.................... //////// Standard Header file for the PIC18F4610 device //////////////// 
.................... #device PIC18F4610 
.................... #list 
....................  
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOLVP                    //No low voltage progming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES PROTECT                  //Code protected from reads 
.................... #FUSES HS			//High speed 
.................... #FUSES WDT128 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... #define FREQ_OSC 8000000  
.................... #define BAUD_RATE 9600 
.................... #use delay(clock=FREQ_OSC,RESTART_WDT) 
*
058A:  MOVLW  03
058C:  MOVWF  FEA
058E:  MOVLW  74
0590:  MOVWF  FE9
0592:  MOVF   FEF,W
0594:  BZ    05B8
0596:  MOVLW  02
0598:  MOVWF  01
059A:  MOVLW  BF
059C:  MOVWF  00
059E:  CLRWDT
05A0:  DECFSZ 00,F
05A2:  BRA    059E
05A4:  DECFSZ 01,F
05A6:  BRA    059A
05A8:  MOVLW  96
05AA:  MOVWF  00
05AC:  DECFSZ 00,F
05AE:  BRA    05AC
05B0:  BRA    05B2
05B2:  CLRWDT
05B4:  DECFSZ FEF,F
05B6:  BRA    0596
05B8:  RETLW  00
.................... //-------------------------------------------- 
.................... // Configuracion del Puerto del GSM 
.................... // Nota:  modificar Pines y baudrate de acuerdo a la config de la placa 
.................... // Importante: ERRORS se utiliza para que la UART del PIC contemple variaciones en el baudrate 
.................... //-------------------------------------------- 
.................... #use rs232(baud=BAUD_RATE, xmit=PIN_C6,rcv=PIN_C7,errors,stream=SIM300)    
*
0322:  BTFSS  F9E.5
0324:  BRA    0322
0326:  MOVFF  FAB,16
032A:  MOVFF  FAE,01
032E:  BTFSS  16.1
0330:  BRA    0336
0332:  BCF    FAB.4
0334:  BSF    FAB.4
0336:  GOTO   0360 (RETURN)
*
1312:  BTFSS  F9E.4
1314:  BRA    1312
1316:  MOVWF  FAD
1318:  GOTO   13AA (RETURN)
....................  
.................... //---------------------- IO Pines ---------------------------------------- 
.................... #define KIOPTOA     0b11110011 // E/S puerto A  
.................... #define KIOPTOB     0b11110111  // E/S puerto B 
.................... #define KIOPTOC     0b10000001  // E/S puerto C 
....................  
.................... #define RTC_IO   	PIN_D2	// Pin I/O de rtc 
.................... #define RTC_SCLK 	PIN_D1	// Pin Sclk de rtc 
.................... #define RTC_RST  	PIN_D0	// Pin reset de rtc 
.................... // 
.................... #define EEPROM_SDA  PIN_B5  // Pin SDA memoria 
.................... #define EEPROM_SCL  PIN_B4  // Pin SCL memoria 
.................... // 
.................... #define	INP_PREC	PIN_B0	// Entrada pluviometro 
.................... #define	SIM300_PWR	PIN_E1	// Encendido SIM300 
.................... // 
.................... #define	TX_BUFFER_SIZE	100 
.................... #define	RX_BUFFER_SIZE	100 
.................... // 
.................... // --------------------- Constantes -------------------------------------- 
.................... // 
.................... #define SZ_SMSTXT       165				// Cantidad de caracteres x SMS  
.................... #define KTEMPX   		0.1091          // Constante para conversor A/D 
.................... #define KTEMPX_QTY		15              // Constante que define la cantidad de medidas a tomar para calcular la presion 
.................... #define KTEMPX_CORR     0               // Constante de correccion de la medida del sensor 
.................... #define KTESHT_QTY		5               // Constante que define la cantidad de medidas a tomar para calcular la humedad y presion 
.................... #define K_TIME_MED		1740			//  Segundos de intervalo entre mediciones 
.................... #define K_TIME_CHK		1500    		// Segundos para control de mediciones internas 
.................... #define K_TIME_RESTART	6000    		// Segundos entre intervalos de reinicio del modem 
.................... #define KTE_PLUV		0.44			// Constante de pluviometro 
.................... #define K_LLUVIA_H		24				// Cantidad de horas para obtener el acumulado de lluvia 
.................... #define KTE_MAXTI		60.0			// Máxima temperatura interna del equipo 
.................... #define KTE_MINTI		0.0				// Mínima temperatura interna del equipo 
.................... #define MAX_CNALARM		3				// Cantidad de mediciones seguidas para activar alarma 
.................... #define HAB_SEN_TI		0x01			// Sensor de temperatura interna habilitado 
.................... #define TEMP_HUM_S		0x02			// Sensor de temperatura y humedad habilitado 
.................... #define RAINFALL_S		0x04			// Sensor de precipitacion habilitado 
.................... #define PREASURE_S		0x08			// Sensor de presion habilitado 
.................... #define HAB_SENS5		0x10			// Reservado 
.................... #define HAB_SENS6		0x20			// Reservado 
.................... #define HAB_SENS7		0x40			// Reservado 
.................... #define HAB_SENS8		0x80			// Reservado 
....................  
.................... // -------------------------- RESPUESTAS---------------------------------- 
.................... #define TYP_SMS_ON		0			// Encendido 
.................... #define TYP_SMS_CON		1			// Consulta de variables actuales 
.................... #define TYP_SMS_AA		2			// Alta de una alarma 
.................... #define TYP_SMS_BA		3			// Baja de una alarma 
.................... #define TYP_SMS_INI		4			// Inicializar eprom 
.................... #define TYP_SMS_RTC		5			// Poner en fecha y hora el rtc 
.................... #define TYP_SMS_CSERV	6			// Cambiar numero de tel a reportar 
.................... #define TYP_SMS_ERR		240			// Error 
....................  
.................... //------------------- EEPROM INTERNA ---------------------------------- 
.................... #define ADDR_HAB_L		0x00			// Inicio memoria sensores habilitados 
.................... #define ADDR_HAB_H		0x01 
.................... #define ADDR_TMED_L		0x02			// Inicio memoria tiempo de medicion programado 
.................... #define ADDR_TMED_H		0x03 
.................... #define ADDR_TCHK_L		0x04			// Inicio memoria tiempo de control interno programado 
.................... #define ADDR_TCHK_H		0x05 
....................  
.................... #define ADDR_TELEF1		0x0A			// Inicio memoria Numero Telefono (20 bytes) 
.................... #define ADDR_TELEF2		0x1E			// Inicio memoria Numero Telefono (20 bytes) 
.................... #define ADDR_ALARM		0x32			// Inicio memoria alarmas 
....................  
.................... #define SZ_TELEFONO		14				// Tamaño del telefono 
.................... 	 
.................... //------------------- UMBRALES INTENSIDAD DE LLUVIA  ------------------------------ 
.................... #define U_DEBIL        		1 
.................... #define U_MOD	       		7.5 
.................... #define U_FUERTE       		15 
.................... #define U_MUYFUERTE    		30 
....................  
.................... #rom 0x0F00000={(HAB_SEN_TI | TEMP_HUM_S | RAINFALL_S | PREASURE_S), K_TIME_MED, K_TIME_CHK} 
.................... #rom (0x0F00000 +ADDR_ALARM) = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //------------------- EEPROM EXTERNA ---------------------------------- 
.................... #define MAX_LOG_CNT		1000			// Maximo nro. de registros 
.................... #define CN_MEMDATA_L	0x0000			// Contador registros 
.................... #define CN_MEMDATA_H	0x0001			// Contador registros 
.................... #define INI_LOG_MEM		0x0002			// Inicio memoria LOG 
.................... #define FIN_LOG_MEM		0xD7A2			// Fin Memoria LOG 
.................... #define INI_AUXEE		0xD7A3			// Inicio auxiliar 
.................... //------------------- Includes ---------------------------------------- 
.................... #include "modem.c" 
.................... void clear_buffer_gsm(void); 
.................... char  *gprs_response(char *s, int16 timeout); 
.................... char  *match_response(char *sms, char *s, int16 timeout); 
.................... void enviar_sms(void); 
.................... void SimPowerOff(void); 
.................... void wait_response_ok(int16 timeout, int times); 
.................... void wait_for_call_ready(void); 
....................  
.................... #define BUFFER_SIZE 255  
.................... volatile int8 buffer[BUFFER_SIZE+1]; 
.................... int8 buf_index = 0;  
....................  
.................... //------------------------------------------------------- 
.................... //       MACROS 
.................... // NOTA : modificar en funcion al diseño de la placa 
.................... //------------------------------------------------------- 
.................... //Power Key 
.................... #define pk_on    output_high (PIN_E1) 
.................... #define pk_off   output_low (PIN_E1) 
.................... #define pk       input(PIN_E1) 
....................  
.................... // Punteros. 
.................... char *ptr; 
....................  
....................  
.................... //----------------------------------------------------- 
.................... //            LIBRERIAS 
.................... //----------------------------------------------------- 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
2B64:  MOVFF  3FF,403
2B68:  MOVFF  3FE,402
2B6C:  MOVFF  403,03
2B70:  MOVLB  4
2B72:  MOVFF  402,FE9
2B76:  MOVFF  403,FEA
2B7A:  MOVF   FEF,F
2B7C:  BZ    2B8A
2B7E:  INCF   x02,F
2B80:  BTFSC  FD8.2
2B82:  INCF   x03,F
2B84:  MOVLB  0
2B86:  BRA    2B6C
2B88:  MOVLB  4
....................    while(*s2 != '\0') 
....................    { 
2B8A:  MOVFF  401,03
2B8E:  MOVFF  400,FE9
2B92:  MOVFF  401,FEA
2B96:  MOVF   FEF,F
2B98:  BZ    2BC0
....................       *s = *s2; 
2B9A:  MOVFF  400,FE9
2B9E:  MOVFF  401,FEA
2BA2:  MOVFF  FEF,406
2BA6:  MOVFF  403,FEA
2BAA:  MOVFF  402,FE9
2BAE:  MOVFF  406,FEF
....................       ++s; 
2BB2:  INCF   x02,F
2BB4:  BTFSC  FD8.2
2BB6:  INCF   x03,F
....................       ++s2; 
2BB8:  INCF   x00,F
2BBA:  BTFSC  FD8.2
2BBC:  INCF   x01,F
....................    } 
2BBE:  BRA    2B8A
....................  
....................    *s = '\0'; 
2BC0:  MOVFF  402,FE9
2BC4:  MOVFF  403,FEA
2BC8:  CLRF   FEF
....................    return(s1); 
2BCA:  MOVLB  3
2BCC:  MOVFF  3FE,01
2BD0:  MOVFF  3FF,02
.................... } 
2BD4:  MOVLB  0
2BD6:  RETLW  00
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
3B9C:  MOVLB  3
3B9E:  MOVFF  392,FE9
3BA2:  MOVFF  393,FEA
3BA6:  MOVFF  FEF,396
3BAA:  MOVFF  395,03
3BAE:  MOVFF  394,FE9
3BB2:  MOVFF  395,FEA
3BB6:  MOVF   FEF,W
3BB8:  SUBWF  x96,W
3BBA:  BNZ   3BE6
....................       if (*s1 == '\0') 
3BBC:  MOVFF  393,03
3BC0:  MOVFF  392,FE9
3BC4:  MOVFF  03,FEA
3BC8:  MOVF   FEF,F
3BCA:  BNZ   3BD2
....................          return(0); 
3BCC:  MOVLW  00
3BCE:  MOVWF  01
3BD0:  BRA    3C10
3BD2:  MOVFF  393,03
3BD6:  MOVF   x92,W
3BD8:  INCF   x92,F
3BDA:  BTFSC  FD8.2
3BDC:  INCF   x93,F
3BDE:  INCF   x94,F
3BE0:  BTFSC  FD8.2
3BE2:  INCF   x95,F
3BE4:  BRA    3B9E
....................    return((*s1 < *s2) ? -1: 1); 
3BE6:  MOVFF  393,03
3BEA:  MOVFF  392,FE9
3BEE:  MOVFF  393,FEA
3BF2:  MOVFF  FEF,396
3BF6:  MOVFF  395,03
3BFA:  MOVFF  394,FE9
3BFE:  MOVFF  395,FEA
3C02:  MOVF   FEF,W
3C04:  SUBWF  x96,W
3C06:  BC    3C0C
3C08:  MOVLW  FF
3C0A:  BRA    3C0E
3C0C:  MOVLW  01
3C0E:  MOVWF  01
.................... } 
3C10:  MOVLB  0
3C12:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
37CC:  MOVFF  39B,39F
37D0:  MOVFF  39A,39E
37D4:  MOVFF  39F,03
37D8:  MOVLB  3
37DA:  MOVFF  39E,FE9
37DE:  MOVFF  39F,FEA
37E2:  MOVF   FEF,F
37E4:  BZ    383A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
37E6:  MOVFF  39D,3A1
37EA:  MOVFF  39C,3A0
37EE:  MOVFF  3A1,03
37F2:  MOVFF  3A0,FE9
37F6:  MOVFF  3A1,FEA
37FA:  MOVF   FEF,F
37FC:  BZ    382E
....................          if (*sc1 == *sc2) 
37FE:  MOVFF  39E,FE9
3802:  MOVFF  39F,FEA
3806:  MOVFF  FEF,3A2
380A:  MOVFF  3A1,03
380E:  MOVFF  3A0,FE9
3812:  MOVFF  3A1,FEA
3816:  MOVF   FEF,W
3818:  SUBWF  xA2,W
381A:  BNZ   3826
....................             return(sc1); 
381C:  MOVFF  39E,01
3820:  MOVFF  39F,02
3824:  BRA    3840
3826:  INCF   xA0,F
3828:  BTFSC  FD8.2
382A:  INCF   xA1,F
382C:  BRA    37EE
382E:  INCF   x9E,F
3830:  BTFSC  FD8.2
3832:  INCF   x9F,F
3834:  MOVLB  0
3836:  BRA    37D4
3838:  MOVLB  3
....................    return(0); 
383A:  MOVLW  00
383C:  MOVWF  01
383E:  MOVWF  02
.................... } 
3840:  MOVLB  0
3842:  GOTO   38BE (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
373C:  MOVFF  39B,39F
3740:  MOVFF  39A,39E
3744:  MOVFF  39F,03
3748:  MOVLB  3
374A:  MOVFF  39E,FE9
374E:  MOVFF  39F,FEA
3752:  MOVF   FEF,F
3754:  BZ    37B6
....................       for (sc2 = s2; ; sc2++) 
3756:  MOVFF  39D,3A1
375A:  MOVFF  39C,3A0
....................     if (*sc2 == '\0') 
375E:  MOVFF  3A1,03
3762:  MOVFF  3A0,FE9
3766:  MOVFF  3A1,FEA
376A:  MOVF   FEF,F
376C:  BNZ   3782
....................        return(sc1 - s1); 
376E:  MOVF   x9A,W
3770:  SUBWF  x9E,W
3772:  MOVWF  00
3774:  MOVF   x9B,W
3776:  SUBWFB x9F,W
3778:  MOVWF  03
377A:  MOVFF  00,01
377E:  BRA    37C6
....................          else if (*sc1 == *sc2) 
3780:  BRA    37A2
3782:  MOVFF  39E,FE9
3786:  MOVFF  39F,FEA
378A:  MOVFF  FEF,3A2
378E:  MOVFF  3A1,03
3792:  MOVFF  3A0,FE9
3796:  MOVFF  3A1,FEA
379A:  MOVF   FEF,W
379C:  SUBWF  xA2,W
379E:  BNZ   37A2
....................             break; 
37A0:  BRA    37AA
37A2:  INCF   xA0,F
37A4:  BTFSC  FD8.2
37A6:  INCF   xA1,F
37A8:  BRA    375E
37AA:  INCF   x9E,F
37AC:  BTFSC  FD8.2
37AE:  INCF   x9F,F
37B0:  MOVLB  0
37B2:  BRA    3744
37B4:  MOVLB  3
....................    return(sc1 - s1); 
37B6:  MOVF   x9A,W
37B8:  SUBWF  x9E,W
37BA:  MOVWF  00
37BC:  MOVF   x9B,W
37BE:  SUBWFB x9F,W
37C0:  MOVWF  03
37C2:  MOVFF  00,01
.................... } 
37C6:  MOVLB  0
37C8:  GOTO   387A (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
*
05D2:  MOVFF  36C,03
05D6:  MOVLB  3
05D8:  MOVFF  36B,FE9
05DC:  MOVFF  36C,FEA
05E0:  MOVF   FEF,F
05E2:  BZ    0656
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
05E4:  MOVFF  36C,370
05E8:  MOVFF  36B,36F
05EC:  MOVFF  36E,372
05F0:  MOVFF  36D,371
05F4:  MOVFF  372,03
05F8:  MOVFF  371,FE9
05FC:  MOVFF  372,FEA
0600:  MOVF   FEF,F
0602:  BZ    0630
0604:  MOVFF  36F,FE9
0608:  MOVFF  370,FEA
060C:  MOVFF  FEF,373
0610:  MOVFF  372,03
0614:  MOVFF  371,FE9
0618:  MOVFF  372,FEA
061C:  MOVF   FEF,W
061E:  SUBWF  x73,W
0620:  BNZ   0630
0622:  INCF   x6F,F
0624:  BTFSC  FD8.2
0626:  INCF   x70,F
0628:  INCF   x71,F
062A:  BTFSC  FD8.2
062C:  INCF   x72,F
062E:  BRA    05F4
....................  
....................       if (*t == '\0') 
0630:  MOVFF  372,03
0634:  MOVFF  371,FE9
0638:  MOVFF  372,FEA
063C:  MOVF   FEF,F
063E:  BNZ   064A
....................          return s1; 
0640:  MOVFF  36B,01
0644:  MOVFF  36C,02
0648:  BRA    065C
....................       ++s1; 
064A:  INCF   x6B,F
064C:  BTFSC  FD8.2
064E:  INCF   x6C,F
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
0650:  MOVLB  0
0652:  BRA    05D2
0654:  MOVLB  3
....................    return 0; 
0656:  MOVLW  00
0658:  MOVWF  01
065A:  MOVWF  02
.................... } 
065C:  MOVLB  0
065E:  GOTO   0676 (RETURN)
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
3846:  MOVLB  3
3848:  MOVF   x92,W
384A:  IORWF  x93,W
384C:  BZ    3856
384E:  MOVFF  393,03
3852:  MOVF   x92,W
3854:  BRA    3860
3856:  MOVFF  11B,03
385A:  MOVLB  1
385C:  MOVF   x1A,W
385E:  MOVLB  3
3860:  MOVWF  x96
3862:  MOVFF  03,397
....................    beg += strspn(beg, s2); 
3866:  MOVFF  397,39B
386A:  MOVFF  396,39A
386E:  MOVFF  395,39D
3872:  MOVFF  394,39C
3876:  MOVLB  0
3878:  BRA    373C
387A:  MOVF   01,W
387C:  MOVLB  3
387E:  ADDWF  x96,F
3880:  MOVLW  00
3882:  ADDWFC x97,F
....................    if (*beg == '\0') 
3884:  MOVFF  397,03
3888:  MOVFF  396,FE9
388C:  MOVFF  397,FEA
3890:  MOVF   FEF,F
3892:  BNZ   38AA
....................    { 
....................       *save = ' '; 
3894:  MOVLB  1
3896:  MOVFF  11A,FE9
389A:  MOVFF  11B,FEA
389E:  MOVLW  20
38A0:  MOVWF  FEF
....................       return(0); 
38A2:  MOVLW  00
38A4:  MOVWF  01
38A6:  MOVWF  02
38A8:  BRA    38FA
....................    } 
....................    end = strpbrk(beg, s2); 
38AA:  MOVFF  397,39B
38AE:  MOVFF  396,39A
38B2:  MOVFF  395,39D
38B6:  MOVFF  394,39C
38BA:  MOVLB  0
38BC:  BRA    37CC
38BE:  MOVFF  02,399
38C2:  MOVFF  01,398
....................    if (*end != '\0') 
38C6:  MOVFF  399,03
38CA:  MOVLB  3
38CC:  MOVFF  398,FE9
38D0:  MOVFF  399,FEA
38D4:  MOVF   FEF,F
38D6:  BZ    38E8
....................    { 
....................       *end = '\0'; 
38D8:  MOVFF  398,FE9
38DC:  MOVFF  399,FEA
38E0:  CLRF   FEF
....................       end++; 
38E2:  INCF   x98,F
38E4:  BTFSC  FD8.2
38E6:  INCF   x99,F
....................    } 
....................    save = end; 
38E8:  MOVFF  399,11B
38EC:  MOVFF  398,11A
....................    return(beg); 
38F0:  MOVFF  396,01
38F4:  MOVFF  397,02
38F8:  MOVLB  1
.................... } 
38FA:  MOVLB  0
38FC:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
2BD8:  MOVFF  3FF,401
2BDC:  MOVFF  3FE,400
2BE0:  MOVFF  401,03
2BE4:  MOVLB  4
2BE6:  MOVFF  400,FE9
2BEA:  MOVFF  401,FEA
2BEE:  MOVF   FEF,F
2BF0:  BZ    2BFC
2BF2:  INCF   x00,F
2BF4:  BTFSC  FD8.2
2BF6:  INCF   x01,F
2BF8:  MOVLB  0
2BFA:  BRA    2BE0
....................    return(sc - s); 
2BFC:  MOVLB  3
2BFE:  MOVF   xFE,W
2C00:  MOVLB  4
2C02:  SUBWF  x00,W
2C04:  MOVWF  00
2C06:  MOVLB  3
2C08:  MOVF   xFF,W
2C0A:  MOVLB  4
2C0C:  SUBWFB x01,W
2C0E:  MOVWF  03
2C10:  MOVFF  00,01
.................... } 
2C14:  MOVLB  0
2C16:  GOTO   2C24 (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0ADC:  MOVLB  4
0ADE:  CLRF   x02
....................    sign = 0; 
0AE0:  CLRF   x00
....................    base = 10; 
0AE2:  MOVLW  0A
0AE4:  MOVWF  x01
....................    result = 0; 
0AE6:  MOVLB  3
0AE8:  CLRF   xFF
....................  
....................    if (!s) 
0AEA:  MOVF   xFD,W
0AEC:  IORWF  xFE,W
0AEE:  BNZ   0AF6
....................       return 0; 
0AF0:  MOVLW  00
0AF2:  MOVWF  01
0AF4:  BRA    0CBA
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0AF6:  MOVLB  4
0AF8:  MOVF   x02,W
0AFA:  INCF   x02,F
0AFC:  CLRF   03
0AFE:  MOVLB  3
0B00:  ADDWF  xFD,W
0B02:  MOVWF  FE9
0B04:  MOVF   xFE,W
0B06:  ADDWFC 03,W
0B08:  MOVWF  FEA
0B0A:  MOVFF  FEF,403
0B0E:  MOVLB  4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B10:  MOVF   x03,W
0B12:  SUBLW  2D
0B14:  BNZ   0B34
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B16:  MOVLW  01
0B18:  MOVWF  x00
....................       c = s[index++]; 
0B1A:  MOVF   x02,W
0B1C:  INCF   x02,F
0B1E:  CLRF   03
0B20:  MOVLB  3
0B22:  ADDWF  xFD,W
0B24:  MOVWF  FE9
0B26:  MOVF   xFE,W
0B28:  ADDWFC 03,W
0B2A:  MOVWF  FEA
0B2C:  MOVFF  FEF,403
0B30:  MOVLB  4
....................    } 
....................    else if (c == '+') 
0B32:  BRA    0B52
0B34:  MOVF   x03,W
0B36:  SUBLW  2B
0B38:  BNZ   0B52
....................    { 
....................       c = s[index++]; 
0B3A:  MOVF   x02,W
0B3C:  INCF   x02,F
0B3E:  CLRF   03
0B40:  MOVLB  3
0B42:  ADDWF  xFD,W
0B44:  MOVWF  FE9
0B46:  MOVF   xFE,W
0B48:  ADDWFC 03,W
0B4A:  MOVWF  FEA
0B4C:  MOVFF  FEF,403
0B50:  MOVLB  4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B52:  MOVF   x03,W
0B54:  SUBLW  2F
0B56:  BTFSC  FD8.0
0B58:  BRA    0CA6
0B5A:  MOVF   x03,W
0B5C:  SUBLW  39
0B5E:  BTFSS  FD8.0
0B60:  BRA    0CA6
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B62:  MOVF   x03,W
0B64:  SUBLW  30
0B66:  BNZ   0BBC
0B68:  CLRF   03
0B6A:  MOVF   x02,W
0B6C:  MOVLB  3
0B6E:  ADDWF  xFD,W
0B70:  MOVWF  FE9
0B72:  MOVF   xFE,W
0B74:  ADDWFC 03,W
0B76:  MOVWF  FEA
0B78:  MOVF   FEF,W
0B7A:  SUBLW  78
0B7C:  BZ    0B9C
0B7E:  CLRF   03
0B80:  MOVLB  4
0B82:  MOVF   x02,W
0B84:  MOVLB  3
0B86:  ADDWF  xFD,W
0B88:  MOVWF  FE9
0B8A:  MOVF   xFE,W
0B8C:  ADDWFC 03,W
0B8E:  MOVWF  FEA
0B90:  MOVF   FEF,W
0B92:  SUBLW  58
0B94:  BTFSC  FD8.2
0B96:  BRA    0B9C
0B98:  MOVLB  4
0B9A:  BRA    0BBC
....................       { 
....................          base = 16; 
0B9C:  MOVLW  10
0B9E:  MOVLB  4
0BA0:  MOVWF  x01
....................          index++; 
0BA2:  INCF   x02,F
....................          c = s[index++]; 
0BA4:  MOVF   x02,W
0BA6:  INCF   x02,F
0BA8:  CLRF   03
0BAA:  MOVLB  3
0BAC:  ADDWF  xFD,W
0BAE:  MOVWF  FE9
0BB0:  MOVF   xFE,W
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEF,403
0BBA:  MOVLB  4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0BBC:  MOVF   x01,W
0BBE:  SUBLW  0A
0BC0:  BNZ   0C04
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0BC2:  MOVF   x03,W
0BC4:  SUBLW  2F
0BC6:  BC    0C02
0BC8:  MOVF   x03,W
0BCA:  SUBLW  39
0BCC:  BNC   0C02
....................             result = 10*result + (c - '0'); 
0BCE:  MOVLW  0A
0BD0:  MOVWF  x04
0BD2:  MOVFF  3FF,405
0BD6:  MOVLB  0
0BD8:  RCALL  0A8E
0BDA:  MOVLW  30
0BDC:  MOVLB  4
0BDE:  SUBWF  x03,W
0BE0:  ADDWF  01,W
0BE2:  MOVLB  3
0BE4:  MOVWF  xFF
....................             c = s[index++]; 
0BE6:  MOVLB  4
0BE8:  MOVF   x02,W
0BEA:  INCF   x02,F
0BEC:  CLRF   03
0BEE:  MOVLB  3
0BF0:  ADDWF  xFD,W
0BF2:  MOVWF  FE9
0BF4:  MOVF   xFE,W
0BF6:  ADDWFC 03,W
0BF8:  MOVWF  FEA
0BFA:  MOVFF  FEF,403
0BFE:  MOVLB  4
....................          } 
0C00:  BRA    0BC2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0C02:  BRA    0CA6
0C04:  MOVF   x01,W
0C06:  SUBLW  10
0C08:  BNZ   0CA6
....................       { 
....................          c = toupper(c); 
0C0A:  MOVF   x03,W
0C0C:  SUBLW  60
0C0E:  BC    0C1C
0C10:  MOVF   x03,W
0C12:  SUBLW  7A
0C14:  BNC   0C1C
0C16:  MOVF   x03,W
0C18:  ANDLW  DF
0C1A:  BRA    0C1E
0C1C:  MOVF   x03,W
0C1E:  MOVWF  x03
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0C20:  MOVF   x03,W
0C22:  SUBLW  2F
0C24:  BC    0C2C
0C26:  MOVF   x03,W
0C28:  SUBLW  39
0C2A:  BC    0C38
0C2C:  MOVF   x03,W
0C2E:  SUBLW  40
0C30:  BC    0CA6
0C32:  MOVF   x03,W
0C34:  SUBLW  46
0C36:  BNC   0CA6
....................             if (c >= '0' && c <= '9') 
0C38:  MOVF   x03,W
0C3A:  SUBLW  2F
0C3C:  BC    0C5C
0C3E:  MOVF   x03,W
0C40:  SUBLW  39
0C42:  BNC   0C5C
....................                result = (result << 4) + (c - '0'); 
0C44:  MOVLB  3
0C46:  SWAPF  xFF,W
0C48:  MOVLB  4
0C4A:  MOVWF  x04
0C4C:  MOVLW  F0
0C4E:  ANDWF  x04,F
0C50:  MOVLW  30
0C52:  SUBWF  x03,W
0C54:  ADDWF  x04,W
0C56:  MOVLB  3
0C58:  MOVWF  xFF
....................             else 
0C5A:  BRA    0C74
....................                result = (result << 4) + (c - 'A' + 10); 
0C5C:  MOVLB  3
0C5E:  SWAPF  xFF,W
0C60:  MOVLB  4
0C62:  MOVWF  x04
0C64:  MOVLW  F0
0C66:  ANDWF  x04,F
0C68:  MOVLW  41
0C6A:  SUBWF  x03,W
0C6C:  ADDLW  0A
0C6E:  ADDWF  x04,W
0C70:  MOVLB  3
0C72:  MOVWF  xFF
....................  
....................             c = s[index++]; 
0C74:  MOVLB  4
0C76:  MOVF   x02,W
0C78:  INCF   x02,F
0C7A:  CLRF   03
0C7C:  MOVLB  3
0C7E:  ADDWF  xFD,W
0C80:  MOVWF  FE9
0C82:  MOVF   xFE,W
0C84:  ADDWFC 03,W
0C86:  MOVWF  FEA
0C88:  MOVFF  FEF,403
0C8C:  MOVLB  4
....................             c = toupper(c); 
0C8E:  MOVF   x03,W
0C90:  SUBLW  60
0C92:  BC    0CA0
0C94:  MOVF   x03,W
0C96:  SUBLW  7A
0C98:  BNC   0CA0
0C9A:  MOVF   x03,W
0C9C:  ANDLW  DF
0C9E:  BRA    0CA2
0CA0:  MOVF   x03,W
0CA2:  MOVWF  x03
....................          } 
0CA4:  BRA    0C20
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0CA6:  DECFSZ x00,W
0CA8:  BRA    0CB4
0CAA:  MOVF   x01,W
0CAC:  SUBLW  0A
0CAE:  BNZ   0CB4
....................        result = -result; 
0CB0:  MOVLB  3
0CB2:  NEGF   xFF
....................  
....................    return(result); 
0CB4:  MOVLB  3
0CB6:  MOVFF  3FF,01
.................... } 
0CBA:  MOVLB  0
0CBC:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
3C14:  MOVLB  3
3C16:  CLRF   x99
3C18:  CLRF   x98
3C1A:  CLRF   x97
3C1C:  MOVLW  7F
3C1E:  MOVWF  x96
3C20:  CLRF   x9D
3C22:  CLRF   x9C
3C24:  CLRF   x9B
3C26:  CLRF   x9A
3C28:  BSF    x9E.0
3C2A:  BCF    x9E.1
3C2C:  BCF    x9E.2
3C2E:  CLRF   xA0
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
3C30:  MOVF   x92,W
3C32:  IORWF  x93,W
3C34:  BNZ   3C40
....................       return 0; 
3C36:  CLRF   00
3C38:  CLRF   01
3C3A:  CLRF   02
3C3C:  CLRF   03
3C3E:  BRA    3E74
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
3C40:  MOVF   xA0,W
3C42:  INCF   xA0,F
3C44:  CLRF   03
3C46:  ADDWF  x92,W
3C48:  MOVWF  FE9
3C4A:  MOVF   x93,W
3C4C:  ADDWFC 03,W
3C4E:  MOVWF  FEA
3C50:  MOVFF  FEF,39F
3C54:  MOVF   x9F,F
3C56:  BTFSC  FD8.2
3C58:  BRA    3DF6
....................    { 
....................       if (skip && !isspace(c)) 
3C5A:  BTFSS  x9E.0
3C5C:  BRA    3C7C
3C5E:  MOVF   x9F,W
3C60:  SUBLW  20
3C62:  BZ    3C7C
....................       { 
....................          skip = 0; 
3C64:  BCF    x9E.0
....................          if (c == '+') 
3C66:  MOVF   x9F,W
3C68:  SUBLW  2B
3C6A:  BNZ   3C72
....................          { 
....................             sign = 0; 
3C6C:  BCF    x9E.1
....................             continue; 
3C6E:  BRA    3DDC
....................          }             
....................          else if (c == '-') 
3C70:  BRA    3C7C
3C72:  MOVF   x9F,W
3C74:  SUBLW  2D
3C76:  BNZ   3C7C
....................          { 
....................             sign = 1; 
3C78:  BSF    x9E.1
....................             continue; 
3C7A:  BRA    3DDC
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
3C7C:  BTFSC  x9E.0
3C7E:  BRA    3C8E
3C80:  MOVF   x9F,W
3C82:  SUBLW  2E
3C84:  BNZ   3C8E
3C86:  BTFSC  x9E.2
3C88:  BRA    3C8E
....................          point = 1; 
3C8A:  BSF    x9E.2
....................       else if (!skip && isdigit(c)) 
3C8C:  BRA    3DDC
3C8E:  BTFSC  x9E.0
3C90:  BRA    3DD6
3C92:  MOVF   x9F,W
3C94:  SUBLW  2F
3C96:  BTFSC  FD8.0
3C98:  BRA    3DD6
3C9A:  MOVF   x9F,W
3C9C:  SUBLW  39
3C9E:  BTFSS  FD8.0
3CA0:  BRA    3DD6
....................       { 
....................          c -= '0'; 
3CA2:  MOVLW  30
3CA4:  SUBWF  x9F,F
....................          if (point) 
3CA6:  BTFSS  x9E.2
3CA8:  BRA    3D5A
....................          { 
....................             pow10 = pow10 * 10.0; 
3CAA:  MOVFF  399,410
3CAE:  MOVFF  398,40F
3CB2:  MOVFF  397,40E
3CB6:  MOVFF  396,40D
3CBA:  MOVLB  4
3CBC:  CLRF   x14
3CBE:  CLRF   x13
3CC0:  MOVLW  20
3CC2:  MOVWF  x12
3CC4:  MOVLW  82
3CC6:  MOVWF  x11
3CC8:  MOVLB  0
3CCA:  CALL   1662
3CCE:  MOVFF  03,399
3CD2:  MOVFF  02,398
3CD6:  MOVFF  01,397
3CDA:  MOVFF  00,396
....................             result += (float)c / pow10;    
3CDE:  MOVLB  3
3CE0:  CLRF   xA6
3CE2:  MOVFF  39F,3A5
3CE6:  MOVLB  0
3CE8:  CALL   162C
3CEC:  MOVFF  00,3A1
3CF0:  MOVFF  01,3A2
3CF4:  MOVFF  02,3A3
3CF8:  MOVFF  03,3A4
3CFC:  MOVFF  03,3A8
3D00:  MOVFF  02,3A7
3D04:  MOVFF  01,3A6
3D08:  MOVFF  00,3A5
3D0C:  MOVFF  399,3AC
3D10:  MOVFF  398,3AB
3D14:  MOVFF  397,3AA
3D18:  MOVFF  396,3A9
3D1C:  CALL   1FF4
3D20:  BCF    FD8.1
3D22:  MOVFF  39D,3A8
3D26:  MOVFF  39C,3A7
3D2A:  MOVFF  39B,3A6
3D2E:  MOVFF  39A,3A5
3D32:  MOVFF  03,3AC
3D36:  MOVFF  02,3AB
3D3A:  MOVFF  01,3AA
3D3E:  MOVFF  00,3A9
3D42:  CALL   1758
3D46:  MOVFF  03,39D
3D4A:  MOVFF  02,39C
3D4E:  MOVFF  01,39B
3D52:  MOVFF  00,39A
....................          } 
....................          else 
3D56:  BRA    3DD2
3D58:  MOVLB  3
....................          { 
....................             result = 10.0 * result + (float)c; 
3D5A:  MOVLB  4
3D5C:  CLRF   x10
3D5E:  CLRF   x0F
3D60:  MOVLW  20
3D62:  MOVWF  x0E
3D64:  MOVLW  82
3D66:  MOVWF  x0D
3D68:  MOVFF  39D,414
3D6C:  MOVFF  39C,413
3D70:  MOVFF  39B,412
3D74:  MOVFF  39A,411
3D78:  MOVLB  0
3D7A:  CALL   1662
3D7E:  MOVFF  00,3A1
3D82:  MOVFF  01,3A2
3D86:  MOVFF  02,3A3
3D8A:  MOVFF  03,3A4
3D8E:  MOVLB  3
3D90:  CLRF   xA6
3D92:  MOVFF  39F,3A5
3D96:  MOVLB  0
3D98:  CALL   162C
3D9C:  BCF    FD8.1
3D9E:  MOVFF  3A4,3A8
3DA2:  MOVFF  3A3,3A7
3DA6:  MOVFF  3A2,3A6
3DAA:  MOVFF  3A1,3A5
3DAE:  MOVFF  03,3AC
3DB2:  MOVFF  02,3AB
3DB6:  MOVFF  01,3AA
3DBA:  MOVFF  00,3A9
3DBE:  CALL   1758
3DC2:  MOVFF  03,39D
3DC6:  MOVFF  02,39C
3DCA:  MOVFF  01,39B
3DCE:  MOVFF  00,39A
....................          } 
....................       } 
....................       else if (!skip) 
3DD2:  BRA    3DDE
3DD4:  MOVLB  3
3DD6:  BTFSC  x9E.0
3DD8:  BRA    3DDC
....................          break; 
3DDA:  BRA    3DF6
3DDC:  MOVLB  0
....................    } 
3DDE:  MOVLB  3
3DE0:  MOVF   xA0,W
3DE2:  INCF   xA0,F
3DE4:  CLRF   03
3DE6:  ADDWF  x92,W
3DE8:  MOVWF  FE9
3DEA:  MOVF   x93,W
3DEC:  ADDWFC 03,W
3DEE:  MOVWF  FEA
3DF0:  MOVFF  FEF,39F
3DF4:  BRA    3C54
....................  
....................    if (sign) 
3DF6:  BTFSS  x9E.1
3DF8:  BRA    3E30
....................       result = -1*result; 
3DFA:  MOVLB  4
3DFC:  CLRF   x10
3DFE:  CLRF   x0F
3E00:  MOVLW  80
3E02:  MOVWF  x0E
3E04:  MOVLW  7F
3E06:  MOVWF  x0D
3E08:  MOVFF  39D,414
3E0C:  MOVFF  39C,413
3E10:  MOVFF  39B,412
3E14:  MOVFF  39A,411
3E18:  MOVLB  0
3E1A:  CALL   1662
3E1E:  MOVFF  03,39D
3E22:  MOVFF  02,39C
3E26:  MOVFF  01,39B
3E2A:  MOVFF  00,39A
3E2E:  MOVLB  3
....................        
....................    if(endptr) 
3E30:  MOVF   x94,W
3E32:  IORWF  x95,W
3E34:  BZ    3E64
....................    { 
....................       if (ptr) { 
3E36:  MOVF   xA0,F
3E38:  BZ    3E52
....................          ptr--; 
3E3A:  DECF   xA0,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
3E3C:  MOVFF  394,FE9
3E40:  MOVFF  395,FEA
3E44:  MOVF   xA0,W
3E46:  ADDWF  x92,W
3E48:  MOVWF  FEF
3E4A:  MOVLW  00
3E4C:  ADDWFC x93,W
3E4E:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
3E50:  BRA    3E64
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
3E52:  MOVFF  394,FE9
3E56:  MOVFF  395,FEA
3E5A:  MOVFF  393,FEC
3E5E:  MOVF   FED,F
3E60:  MOVFF  392,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
3E64:  MOVFF  39A,00
3E68:  MOVFF  39B,01
3E6C:  MOVFF  39C,02
3E70:  MOVFF  39D,03
.................... } 
3E74:  MOVLB  0
3E76:  RETLW  00
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1() { 
....................    char digit; 
....................  
....................    digit = getc(); 
....................  
....................    putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... #if !defined(__PCD__) 
.................... signed int8 get_int() { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int16 get_int() { 
....................   char s[5]; 
....................   signed int16 i; 
....................  
....................   get_string(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... signed int16 get_long() { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int32 get_long() { 
....................   char s[7]; 
....................   signed int32 l; 
....................  
....................   get_string(s, 10); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //-------------------------------------------------------------------------- 
.................... //  D E F I N I C I O N     D E  VARIABLES PARA MODULO GSM 
.................... //-------------------------------------------------------------------------- 
....................  
.................... char ok[] = "OK"; 
.................... char rd[] = "RDY"; 
.................... char sms_noleido[] = { "UNREAD" }; 
.................... char caracter[] = { ">" }; // caracter que me indica iniciar mensaje de texto 
....................  
.................... //int suspender; 
.................... int guia; 
.................... int done; 
....................  
.................... //------------------------------------------------------- 
.................... //  Funcion Delay 1 seg 
.................... //------------------------------------------------------- 
....................  
.................... #inline  
.................... void delay_sec (void)  
.................... {  
....................    delay_ms(1000);  
.................... }  
....................  
....................  
.................... /*---------------------------------------------------------------------- 
.................... | Funcion para apagar el modem 
.................... ----------------------------------------------------------------------*/ 
.................... void SimPowerOff(void) 
.................... { 
.................... 	output_bit(SIM300_PWR, 0); 
.................... 	delay_ms(1500); 
.................... 	output_bit(SIM300_PWR, 1); 
.................... } 
....................  
.................... //-------------------------------------------------------- 
.................... // INICIALIZACION DEL MODULO GSM 
.................... //-------------------------------------------------------- 
.................... int modulo_gsm_init(void){ 
.................... 	//Inicio del modem segun DATASHEET SIMCOM  
.................... 	pk_off;	 
*
0776:  BCF    F96.1
0778:  BCF    F8D.1
.................... 	delay_ms(1500);		// Esperamos 1-1/2 seg. 
077A:  MOVLW  06
077C:  MOVLB  3
077E:  MOVWF  x54
0780:  MOVLW  FA
0782:  MOVWF  x74
0784:  MOVLB  0
0786:  RCALL  058A
0788:  MOVLB  3
078A:  DECFSZ x54,F
078C:  BRA    0780
.................... 	pk_on; 				// PWRKEY=1; 
078E:  BCF    F96.1
0790:  BSF    F8D.1
.................... 	delay_ms(1500);		// Esperamos 1-1/2 seg. 
0792:  MOVLW  06
0794:  MOVWF  x54
0796:  MOVLW  FA
0798:  MOVWF  x74
079A:  MOVLB  0
079C:  RCALL  058A
079E:  MOVLB  3
07A0:  DECFSZ x54,F
07A2:  BRA    0796
.................... 	pk_off;				// PRWKEY=0; 
07A4:  BCF    F96.1
07A6:  BCF    F8D.1
.................... 	delay_ms(3000);		// Esperamos 3 seg. 
07A8:  MOVLW  0C
07AA:  MOVWF  x54
07AC:  MOVLW  FA
07AE:  MOVWF  x74
07B0:  MOVLB  0
07B2:  RCALL  058A
07B4:  MOVLB  3
07B6:  DECFSZ x54,F
07B8:  BRA    07AC
.................... 	restart_wdt(); 
07BA:  CLRWDT
.................... 	wait_for_call_ready(); 
07BC:  MOVLB  0
07BE:  BRA    06B4
.................... 	clear_buffer_gsm();  // se borra buffer del modem 
07C0:  RCALL  06F0
.................... 	fprintf(SIM300,"AT\r"); 
07C2:  MOVLW  41
07C4:  BTFSS  F9E.4
07C6:  BRA    07C4
07C8:  MOVWF  FAD
07CA:  MOVLW  54
07CC:  BTFSS  F9E.4
07CE:  BRA    07CC
07D0:  MOVWF  FAD
07D2:  MOVLW  0D
07D4:  BTFSS  F9E.4
07D6:  BRA    07D4
07D8:  MOVWF  FAD
.................... 				 
.................... 	while(gprs_response(ok,8000)==0) //  Esperando Respuesta del Modulo GSM 
.................... 	{ 
07DA:  MOVLW  01
07DC:  MOVLB  3
07DE:  MOVWF  x66
07E0:  MOVLW  20
07E2:  MOVWF  x65
07E4:  MOVLW  1F
07E6:  MOVWF  x68
07E8:  MOVLW  40
07EA:  MOVWF  x67
07EC:  MOVLB  0
07EE:  RCALL  0662
07F0:  MOVFF  02,355
07F4:  MOVFF  01,354
07F8:  MOVLB  3
07FA:  MOVF   x54,F
07FC:  BNZ   081E
07FE:  MOVF   x55,F
0800:  BNZ   081E
.................... 	 fprintf(SIM300,"AT\r"); 
0802:  MOVLW  41
0804:  BTFSS  F9E.4
0806:  BRA    0804
0808:  MOVWF  FAD
080A:  MOVLW  54
080C:  BTFSS  F9E.4
080E:  BRA    080C
0810:  MOVWF  FAD
0812:  MOVLW  0D
0814:  BTFSS  F9E.4
0816:  BRA    0814
0818:  MOVWF  FAD
.................... 	} 
081A:  MOVLB  0
081C:  BRA    07DA
....................  
.................... 	 //** ELIMINAR ECO **//    
.................... 	 clear_buffer_gsm();        // se borra buffer del modem 
081E:  MOVLB  0
0820:  RCALL  06F0
.................... 	 fprintf(SIM300,"ATE0\r");     // Elimina ECO 
0822:  MOVLW  F6
0824:  MOVWF  FF6
0826:  MOVLW  01
0828:  MOVWF  FF7
082A:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
082C:  MOVLW  07
082E:  MOVLB  3
0830:  MOVWF  x55
0832:  MOVLW  D0
0834:  MOVWF  x54
0836:  MOVLW  05
0838:  MOVWF  x56
083A:  MOVLB  0
083C:  RCALL  0740
.................... 	 
.................... 	 //** MODO TEXTO **// 
.................... 	 clear_buffer_gsm();            // se borra buffer del modem 
083E:  RCALL  06F0
.................... 	 fprintf(SIM300,"AT+CMGF=1\r");    // Modo Texto 
0840:  MOVLW  FC
0842:  MOVWF  FF6
0844:  MOVLW  01
0846:  MOVWF  FF7
0848:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
084A:  MOVLW  07
084C:  MOVLB  3
084E:  MOVWF  x55
0850:  MOVLW  D0
0852:  MOVWF  x54
0854:  MOVLW  05
0856:  MOVWF  x56
0858:  MOVLB  0
085A:  RCALL  0740
.................... 	 
.................... 	 clear_buffer_gsm();         	 // se borra buffer del modem	 
085C:  RCALL  06F0
.................... 	 fprintf(SIM300,"AT+CMEE=2\r");    // Reporte de Errores en Modo Texto  
085E:  MOVLW  08
0860:  MOVWF  FF6
0862:  MOVLW  02
0864:  MOVWF  FF7
0866:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
0868:  MOVLW  07
086A:  MOVLB  3
086C:  MOVWF  x55
086E:  MOVLW  D0
0870:  MOVWF  x54
0872:  MOVLW  05
0874:  MOVWF  x56
0876:  MOVLB  0
0878:  RCALL  0740
.................... 	  
.................... 	 clear_buffer_gsm();            // se borra buffer del modem 
087A:  RCALL  06F0
.................... 	 fprintf(SIM300,"AT+CPMS=\"ME\"\r"); // Selecciono la mememoria SIM para recibir y leer SMS. 
087C:  MOVLW  14
087E:  MOVWF  FF6
0880:  MOVLW  02
0882:  MOVWF  FF7
0884:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
0886:  MOVLW  07
0888:  MOVLB  3
088A:  MOVWF  x55
088C:  MOVLW  D0
088E:  MOVWF  x54
0890:  MOVLW  05
0892:  MOVWF  x56
0894:  MOVLB  0
0896:  RCALL  0740
....................  
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
0898:  RCALL  06F0
.................... 	 fprintf(SIM300, "AT+CSCS=\"GSM\"\r");	//SMS text mode parameters 
089A:  MOVLW  22
089C:  MOVWF  FF6
089E:  MOVLW  02
08A0:  MOVWF  FF7
08A2:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
08A4:  MOVLW  07
08A6:  MOVLB  3
08A8:  MOVWF  x55
08AA:  MOVLW  D0
08AC:  MOVWF  x54
08AE:  MOVLW  05
08B0:  MOVWF  x56
08B2:  MOVLB  0
08B4:  RCALL  0740
.................... 	  
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
08B6:  RCALL  06F0
.................... 	 fprintf(SIM300, "AT+CSMP=17,167,0,241\r");	//SMS text mode parameters 
08B8:  MOVLW  32
08BA:  MOVWF  FF6
08BC:  MOVLW  02
08BE:  MOVWF  FF7
08C0:  RCALL  071E
.................... 	 wait_response_ok(2000,5); 
08C2:  MOVLW  07
08C4:  MOVLB  3
08C6:  MOVWF  x55
08C8:  MOVLW  D0
08CA:  MOVWF  x54
08CC:  MOVLW  05
08CE:  MOVWF  x56
08D0:  MOVLB  0
08D2:  RCALL  0740
.................... 	 
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
08D4:  RCALL  06F0
.................... 	return 1; 
08D6:  MOVLW  01
08D8:  MOVWF  01
.................... } 
08DA:  RETLW  00
....................  
....................  
.................... //------------------------------------------------- 
.................... //  BORRA EL BUFFER GSM 
.................... //------------------------------------------------- 
.................... void clear_buffer_gsm(void)  /*borra el buffer gsm */ 
.................... {  
*
06F0:  MOVLB  3
06F2:  CLRF   x65
....................   int erase=0; 
....................   disable_interrupts(INT_RDA); 
06F4:  BCF    F9D.5
....................    
....................   buf_index = 0;  
06F6:  MOVLB  1
06F8:  CLRF   x17
....................   buffer[0] = 0;  
06FA:  CLRF   17
....................   while(erase!=BUFFER_SIZE) { 
06FC:  MOVLB  3
06FE:  INCFSZ x65,W
0700:  BRA    0704
0702:  BRA    0718
.................... 	buffer[erase] = '\0'; 
0704:  CLRF   03
0706:  MOVF   x65,W
0708:  ADDLW  17
070A:  MOVWF  FE9
070C:  MOVLW  00
070E:  ADDWFC 03,W
0710:  MOVWF  FEA
0712:  CLRF   FEF
.................... 	erase++; 
0714:  INCF   x65,F
....................   } 
0716:  BRA    06FE
....................   enable_interrupts(INT_RDA);  
0718:  BSF    F9D.5
.................... }  
071A:  MOVLB  0
071C:  RETLW  00
....................  
.................... //--------------------------------------------------- 
.................... // ESPERA LA RESPUESTA DEL MODULO 
.................... //--------------------------------------------------- 
.................... void wait_response_ok(int16 timeout, int times){ 
*
0740:  MOVFF  356,357
.................... 	char tmOut = times; 
.................... 	do { 
.................... 		tmOut--; 
0744:  MOVLB  3
0746:  DECF   x57,F
.................... 	}while((gprs_response(ok,timeout) == NULL) && (tmOut != 0)); 
0748:  MOVLW  01
074A:  MOVWF  x66
074C:  MOVLW  20
074E:  MOVWF  x65
0750:  MOVFF  355,368
0754:  MOVFF  354,367
0758:  MOVLB  0
075A:  RCALL  0662
075C:  MOVFF  02,359
0760:  MOVFF  01,358
0764:  MOVLB  3
0766:  MOVF   x58,F
0768:  BNZ   0772
076A:  MOVF   x59,F
076C:  BNZ   0772
076E:  MOVF   x57,F
0770:  BNZ   0746
.................... } 
0772:  MOVLB  0
0774:  RETLW  00
....................  
.................... //------------------------------------------- 
.................... //FUNCION DE DEMORA A LA ESPERA DE OPERADORA 
.................... //------------------------------------------- 
.................... void wait_for_call_ready(void){ 
.................... 	disable_interrupts(INT_RDA); 
*
06B4:  BCF    F9D.5
....................     char tmOut = 10; 
06B6:  MOVLW  0A
06B8:  MOVLB  3
06BA:  MOVWF  x54
.................... 	do { 
.................... 		tmOut--; 
06BC:  DECF   x54,F
.................... 	} while((gprs_response(rd,5000) == NULL) && (tmOut != 0)); 
06BE:  MOVLW  01
06C0:  MOVWF  x66
06C2:  MOVLW  23
06C4:  MOVWF  x65
06C6:  MOVLW  13
06C8:  MOVWF  x68
06CA:  MOVLW  88
06CC:  MOVWF  x67
06CE:  MOVLB  0
06D0:  RCALL  0662
06D2:  MOVFF  02,356
06D6:  MOVFF  01,355
06DA:  MOVLB  3
06DC:  MOVF   x55,F
06DE:  BNZ   06E8
06E0:  MOVF   x56,F
06E2:  BNZ   06E8
06E4:  MOVF   x54,F
06E6:  BNZ   06BC
.................... 	enable_interrupts(INT_RDA); 
06E8:  BSF    F9D.5
.................... } 
06EA:  MOVLB  0
06EC:  GOTO   07C0 (RETURN)
....................  
.................... //================================================================== 
.................... // funcion de comparacion de contenido buffer GSM 
.................... /* String que estamos buscando */  
.................... /* Tiempo de espera */  
.................... //================================================================== 
.................... char  *gprs_response(char *s, int16 timeout)  
.................... {  
....................   char  *p;  
....................  
....................   while (TRUE)  
....................   {  
....................     p = strstr(buffer, s);  
*
0662:  MOVLB  3
0664:  CLRF   x6C
0666:  MOVLW  17
0668:  MOVWF  x6B
066A:  MOVFF  366,36E
066E:  MOVFF  365,36D
0672:  MOVLB  0
0674:  BRA    05D2
0676:  MOVFF  02,36A
067A:  MOVFF  01,369
....................     if (p)  
067E:  MOVLB  3
0680:  MOVF   x69,W
0682:  IORWF  x6A,W
0684:  BZ    0690
....................     {  
....................        return (p); // salida de la funcion 
0686:  MOVFF  369,01
068A:  MOVFF  36A,02
068E:  BRA    06B0
....................     }       
....................     if (timeout)  
0690:  MOVF   x67,W
0692:  IORWF  x68,W
0694:  BZ    06AE
....................     {     
....................       timeout--;  
0696:  MOVF   x67,W
0698:  BTFSC  FD8.2
069A:  DECF   x68,F
069C:  DECF   x67,F
.................... 	  restart_wdt(); 
069E:  CLRWDT
....................       if (!timeout)  
06A0:  MOVF   x67,W
06A2:  IORWF  x68,W
06A4:  BNZ   06AE
....................       {  
....................         return (NULL);    // timeout buffer 
06A6:  MOVLW  00
06A8:  MOVWF  01
06AA:  MOVWF  02
06AC:  BRA    06B0
....................       }  
....................     }  
....................   }  
06AE:  BRA    0664
.................... }   
06B0:  MOVLB  0
06B2:  RETLW  00
....................  
.................... //================================================================== 
.................... // funcion de comparacion de contenido de parametro sms 
.................... /* String que estamos buscando */  
.................... /* Tiempo de espera */  
.................... //================================================================== 
.................... char  *match_response(char *sms, char *s, int16 timeout)  
.................... {  
....................   char  *p;  
....................   while (TRUE)  
....................   {  
....................     p = strstr(sms, s);  
....................     if (p)  
....................     {  
....................        return (p); // salida de la funcion 
....................     }       
....................     if (timeout)  
....................     {     
....................       timeout--;  
....................       if (!timeout)  
....................       {  
....................        return (NULL);    // timeout buffer 
....................      }  
....................     }  
....................   }  
.................... }   
....................  
.................... //================================================================== 
.................... //  BORRAR SMS DEL MODEM 
.................... //================================================================== 
....................  
.................... int borrar_sms(void){ 
....................    int x; 
....................    if (guia == 10){ 
*
38FE:  MOVLB  1
3900:  MOVF   x30,W
3902:  SUBLW  0A
3904:  BNZ   396E
.................... 		   for (x = 1; x <= 10; x++){ 
3906:  MOVLW  01
3908:  MOVLB  3
390A:  MOVWF  x61
390C:  MOVF   x61,W
390E:  SUBLW  0A
3910:  BNC   395A
.................... 				fprintf(SIM300,"AT+CMGD=%d\r",x); 
3912:  MOVLW  48
3914:  MOVWF  FF6
3916:  MOVLW  02
3918:  MOVWF  FF7
391A:  MOVLW  08
391C:  MOVWF  x65
391E:  MOVLB  0
3920:  CALL   08DC
3924:  MOVFF  361,362
3928:  MOVLW  1F
392A:  MOVLB  3
392C:  MOVWF  x63
392E:  MOVLB  0
3930:  CALL   0932
3934:  MOVLW  0D
3936:  BTFSS  F9E.4
3938:  BRA    3936
393A:  MOVWF  FAD
.................... 				gprs_response(ok,1000); 
393C:  MOVLW  01
393E:  MOVLB  3
3940:  MOVWF  x66
3942:  MOVLW  20
3944:  MOVWF  x65
3946:  MOVLW  03
3948:  MOVWF  x68
394A:  MOVLW  E8
394C:  MOVWF  x67
394E:  MOVLB  0
3950:  CALL   0662
.................... 		   } 
3954:  MOVLB  3
3956:  INCF   x61,F
3958:  BRA    390C
.................... 		guia=1; 
395A:  MOVLW  01
395C:  MOVLB  1
395E:  MOVWF  x30
.................... 		clear_buffer_gsm(); 
3960:  MOVLB  0
3962:  CALL   06F0
.................... 		return 1; 
3966:  MOVLW  01
3968:  MOVWF  01
396A:  BRA    3972
396C:  MOVLB  1
.................... 	} 
.................... 	return 0; 
396E:  MOVLW  00
3970:  MOVWF  01
3972:  MOVLB  0
.................... } 
3974:  GOTO   3B5C (RETURN)
....................  
.................... //================================================================== 
.................... //  BORRAR TODOS LOS SMS  AL INICIO DEL MODEM 
.................... //================================================================== 
....................  
.................... void borrar_sms_inicio(void){ 
....................     int x; 
.................... 	for (x = 1; x <= 50; x++){ 
*
0A12:  MOVLW  01
0A14:  MOVLB  3
0A16:  MOVWF  x54
0A18:  MOVF   x54,W
0A1A:  SUBLW  32
0A1C:  BNC   0A66
.................... 		clear_buffer_gsm(); 
0A1E:  MOVLB  0
0A20:  RCALL  06F0
.................... 		fprintf(SIM300,"AT+CMGD=%d\r",x); 
0A22:  MOVLW  54
0A24:  MOVWF  FF6
0A26:  MOVLW  02
0A28:  MOVWF  FF7
0A2A:  MOVLW  08
0A2C:  MOVLB  3
0A2E:  MOVWF  x65
0A30:  MOVLB  0
0A32:  RCALL  08DC
0A34:  MOVFF  354,362
0A38:  MOVLW  1F
0A3A:  MOVLB  3
0A3C:  MOVWF  x63
0A3E:  MOVLB  0
0A40:  RCALL  0932
0A42:  MOVLW  0D
0A44:  BTFSS  F9E.4
0A46:  BRA    0A44
0A48:  MOVWF  FAD
.................... 		gprs_response(ok,1000); 
0A4A:  MOVLW  01
0A4C:  MOVLB  3
0A4E:  MOVWF  x66
0A50:  MOVLW  20
0A52:  MOVWF  x65
0A54:  MOVLW  03
0A56:  MOVWF  x68
0A58:  MOVLW  E8
0A5A:  MOVWF  x67
0A5C:  MOVLB  0
0A5E:  RCALL  0662
.................... 	} 
0A60:  MOVLB  3
0A62:  INCF   x54,F
0A64:  BRA    0A18
.................... } 
0A66:  MOVLB  0
0A68:  GOTO   4BDC (RETURN)
....................  
....................  
.................... #include <ds1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_B1 
.................... #define RTC_IO   PIN_B3 
.................... #define RTC_RST  PIN_B2 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
0442:  MOVLB  3
0444:  CLRF   x9C
0446:  MOVF   x9C,W
0448:  SUBLW  07
044A:  BNC   0466
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
044C:  BCF    FD8.0
044E:  RRCF   x9B,F
0450:  BC    0456
0452:  BCF    F8C.2
0454:  BRA    0458
0456:  BSF    F8C.2
0458:  BCF    F95.2
....................       output_high(RTC_SCLK); 
045A:  BCF    F95.1
045C:  BSF    F8C.1
....................       output_low(RTC_SCLK); 
045E:  BCF    F95.1
0460:  BCF    F8C.1
....................    } 
0462:  INCF   x9C,F
0464:  BRA    0446
.................... } 
0466:  MOVLB  0
0468:  RETLW  00
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
046A:  BCF    F95.0
046C:  BSF    F8C.0
....................    write_ds1302_byte(cmd); 
046E:  MOVFF  399,39B
0472:  RCALL  0442
....................    write_ds1302_byte(data); 
0474:  MOVFF  39A,39B
0478:  RCALL  0442
....................    output_low(RTC_RST); 
047A:  BCF    F95.0
047C:  BCF    F8C.0
.................... } 
047E:  RETLW  00
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
0480:  BCF    F95.0
0482:  BSF    F8C.0
....................    write_ds1302_byte(cmd); 
0484:  MOVFF  37E,39B
0488:  RCALL  0442
....................     
....................    input(RTC_IO); 
048A:  BSF    F95.2
....................    delay_us(1); 
048C:  CLRWDT
048E:  NOP   
....................           
....................    for(i=0;i<=7;++i) { 
0490:  MOVLB  3
0492:  CLRF   x7F
0494:  MOVF   x7F,W
0496:  SUBLW  07
0498:  BNC   04C0
....................       shift_right(&data,1,input(RTC_IO)); 
049A:  BSF    F95.2
049C:  BTFSC  F83.2
049E:  BRA    04A4
04A0:  BCF    FD8.0
04A2:  BRA    04A6
04A4:  BSF    FD8.0
04A6:  RRCF   x80,F
....................       output_high(RTC_SCLK); 
04A8:  BCF    F95.1
04AA:  BSF    F8C.1
....................       delay_us(2); 
04AC:  CLRWDT
04AE:  BRA    04B0
04B0:  NOP   
....................       output_low(RTC_SCLK); 
04B2:  BCF    F95.1
04B4:  BCF    F8C.1
....................       delay_us(2); 
04B6:  CLRWDT
04B8:  BRA    04BA
04BA:  NOP   
....................    } 
04BC:  INCF   x7F,F
04BE:  BRA    0494
....................    output_low(RTC_RST); 
04C0:  BCF    F95.0
04C2:  BCF    F8C.0
....................  
....................    return(data); 
04C4:  MOVFF  380,01
.................... } 
04C8:  MOVLB  0
04CA:  RETLW  00
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
04CC:  BCF    F95.0
04CE:  BCF    F8C.0
....................    delay_us(2); 
04D0:  CLRWDT
04D2:  BRA    04D4
04D4:  NOP   
....................    output_low(RTC_SCLK); 
04D6:  BCF    F95.1
04D8:  BCF    F8C.1
....................    write_ds1302(0x8e,0); 
04DA:  MOVLW  8E
04DC:  MOVLB  3
04DE:  MOVWF  x99
04E0:  CLRF   x9A
04E2:  MOVLB  0
04E4:  RCALL  046A
....................    write_ds1302(0x90,0xa4); 
04E6:  MOVLW  90
04E8:  MOVLB  3
04EA:  MOVWF  x99
04EC:  MOVLW  A4
04EE:  MOVWF  x9A
04F0:  MOVLB  0
04F2:  RCALL  046A
....................    x=read_ds1302(0x81); 
04F4:  MOVLW  81
04F6:  MOVLB  3
04F8:  MOVWF  x7E
04FA:  MOVLB  0
04FC:  RCALL  0480
04FE:  MOVFF  01,354
....................    if((x & 0x80)!=0) 
0502:  MOVLB  3
0504:  MOVF   x54,W
0506:  ANDLW  80
0508:  BZ    0516
....................      write_ds1302(0x80,0); 
050A:  MOVLW  80
050C:  MOVWF  x99
050E:  CLRF   x9A
0510:  MOVLB  0
0512:  RCALL  046A
0514:  MOVLB  3
.................... } 
0516:  MOVLB  0
0518:  GOTO   4B82 (RETURN)
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
*
3E78:  MOVFF  398,406
3E7C:  MOVLW  0A
3E7E:  MOVLB  4
3E80:  MOVWF  x07
3E82:  MOVLB  0
3E84:  CALL   0906
3E88:  MOVFF  01,399
....................    nibl=data-(nibh*10); 
3E8C:  MOVLB  3
3E8E:  MOVF   x99,W
3E90:  MULLW  0A
3E92:  MOVF   FF3,W
3E94:  SUBWF  x98,W
3E96:  MOVWF  x9A
....................  
....................    return((nibh<<4)|nibl); 
3E98:  SWAPF  x99,W
3E9A:  MOVWF  00
3E9C:  MOVLW  F0
3E9E:  ANDWF  00,F
3EA0:  MOVF   00,W
3EA2:  IORWF  x9A,W
3EA4:  MOVWF  01
.................... } 
3EA6:  MOVLB  0
3EA8:  RETLW  00
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
0E16:  MOVFF  37F,380
....................    data=(i>>4)*10; 
0E1A:  MOVLB  3
0E1C:  SWAPF  x80,W
0E1E:  MOVWF  00
0E20:  MOVLW  0F
0E22:  ANDWF  00,F
0E24:  MOVF   00,W
0E26:  MULLW  0A
0E28:  MOVFF  FF3,37F
....................    data=data+(i<<4>>4); 
0E2C:  SWAPF  x80,W
0E2E:  MOVWF  00
0E30:  MOVLW  F0
0E32:  ANDWF  00,F
0E34:  MOVF   00,W
0E36:  SWAPF  00,F
0E38:  MOVLW  0F
0E3A:  ANDWF  00,F
0E3C:  MOVF   00,W
0E3E:  ADDWF  x7F,F
....................  
....................    return data; 
0E40:  MOVFF  37F,01
.................... } 
0E44:  MOVLB  0
0E46:  RETLW  00
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
3EAA:  MOVFF  392,398
3EAE:  RCALL  3E78
3EB0:  MOVFF  01,398
3EB4:  MOVLW  86
3EB6:  MOVLB  3
3EB8:  MOVWF  x99
3EBA:  MOVFF  01,39A
3EBE:  MOVLB  0
3EC0:  CALL   046A
....................    write_ds1302(0x88,get_bcd(mth)); 
3EC4:  MOVFF  393,398
3EC8:  RCALL  3E78
3ECA:  MOVFF  01,398
3ECE:  MOVLW  88
3ED0:  MOVLB  3
3ED2:  MOVWF  x99
3ED4:  MOVFF  01,39A
3ED8:  MOVLB  0
3EDA:  CALL   046A
....................    write_ds1302(0x8c,get_bcd(year)); 
3EDE:  MOVFF  394,398
3EE2:  RCALL  3E78
3EE4:  MOVFF  01,398
3EE8:  MOVLW  8C
3EEA:  MOVLB  3
3EEC:  MOVWF  x99
3EEE:  MOVFF  01,39A
3EF2:  MOVLB  0
3EF4:  CALL   046A
....................    write_ds1302(0x8a,get_bcd(dow)); 
3EF8:  MOVFF  395,398
3EFC:  RCALL  3E78
3EFE:  MOVFF  01,398
3F02:  MOVLW  8A
3F04:  MOVLB  3
3F06:  MOVWF  x99
3F08:  MOVFF  01,39A
3F0C:  MOVLB  0
3F0E:  CALL   046A
....................    write_ds1302(0x84,get_bcd(hr)); 
3F12:  MOVFF  396,398
3F16:  RCALL  3E78
3F18:  MOVFF  01,398
3F1C:  MOVLW  84
3F1E:  MOVLB  3
3F20:  MOVWF  x99
3F22:  MOVFF  01,39A
3F26:  MOVLB  0
3F28:  CALL   046A
....................    write_ds1302(0x82,get_bcd(min)); 
3F2C:  MOVFF  397,398
3F30:  RCALL  3E78
3F32:  MOVFF  01,398
3F36:  MOVLW  82
3F38:  MOVLB  3
3F3A:  MOVWF  x99
3F3C:  MOVFF  01,39A
3F40:  MOVLB  0
3F42:  CALL   046A
....................    write_ds1302(0x80,get_bcd(0)); 
3F46:  MOVLB  3
3F48:  CLRF   x98
3F4A:  MOVLB  0
3F4C:  RCALL  3E78
3F4E:  MOVFF  01,398
3F52:  MOVLW  80
3F54:  MOVLB  3
3F56:  MOVWF  x99
3F58:  MOVFF  01,39A
3F5C:  MOVLB  0
3F5E:  CALL   046A
.................... } 
3F62:  GOTO   476E (RETURN)
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
1150:  MOVLW  87
1152:  MOVLB  3
1154:  MOVWF  x7E
1156:  MOVLB  0
1158:  CALL   0480
115C:  MOVFF  01,37A
1160:  MOVFF  01,37F
1164:  RCALL  0E16
1166:  MOVFF  01,36F
....................    mth = rm_bcd(read_ds1302(0x89)); 
116A:  MOVLW  89
116C:  MOVLB  3
116E:  MOVWF  x7E
1170:  MOVLB  0
1172:  CALL   0480
1176:  MOVFF  01,37A
117A:  MOVFF  01,37F
117E:  RCALL  0E16
1180:  MOVFF  01,370
....................    year = rm_bcd(read_ds1302(0x8d)); 
1184:  MOVLW  8D
1186:  MOVLB  3
1188:  MOVWF  x7E
118A:  MOVLB  0
118C:  CALL   0480
1190:  MOVFF  01,37A
1194:  MOVFF  01,37F
1198:  RCALL  0E16
119A:  MOVFF  01,371
....................    dow = rm_bcd(read_ds1302(0x8b)); 
119E:  MOVLW  8B
11A0:  MOVLB  3
11A2:  MOVWF  x7E
11A4:  MOVLB  0
11A6:  CALL   0480
11AA:  MOVFF  01,37A
11AE:  MOVFF  01,37F
11B2:  RCALL  0E16
11B4:  MOVFF  01,36E
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
11B8:  MOVLW  85
11BA:  MOVLB  3
11BC:  MOVWF  x7E
11BE:  MOVLB  0
11C0:  CALL   0480
11C4:  MOVFF  01,37A
11C8:  MOVFF  01,37F
11CC:  RCALL  0E16
11CE:  MOVFF  01,36B
....................    min = rm_bcd(read_ds1302(0x83)); 
11D2:  MOVLW  83
11D4:  MOVLB  3
11D6:  MOVWF  x7E
11D8:  MOVLB  0
11DA:  CALL   0480
11DE:  MOVFF  01,37A
11E2:  MOVFF  01,37F
11E6:  RCALL  0E16
11E8:  MOVFF  01,36C
....................    sec = rm_bcd(read_ds1302(0x81)); 
11EC:  MOVLW  81
11EE:  MOVLB  3
11F0:  MOVWF  x7E
11F2:  MOVLB  0
11F4:  CALL   0480
11F8:  MOVFF  01,37A
11FC:  MOVFF  01,37F
1200:  RCALL  0E16
1202:  MOVFF  01,36D
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "sht75.c" 
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... //                                                                           //  
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       //  
.................... //                                                                           //  
.................... // ***** To initialise SHT75 sensor upon power up *****                      //  
.................... //                                                                           //  
.................... // Function : sht_init()                                                     //  
.................... // Return   : none                                                           //  
.................... //                                                                           //  
.................... //                                                                           //  
.................... // ***** To measure and calculate SHT75 temp & real RH *****                 //  
.................... //                                                                           //  
.................... // Function : sht_rd (temp, truehumid)                                       //  
.................... // Return   : temperature & true humidity in float values                    //  
.................... //                                                                           //  
.................... ///////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define sht_data_pin   PIN_C0   //#define sht_data_pin   PIN_D3  
.................... #define sht_clk_pin    PIN_C1   //#define sht_clk_pin    PIN_C4  
....................  
....................  
.................... //***** Function to alert SHT75 *****  
....................  
.................... void comstart (void)  
.................... {  
....................  output_float(sht_data_pin);  //data high  
*
051C:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);  //clk low  
051E:  BCF    F8B.1
0520:  BCF    F94.1
....................  delay_us(1);  
0522:  CLRWDT
0524:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0526:  BSF    F8B.1
0528:  BCF    F94.1
....................  delay_us(1);  
052A:  CLRWDT
052C:  NOP   
....................  output_bit(sht_data_pin, 0); //data low  
052E:  BCF    F8B.0
0530:  BCF    F94.0
....................  delay_us(1);  
0532:  CLRWDT
0534:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0536:  BCF    F8B.1
0538:  BCF    F94.1
....................  delay_us(2);  
053A:  CLRWDT
053C:  BRA    053E
053E:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0540:  BSF    F8B.1
0542:  BCF    F94.1
....................  delay_us(1);  
0544:  CLRWDT
0546:  NOP   
....................  output_float(sht_data_pin);  //data high  
0548:  BSF    F94.0
....................  delay_us(1);  
054A:  CLRWDT
054C:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
054E:  BCF    F8B.1
0550:  BCF    F94.1
.................... }  
0552:  RETLW  00
....................  
....................  
.................... //***** Function to write data to SHT75 *****  
....................  
.................... int1 comwrite (int8 iobyte)  
.................... {  
*
1470:  MOVLW  80
1472:  MOVLB  3
1474:  MOVWF  x80
....................  int8 i, mask = 0x80;  
....................  int1 ack;  
....................  
....................  //Shift out command  
....................  delay_us(4);  
1476:  CLRWDT
1478:  MOVLW  02
147A:  MOVWF  00
147C:  DECFSZ 00,F
147E:  BRA    147C
....................  for(i=0; i<8; i++)  
1480:  CLRF   x7F
1482:  MOVF   x7F,W
1484:  SUBLW  07
1486:  BNC   14AE
....................   {  
....................    output_bit(sht_clk_pin, 0);                          //clk low  
1488:  BCF    F8B.1
148A:  BCF    F94.1
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high  
148C:  MOVF   x7E,W
148E:  ANDWF  x80,W
1490:  BZ    1496
1492:  BSF    F94.0
....................    else output_bit(sht_data_pin, 0);                    //data low if MSB low  
1494:  BRA    149A
1496:  BCF    F8B.0
1498:  BCF    F94.0
....................    delay_us(1);  
149A:  CLRWDT
149C:  NOP   
....................    output_bit(sht_clk_pin, 1);                          //clk high  
149E:  BSF    F8B.1
14A0:  BCF    F94.1
....................    delay_us(1);  
14A2:  CLRWDT
14A4:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit  
14A6:  BCF    FD8.0
14A8:  RRCF   x80,F
....................   }  
14AA:  INCF   x7F,F
14AC:  BRA    1482
....................  
....................  //Shift in ack  
....................  output_bit(sht_clk_pin, 0);  //clk low  
14AE:  BCF    F8B.1
14B0:  BCF    F94.1
....................  delay_us(1);  
14B2:  CLRWDT
14B4:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit  
14B6:  BSF    F94.0
14B8:  BCF    x81.0
14BA:  BTFSC  F82.0
14BC:  BSF    x81.0
....................  output_bit(sht_clk_pin, 1);  //clk high  
14BE:  BSF    F8B.1
14C0:  BCF    F94.1
....................  delay_us(1);  
14C2:  CLRWDT
14C4:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
14C6:  BCF    F8B.1
14C8:  BCF    F94.1
....................  return(ack);  
14CA:  MOVLW  00
14CC:  BTFSC  x81.0
14CE:  MOVLW  01
14D0:  MOVWF  01
.................... }  
14D2:  MOVLB  0
14D4:  RETLW  00
....................  
....................  
.................... //***** Function to read data from SHT75 *****  
....................  
.................... int16 comread (void)  
.................... {  
*
1512:  MOVLB  3
1514:  CLRF   x80
1516:  CLRF   x7F
....................  int8 i;  
....................  int16 iobyte = 0;  
....................  const int16 mask0 = 0x0000;  
....................  const int16 mask1 = 0x0001;  
....................  
....................  //shift in MSB data  
....................  for(i=0; i<8; i++)  
1518:  CLRF   x7E
151A:  MOVF   x7E,W
151C:  SUBLW  07
151E:  BNC   1544
....................   {  
....................    iobyte = iobyte << 1;  
1520:  BCF    FD8.0
1522:  RLCF   x7F,F
1524:  RLCF   x80,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
1526:  BSF    F8B.1
1528:  BCF    F94.1
....................    delay_us(1);  
152A:  CLRWDT
152C:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
152E:  BSF    F94.0
1530:  BTFSS  F82.0
1532:  BRA    1538
1534:  BSF    x7F.0
....................    else iobyte |= mask0;  
1536:  BRA    1538
....................    output_bit(sht_clk_pin, 0);                //clk low  
1538:  BCF    F8B.1
153A:  BCF    F94.1
....................    delay_us(1);  
153C:  CLRWDT
153E:  NOP   
....................   }  
1540:  INCF   x7E,F
1542:  BRA    151A
....................  
....................  //send ack 0 bit  
....................  output_bit(sht_data_pin, 0); //data low  
1544:  BCF    F8B.0
1546:  BCF    F94.0
....................  delay_us(1);  
1548:  CLRWDT
154A:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
154C:  BSF    F8B.1
154E:  BCF    F94.1
....................  delay_us(2);  
1550:  CLRWDT
1552:  BRA    1554
1554:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
1556:  BCF    F8B.1
1558:  BCF    F94.1
....................  delay_us(1);  
155A:  CLRWDT
155C:  NOP   
....................  output_float(sht_data_pin);  //data high  
155E:  BSF    F94.0
....................  
....................  //shift in LSB data  
....................  for(i=0; i<8; i++)  
1560:  CLRF   x7E
1562:  MOVF   x7E,W
1564:  SUBLW  07
1566:  BNC   158C
....................   {  
....................    iobyte = iobyte << 1;  
1568:  BCF    FD8.0
156A:  RLCF   x7F,F
156C:  RLCF   x80,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
156E:  BSF    F8B.1
1570:  BCF    F94.1
....................    delay_us(1);  
1572:  CLRWDT
1574:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
1576:  BSF    F94.0
1578:  BTFSS  F82.0
157A:  BRA    1580
157C:  BSF    x7F.0
....................    else iobyte |= mask0;  
157E:  BRA    1580
....................    output_bit(sht_clk_pin, 0);                //clk low  
1580:  BCF    F8B.1
1582:  BCF    F94.1
....................    delay_us(1);  
1584:  CLRWDT
1586:  NOP   
....................   }  
1588:  INCF   x7E,F
158A:  BRA    1562
....................  
....................  //send ack 1 bit  
....................  output_float(sht_data_pin);  //data high  
158C:  BSF    F94.0
....................  delay_us(1);  
158E:  CLRWDT
1590:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
1592:  BSF    F8B.1
1594:  BCF    F94.1
....................  delay_us(2);  
1596:  CLRWDT
1598:  BRA    159A
159A:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
159C:  BCF    F8B.1
159E:  BCF    F94.1
....................  
....................  return(iobyte);  
15A0:  MOVFF  37F,01
15A4:  MOVFF  380,02
.................... }  
15A8:  MOVLB  0
15AA:  RETLW  00
....................  
....................  
.................... //***** Function to wait for SHT75 reading *****  
....................  
.................... void comwait (void)  
.................... {  
....................  int16 sht_delay;  
....................  
....................  output_float(sht_data_pin);                     //data high  
*
14D6:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);                     //clk low  
14D8:  BCF    F8B.1
14DA:  BCF    F94.1
....................  delay_us(1);  
14DC:  CLRWDT
14DE:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms  
14E0:  MOVLB  3
14E2:  CLRF   x7F
14E4:  CLRF   x7E
14E6:  MOVF   x7F,W
14E8:  SUBLW  75
14EA:  BNC   150E
14EC:  BNZ   14F4
14EE:  MOVF   x7E,W
14F0:  SUBLW  2F
14F2:  BNC   150E
....................   {  
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready  
14F4:  BSF    F94.0
14F6:  BTFSC  F82.0
14F8:  BRA    14FC
14FA:  BRA    150E
....................    delay_us(10);  
14FC:  CLRWDT
14FE:  MOVLW  06
1500:  MOVWF  00
1502:  DECFSZ 00,F
1504:  BRA    1502
....................   }  
1506:  INCF   x7E,F
1508:  BTFSC  FD8.2
150A:  INCF   x7F,F
150C:  BRA    14E6
.................... }  
150E:  MOVLB  0
1510:  RETLW  00
....................  
....................  
.................... //***** Function to reset SHT75 communication *****  
....................  
.................... void comreset (void)  
.................... {  
....................  int8 i;  
....................  
....................  output_float(sht_data_pin);    //data high  
*
0554:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);    //clk low  
0556:  BCF    F8B.1
0558:  BCF    F94.1
....................  delay_us(2);  
055A:  CLRWDT
055C:  BRA    055E
055E:  NOP   
....................  for(i=0; i<9; i++)  
0560:  MOVLB  3
0562:  CLRF   x54
0564:  MOVF   x54,W
0566:  SUBLW  08
0568:  BNC   0582
....................   {  
....................    output_bit(sht_clk_pin, 1);  //toggle clk 9 times  
056A:  BSF    F8B.1
056C:  BCF    F94.1
....................    delay_us(2);  
056E:  CLRWDT
0570:  BRA    0572
0572:  NOP   
....................    output_bit(sht_clk_pin, 0);  
0574:  BCF    F8B.1
0576:  BCF    F94.1
....................    delay_us(2);  
0578:  CLRWDT
057A:  BRA    057C
057C:  NOP   
....................  }  
057E:  INCF   x54,F
0580:  BRA    0564
....................  comstart();  
0582:  MOVLB  0
0584:  RCALL  051C
.................... }  
0586:  GOTO   05BC (RETURN)
....................  
....................  
.................... //***** Function to soft reset SHT75 *****  
....................  
.................... void sht_soft_reset (void)  
.................... {  
....................  comreset();           //SHT75 communication reset  
....................  comwrite(0x1e);       //send SHT75 reset command  
....................  delay_ms(15);         //pause 15 ms  
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 temperature *****  
....................  
.................... int16 measuretemp (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();             //alert SHT75  
*
15AC:  CALL   051C
....................  ack = comwrite(0x03);   //send measure temp command and read ack status  
15B0:  MOVLW  03
15B2:  MOVLB  3
15B4:  MOVWF  x7E
15B6:  MOVLB  0
15B8:  RCALL  1470
15BA:  MOVLB  3
15BC:  BCF    x7B.0
15BE:  BTFSC  01.0
15C0:  BSF    x7B.0
....................  if(ack == 1) return 0;  // Debe retornar un valor      
15C2:  BTFSS  x7B.0
15C4:  BRA    15CE
15C6:  MOVLW  00
15C8:  MOVWF  01
15CA:  MOVWF  02
15CC:  BRA    15E6
....................  comwait();              //wait for SHT75 measurement to complete  
15CE:  MOVLB  0
15D0:  RCALL  14D6
....................  iobyte = comread();     //read SHT75 temp data  
15D2:  RCALL  1512
15D4:  MOVFF  02,37D
15D8:  MOVFF  01,37C
....................  return(iobyte);  
15DC:  MOVLB  3
15DE:  MOVFF  37C,01
15E2:  MOVFF  37D,02
.................... }  
15E6:  MOVLB  0
15E8:  GOTO   2316 (RETURN)
....................  
....................  
.................... //***** Function to measure SHT75 RH *****  
....................  
.................... int16 measurehumid (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();            //alert SHT75  
15EC:  CALL   051C
....................  ack = comwrite(0x05);  //send measure RH command and read ack status  
15F0:  MOVLW  05
15F2:  MOVLB  3
15F4:  MOVWF  x7E
15F6:  MOVLB  0
15F8:  RCALL  1470
15FA:  MOVLB  3
15FC:  BCF    x7B.0
15FE:  BTFSC  01.0
1600:  BSF    x7B.0
....................  if(ack == 1) return 0;   // Debe retornar algun valor 
1602:  BTFSS  x7B.0
1604:  BRA    160E
1606:  MOVLW  00
1608:  MOVWF  01
160A:  MOVWF  02
160C:  BRA    1626
....................  comwait();             //wait for SHT75 measurement to complete  
160E:  MOVLB  0
1610:  RCALL  14D6
....................  iobyte = comread();    //read SHT75 temp data  
1612:  RCALL  1512
1614:  MOVFF  02,37D
1618:  MOVFF  01,37C
....................  return(iobyte);  
161C:  MOVLB  3
161E:  MOVFF  37C,01
1622:  MOVFF  37D,02
.................... }  
1626:  MOVLB  0
1628:  GOTO   2322 (RETURN)
....................  
....................  
.................... //***** Function to calculate SHT75 temp & RH *****  
....................  
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue)  
.................... {  
....................  float rh; // float truehumid1, rh;  
....................  
....................  //calculate temperature reading  
....................  tc = ((float) temp * 0.01) - 40.0;  
*
233A:  MOVFF  37C,3A6
233E:  MOVFF  37B,3A5
2342:  CALL   162C
2346:  MOVFF  00,383
234A:  MOVFF  01,384
234E:  MOVFF  02,385
2352:  MOVFF  03,386
2356:  MOVFF  03,410
235A:  MOVFF  02,40F
235E:  MOVFF  01,40E
2362:  MOVFF  00,40D
2366:  MOVLW  0A
2368:  MOVLB  4
236A:  MOVWF  x14
236C:  MOVLW  D7
236E:  MOVWF  x13
2370:  MOVLW  23
2372:  MOVWF  x12
2374:  MOVLW  78
2376:  MOVWF  x11
2378:  MOVLB  0
237A:  CALL   1662
237E:  MOVFF  00,383
2382:  MOVFF  01,384
2386:  MOVFF  02,385
238A:  MOVFF  03,386
238E:  BSF    FD8.1
2390:  MOVFF  03,3A8
2394:  MOVFF  02,3A7
2398:  MOVFF  01,3A6
239C:  MOVFF  00,3A5
23A0:  MOVLB  3
23A2:  CLRF   xAC
23A4:  CLRF   xAB
23A6:  MOVLW  20
23A8:  MOVWF  xAA
23AA:  MOVLW  84
23AC:  MOVWF  xA9
23AE:  MOVLB  0
23B0:  CALL   1758
23B4:  MOVFF  03,2F5
23B8:  MOVFF  02,2F4
23BC:  MOVFF  01,2F3
23C0:  MOVFF  00,2F2
....................  
....................  //calculate Real RH reading  
....................  rh = (float) humid;  
23C4:  MOVFF  37E,3A6
23C8:  MOVFF  37D,3A5
23CC:  CALL   162C
23D0:  MOVFF  03,382
23D4:  MOVFF  02,381
23D8:  MOVFF  01,380
23DC:  MOVFF  00,37F
....................  
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0;  
23E0:  MOVFF  382,410
23E4:  MOVFF  381,40F
23E8:  MOVFF  380,40E
23EC:  MOVFF  37F,40D
23F0:  MOVLW  54
23F2:  MOVLB  4
23F4:  MOVWF  x14
23F6:  MOVLW  E3
23F8:  MOVWF  x13
23FA:  MOVLW  25
23FC:  MOVWF  x12
23FE:  MOVLW  7A
2400:  MOVWF  x11
2402:  MOVLB  0
2404:  CALL   1662
2408:  MOVFF  00,383
240C:  MOVFF  01,384
2410:  MOVFF  02,385
2414:  MOVFF  03,386
2418:  MOVFF  382,410
241C:  MOVFF  381,40F
2420:  MOVFF  380,40E
2424:  MOVFF  37F,40D
2428:  MOVFF  382,414
242C:  MOVFF  381,413
2430:  MOVFF  380,412
2434:  MOVFF  37F,411
2438:  CALL   1662
243C:  MOVFF  00,387
2440:  MOVFF  01,388
2444:  MOVFF  02,389
2448:  MOVFF  03,38A
244C:  MOVFF  03,410
2450:  MOVFF  02,40F
2454:  MOVFF  01,40E
2458:  MOVFF  00,40D
245C:  MOVLW  A2
245E:  MOVLB  4
2460:  MOVWF  x14
2462:  MOVLW  E7
2464:  MOVWF  x13
2466:  MOVLW  3B
2468:  MOVWF  x12
246A:  MOVLW  6C
246C:  MOVWF  x11
246E:  MOVLB  0
2470:  CALL   1662
2474:  BSF    FD8.1
2476:  MOVFF  386,3A8
247A:  MOVFF  385,3A7
247E:  MOVFF  384,3A6
2482:  MOVFF  383,3A5
2486:  MOVFF  03,3AC
248A:  MOVFF  02,3AB
248E:  MOVFF  01,3AA
2492:  MOVFF  00,3A9
2496:  CALL   1758
249A:  MOVFF  00,383
249E:  MOVFF  01,384
24A2:  MOVFF  02,385
24A6:  MOVFF  03,386
24AA:  BSF    FD8.1
24AC:  MOVFF  03,3A8
24B0:  MOVFF  02,3A7
24B4:  MOVFF  01,3A6
24B8:  MOVFF  00,3A5
24BC:  MOVLB  3
24BE:  CLRF   xAC
24C0:  CLRF   xAB
24C2:  CLRF   xAA
24C4:  MOVLW  81
24C6:  MOVWF  xA9
24C8:  MOVLB  0
24CA:  CALL   1758
24CE:  MOVFF  03,372
24D2:  MOVFF  02,371
24D6:  MOVFF  01,370
24DA:  MOVFF  00,36F
....................  
....................  //calculate True RH reading  
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin;  
24DE:  BSF    FD8.1
24E0:  MOVFF  2F5,3A8
24E4:  MOVFF  2F4,3A7
24E8:  MOVFF  2F3,3A6
24EC:  MOVFF  2F2,3A5
24F0:  MOVLB  3
24F2:  CLRF   xAC
24F4:  CLRF   xAB
24F6:  MOVLW  48
24F8:  MOVWF  xAA
24FA:  MOVLW  83
24FC:  MOVWF  xA9
24FE:  MOVLB  0
2500:  CALL   1758
2504:  MOVFF  00,383
2508:  MOVFF  01,384
250C:  MOVFF  02,385
2510:  MOVFF  03,386
2514:  MOVLW  AC
2516:  MOVLB  4
2518:  MOVWF  x10
251A:  MOVLW  C5
251C:  MOVWF  x0F
251E:  MOVLW  27
2520:  MOVWF  x0E
2522:  MOVLW  71
2524:  MOVWF  x0D
2526:  MOVFF  382,414
252A:  MOVFF  381,413
252E:  MOVFF  380,412
2532:  MOVFF  37F,411
2536:  MOVLB  0
2538:  CALL   1662
253C:  BCF    FD8.1
253E:  MOVLW  0A
2540:  MOVLB  3
2542:  MOVWF  xA8
2544:  MOVLW  D7
2546:  MOVWF  xA7
2548:  MOVLW  23
254A:  MOVWF  xA6
254C:  MOVLW  78
254E:  MOVWF  xA5
2550:  MOVFF  03,3AC
2554:  MOVFF  02,3AB
2558:  MOVFF  01,3AA
255C:  MOVFF  00,3A9
2560:  MOVLB  0
2562:  CALL   1758
2566:  MOVFF  386,410
256A:  MOVFF  385,40F
256E:  MOVFF  384,40E
2572:  MOVFF  383,40D
2576:  MOVFF  03,414
257A:  MOVFF  02,413
257E:  MOVFF  01,412
2582:  MOVFF  00,411
2586:  CALL   1662
258A:  MOVFF  00,383
258E:  MOVFF  01,384
2592:  MOVFF  02,385
2596:  MOVFF  03,386
259A:  BCF    FD8.1
259C:  MOVFF  03,3A8
25A0:  MOVFF  02,3A7
25A4:  MOVFF  01,3A6
25A8:  MOVFF  00,3A5
25AC:  MOVFF  372,3AC
25B0:  MOVFF  371,3AB
25B4:  MOVFF  370,3AA
25B8:  MOVFF  36F,3A9
25BC:  CALL   1758
25C0:  MOVFF  03,2F1
25C4:  MOVFF  02,2F0
25C8:  MOVFF  01,2EF
25CC:  MOVFF  00,2EE
.................... }  
....................  
....................  
.................... //***** Function to measure & calculate SHT75 temp & RH *****  
....................  
.................... void sht_rd (float & temp, float & truehumid)  
.................... {  
....................  int16 restemp, reshumid;  
....................  float realhumid;  
....................  restemp = 0; truehumid = 0;  
*
2300:  MOVLB  3
2302:  CLRF   x6C
2304:  CLRF   x6B
2306:  MOVLB  2
2308:  CLRF   xF1
230A:  CLRF   xF0
230C:  CLRF   xEF
230E:  CLRF   xEE
....................  
....................  restemp = measuretemp();    //measure temp  
2310:  MOVLB  0
2312:  GOTO   15AC
2316:  MOVFF  02,36C
231A:  MOVFF  01,36B
....................  reshumid = measurehumid();  //measure RH  
231E:  GOTO   15EC
2322:  MOVFF  02,36E
2326:  MOVFF  01,36D
....................  calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH  
232A:  MOVFF  36C,37C
232E:  MOVFF  36B,37B
2332:  MOVFF  36E,37E
2336:  MOVFF  36D,37D
*
25D0:  NOP   
.................... }  
....................  
....................  
.................... //***** Function to initialise SHT75 on power-up *****  
....................  
.................... void sht_init (void)  
.................... {  
....................  comreset();    //reset SHT75  
*
05BA:  BRA    0554
....................  delay_ms(20);  //delay for power-up  
05BC:  MOVLW  14
05BE:  MOVLB  3
05C0:  MOVWF  x74
05C2:  MOVLB  0
05C4:  RCALL  058A
.................... } 
05C6:  GOTO   4B86 (RETURN)
....................  
.................... #include <24512.C> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B1 
.................... #define EEPROM_SCL  PIN_B0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
1CD8:  MOVLW  08
1CDA:  MOVWF  01
1CDC:  BRA    1CDE
1CDE:  BCF    F8A.4
1CE0:  BCF    F93.4
1CE2:  BRA    1CE4
1CE4:  NOP   
1CE6:  MOVLB  3
1CE8:  RLCF   x98,F
1CEA:  BCF    F8A.5
1CEC:  BTFSC  FD8.0
1CEE:  BSF    F93.5
1CF0:  BTFSS  FD8.0
1CF2:  BCF    F93.5
1CF4:  BSF    F93.4
1CF6:  BTFSS  F81.4
1CF8:  BRA    1CF6
1CFA:  DECFSZ 01,F
1CFC:  BRA    1D00
1CFE:  BRA    1D04
1D00:  MOVLB  0
1D02:  BRA    1CDC
1D04:  BRA    1D06
1D06:  BCF    F8A.4
1D08:  BCF    F93.4
1D0A:  NOP   
1D0C:  BSF    F93.5
1D0E:  BRA    1D10
1D10:  NOP   
1D12:  BRA    1D14
1D14:  NOP   
1D16:  BSF    F93.4
1D18:  BTFSS  F81.4
1D1A:  BRA    1D18
1D1C:  CLRF   01
1D1E:  BRA    1D20
1D20:  NOP   
1D22:  BTFSC  F81.5
1D24:  BSF    01.0
1D26:  BCF    F8A.4
1D28:  BCF    F93.4
1D2A:  BCF    F8A.5
1D2C:  BCF    F93.5
1D2E:  MOVLB  0
1D30:  RETLW  00
1D32:  MOVLW  08
1D34:  MOVLB  3
1D36:  MOVWF  x84
1D38:  MOVFF  00,385
1D3C:  BSF    F93.5
1D3E:  BRA    1D40
1D40:  NOP   
1D42:  BSF    F93.4
1D44:  BTFSS  F81.4
1D46:  BRA    1D44
1D48:  BTFSC  F81.5
1D4A:  BSF    FD8.0
1D4C:  BTFSS  F81.5
1D4E:  BCF    FD8.0
1D50:  RLCF   01,F
1D52:  BRA    1D54
1D54:  BCF    F93.4
1D56:  BCF    F8A.4
1D58:  DECFSZ x84,F
1D5A:  BRA    1D3C
1D5C:  BSF    F93.5
1D5E:  BRA    1D60
1D60:  NOP   
1D62:  BCF    F8A.5
1D64:  MOVF   x85,W
1D66:  BTFSS  FD8.2
1D68:  BCF    F93.5
1D6A:  NOP   
1D6C:  BSF    F93.4
1D6E:  BTFSS  F81.4
1D70:  BRA    1D6E
1D72:  BRA    1D74
1D74:  BCF    F8A.4
1D76:  BCF    F93.4
1D78:  BRA    1D7A
1D7A:  NOP   
1D7C:  BCF    F8A.5
1D7E:  BCF    F93.5
1D80:  MOVLB  0
1D82:  GOTO   1DE0 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
05CA:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
05CC:  BSF    F93.5
....................  
.................... } 
05CE:  GOTO   4B8A (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
2786:  BSF    F93.5
2788:  BRA    278A
278A:  BSF    F93.4
278C:  BRA    278E
278E:  NOP   
2790:  BCF    F8A.5
2792:  BCF    F93.5
2794:  BRA    2796
2796:  BCF    F8A.4
2798:  BCF    F93.4
....................    i2c_write(0xa0); 
279A:  MOVLW  A0
279C:  MOVLB  3
279E:  MOVWF  x98
27A0:  MOVLB  0
27A2:  CALL   1CD8
....................    i2c_write(address>>8); 
27A6:  MOVFF  393,396
27AA:  MOVLB  3
27AC:  CLRF   x97
27AE:  MOVFF  393,398
27B2:  MOVLB  0
27B4:  CALL   1CD8
....................    i2c_write(address); 
27B8:  MOVFF  392,398
27BC:  CALL   1CD8
....................    i2c_write(data); 
27C0:  MOVFF  394,398
27C4:  CALL   1CD8
....................    i2c_stop(); 
27C8:  BCF    F93.5
27CA:  NOP   
27CC:  BSF    F93.4
27CE:  BTFSS  F81.4
27D0:  BRA    27CE
27D2:  BRA    27D4
27D4:  BRA    27D6
27D6:  NOP   
27D8:  BSF    F93.5
27DA:  BRA    27DC
....................    i2c_start(); 
27DC:  BSF    F93.5
27DE:  BRA    27E0
27E0:  BSF    F93.4
27E2:  BRA    27E4
27E4:  NOP   
27E6:  BCF    F8A.5
27E8:  BCF    F93.5
27EA:  BRA    27EC
27EC:  BCF    F8A.4
27EE:  BCF    F93.4
....................    status=i2c_write(0xa0); 
27F0:  MOVLW  A0
27F2:  MOVLB  3
27F4:  MOVWF  x98
27F6:  MOVLB  0
27F8:  CALL   1CD8
27FC:  MOVF   01,W
27FE:  MOVLB  3
2800:  BCF    x95.0
2802:  BTFSC  01.0
2804:  BSF    x95.0
....................    while(status==1) 
....................    { 
2806:  BTFSS  x95.0
2808:  BRA    2838
....................       i2c_start(); 
280A:  BSF    F93.5
280C:  BRA    280E
280E:  BSF    F93.4
2810:  BRA    2812
2812:  NOP   
2814:  BTFSS  F81.4
2816:  BRA    2814
2818:  BCF    F8A.5
281A:  BCF    F93.5
281C:  BRA    281E
281E:  BCF    F8A.4
2820:  BCF    F93.4
....................       status=i2c_write(0xa0); 
2822:  MOVLW  A0
2824:  MOVWF  x98
2826:  MOVLB  0
2828:  CALL   1CD8
282C:  MOVF   01,W
282E:  MOVLB  3
2830:  BCF    x95.0
2832:  BTFSC  01.0
2834:  BSF    x95.0
....................    } 
2836:  BRA    2806
....................    i2c_stop(); 
2838:  BCF    F93.5
283A:  NOP   
283C:  BSF    F93.4
283E:  BTFSS  F81.4
2840:  BRA    283E
2842:  BRA    2844
2844:  BRA    2846
2846:  NOP   
2848:  BSF    F93.5
284A:  BRA    284C
.................... } 
284C:  MOVLB  0
284E:  RETLW  00
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
1D86:  BSF    F93.5
1D88:  BRA    1D8A
1D8A:  BSF    F93.4
1D8C:  BRA    1D8E
1D8E:  NOP   
1D90:  BCF    F8A.5
1D92:  BCF    F93.5
1D94:  BRA    1D96
1D96:  BCF    F8A.4
1D98:  BCF    F93.4
....................    i2c_write(0xa0); 
1D9A:  MOVLW  A0
1D9C:  MOVLB  3
1D9E:  MOVWF  x98
1DA0:  MOVLB  0
1DA2:  RCALL  1CD8
....................    i2c_write(address>>8); 
1DA4:  MOVFF  381,383
1DA8:  MOVLB  3
1DAA:  CLRF   x84
1DAC:  MOVFF  381,398
1DB0:  MOVLB  0
1DB2:  RCALL  1CD8
....................    i2c_write(address); 
1DB4:  MOVFF  380,398
1DB8:  RCALL  1CD8
....................    i2c_start(); 
1DBA:  BSF    F93.5
1DBC:  BRA    1DBE
1DBE:  BSF    F93.4
1DC0:  BRA    1DC2
1DC2:  NOP   
1DC4:  BTFSS  F81.4
1DC6:  BRA    1DC4
1DC8:  BCF    F8A.5
1DCA:  BCF    F93.5
1DCC:  BRA    1DCE
1DCE:  BCF    F8A.4
1DD0:  BCF    F93.4
....................    i2c_write(0xa1); 
1DD2:  MOVLW  A1
1DD4:  MOVLB  3
1DD6:  MOVWF  x98
1DD8:  MOVLB  0
1DDA:  RCALL  1CD8
....................    data=i2c_read(0); 
1DDC:  CLRF   00
1DDE:  BRA    1D32
1DE0:  MOVFF  01,382
....................    i2c_stop(); 
1DE4:  BCF    F93.5
1DE6:  NOP   
1DE8:  BSF    F93.4
1DEA:  BTFSS  F81.4
1DEC:  BRA    1DEA
1DEE:  BRA    1DF0
1DF0:  BRA    1DF2
1DF2:  NOP   
1DF4:  BSF    F93.5
1DF6:  BRA    1DF8
....................    return(data); 
1DF8:  MOVLB  3
1DFA:  MOVFF  382,01
.................... } 
1DFE:  MOVLB  0
1E00:  RETLW  00
....................  
.................... #include "timeFunc.c" 
.................... typedef struct dateSt {         // estructura para la conversión de fecha 
....................    char  hour; 
....................    char  min; 
....................    char  sec; 
....................    char  day; 
....................    char  mon; 
....................    char  dow; 
....................    long  year; 
.................... } TDateSt; 
....................  
.................... const long  mes[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
.................... const char S2Ddays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................  
.................... char	dtFecha[10], dtHora[10]; 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | Date2Sec(TDateSt time) Convierte la fecha pasada en la estructura en segundos 
.................... | Parametro: 'time' : estructura tipo TDateSt 
.................... | RETURN VALUE: unsigned long (segundos) 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... int32  Date2Sec(TDateSt *time) 
.................... { 
....................    int32  t, xt; 
....................     
....................    xt = 365L * (int32)(time->year - 1970) + (int32)(mes[time->mon-1] + time->day - 1); 
*
0EA4:  MOVLW  06
0EA6:  MOVLB  3
0EA8:  ADDWF  x7A,W
0EAA:  MOVWF  FE9
0EAC:  MOVLW  00
0EAE:  ADDWFC x7B,W
0EB0:  MOVWF  FEA
0EB2:  MOVFF  FEC,385
0EB6:  MOVF   FED,F
0EB8:  MOVFF  FEF,384
0EBC:  MOVLW  B2
0EBE:  SUBWF  x84,W
0EC0:  MOVWF  00
0EC2:  MOVLW  07
0EC4:  SUBWFB x85,W
0EC6:  MOVWF  03
0EC8:  MOVF   00,W
0ECA:  MOVFF  03,01
0ECE:  CLRF   02
0ED0:  CLRF   03
0ED2:  MOVFF  03,387
0ED6:  MOVFF  02,386
0EDA:  MOVFF  01,385
0EDE:  MOVFF  00,384
0EE2:  MOVFF  FEA,389
0EE6:  MOVFF  FE9,388
0EEA:  CLRF   x96
0EEC:  CLRF   x95
0EEE:  MOVLW  01
0EF0:  MOVWF  x94
0EF2:  MOVLW  6D
0EF4:  MOVWF  x93
0EF6:  MOVFF  03,39A
0EFA:  MOVFF  02,399
0EFE:  MOVFF  01,398
0F02:  MOVFF  00,397
0F06:  MOVLB  0
0F08:  RCALL  0E48
0F0A:  MOVFF  389,FEA
0F0E:  MOVFF  388,FE9
0F12:  MOVFF  03,387
0F16:  MOVFF  02,386
0F1A:  MOVFF  01,385
0F1E:  MOVFF  00,384
0F22:  MOVLW  04
0F24:  MOVLB  3
0F26:  ADDWF  x7A,W
0F28:  MOVWF  FE9
0F2A:  MOVLW  00
0F2C:  ADDWFC x7B,W
0F2E:  MOVWF  FEA
0F30:  MOVLW  01
0F32:  SUBWF  FEF,W
0F34:  MOVWF  00
0F36:  BCF    FD8.0
0F38:  RLCF   00,F
0F3A:  MOVF   00,W
0F3C:  CLRF   03
0F3E:  MOVFF  FF2,38A
0F42:  BCF    FF2.7
0F44:  MOVLB  0
0F46:  CALL   00AE
0F4A:  TBLRD*+
0F4C:  MOVFF  FF5,03
0F50:  MOVLB  3
0F52:  BTFSC  x8A.7
0F54:  BSF    FF2.7
0F56:  MOVWF  x8A
0F58:  MOVFF  03,38B
0F5C:  MOVLW  03
0F5E:  ADDWF  x7A,W
0F60:  MOVWF  FE9
0F62:  MOVLW  00
0F64:  ADDWFC x7B,W
0F66:  MOVWF  FEA
0F68:  MOVF   FEF,W
0F6A:  ADDWF  x8A,F
0F6C:  MOVLW  00
0F6E:  ADDWFC x8B,F
0F70:  MOVLW  01
0F72:  SUBWF  x8A,W
0F74:  MOVWF  00
0F76:  MOVLW  00
0F78:  SUBWFB x8B,W
0F7A:  MOVWF  03
0F7C:  MOVF   00,W
0F7E:  MOVFF  03,01
0F82:  CLRF   02
0F84:  CLRF   03
0F86:  MOVF   00,W
0F88:  ADDWF  x84,W
0F8A:  MOVWF  x80
0F8C:  MOVF   01,W
0F8E:  ADDWFC x85,W
0F90:  MOVWF  x81
0F92:  MOVF   02,W
0F94:  ADDWFC x86,W
0F96:  MOVWF  x82
0F98:  MOVF   03,W
0F9A:  ADDWFC x87,W
0F9C:  MOVWF  x83
....................    xt += (int32)((time->year - 1969) >> 2); 
0F9E:  MOVLW  06
0FA0:  ADDWF  x7A,W
0FA2:  MOVWF  FE9
0FA4:  MOVLW  00
0FA6:  ADDWFC x7B,W
0FA8:  MOVWF  FEA
0FAA:  MOVFF  FEC,385
0FAE:  MOVF   FED,F
0FB0:  MOVFF  FEF,384
0FB4:  MOVLW  B1
0FB6:  SUBWF  x84,F
0FB8:  MOVLW  07
0FBA:  SUBWFB x85,F
0FBC:  RRCF   x85,W
0FBE:  MOVWF  03
0FC0:  RRCF   x84,W
0FC2:  MOVWF  02
0FC4:  RRCF   03,F
0FC6:  RRCF   02,F
0FC8:  MOVLW  3F
0FCA:  ANDWF  03,F
0FCC:  MOVFF  02,00
0FD0:  MOVFF  03,01
0FD4:  CLRF   02
0FD6:  CLRF   03
0FD8:  MOVF   00,W
0FDA:  ADDWF  x80,F
0FDC:  MOVF   01,W
0FDE:  ADDWFC x81,F
0FE0:  MOVF   02,W
0FE2:  ADDWFC x82,F
0FE4:  MOVF   03,W
0FE6:  ADDWFC x83,F
....................    if ((time->mon > 2) && ((time->year & 3) == 0)) xt++; 
0FE8:  MOVLW  04
0FEA:  ADDWF  x7A,W
0FEC:  MOVWF  FE9
0FEE:  MOVLW  00
0FF0:  ADDWFC x7B,W
0FF2:  MOVWF  FEA
0FF4:  MOVF   FEF,W
0FF6:  SUBLW  02
0FF8:  BC    102E
0FFA:  MOVLW  06
0FFC:  ADDWF  x7A,W
0FFE:  MOVWF  FE9
1000:  MOVLW  00
1002:  ADDWFC x7B,W
1004:  MOVWF  FEA
1006:  MOVFF  FEC,385
100A:  MOVF   FED,F
100C:  MOVFF  FEF,384
1010:  MOVLW  03
1012:  ANDWF  x84,F
1014:  CLRF   x85
1016:  MOVF   x84,F
1018:  BNZ   102E
101A:  MOVF   x85,F
101C:  BNZ   102E
101E:  MOVLW  01
1020:  ADDWF  x80,F
1022:  BTFSC  FD8.0
1024:  INCF   x81,F
1026:  BTFSC  FD8.2
1028:  INCF   x82,F
102A:  BTFSC  FD8.2
102C:  INCF   x83,F
....................    t = (int32)(time->sec) + 60L * ((int32)(time->min) + 60L * (int32)(time->hour + 24 * xt)); 
102E:  MOVLW  02
1030:  ADDWF  x7A,W
1032:  MOVWF  FE9
1034:  MOVLW  00
1036:  ADDWFC x7B,W
1038:  MOVWF  FEA
103A:  MOVF   FEF,W
103C:  CLRF   x87
103E:  CLRF   x86
1040:  CLRF   x85
1042:  MOVWF  x84
1044:  MOVLW  01
1046:  ADDWF  x7A,W
1048:  MOVWF  FE9
104A:  MOVLW  00
104C:  ADDWFC x7B,W
104E:  MOVWF  FEA
1050:  MOVF   FEF,W
1052:  CLRF   x8B
1054:  CLRF   x8A
1056:  CLRF   x89
1058:  MOVWF  x88
105A:  MOVFF  37A,FE9
105E:  MOVFF  37B,FEA
1062:  MOVFF  FEF,38C
1066:  MOVFF  FEA,38E
106A:  MOVFF  FE9,38D
106E:  CLRF   x96
1070:  CLRF   x95
1072:  CLRF   x94
1074:  MOVLW  18
1076:  MOVWF  x93
1078:  MOVFF  383,39A
107C:  MOVFF  382,399
1080:  MOVFF  381,398
1084:  MOVFF  380,397
1088:  MOVLB  0
108A:  RCALL  0E48
108C:  MOVFF  38E,FEA
1090:  MOVFF  38D,FE9
1094:  MOVLB  3
1096:  MOVF   x8C,W
1098:  ADDWF  00,F
109A:  MOVLW  00
109C:  ADDWFC 01,F
109E:  ADDWFC 02,F
10A0:  ADDWFC 03,F
10A2:  MOVFF  FEA,390
10A6:  MOVFF  FE9,38F
10AA:  CLRF   x96
10AC:  CLRF   x95
10AE:  CLRF   x94
10B0:  MOVLW  3C
10B2:  MOVWF  x93
10B4:  MOVFF  03,39A
10B8:  MOVFF  02,399
10BC:  MOVFF  01,398
10C0:  MOVFF  00,397
10C4:  MOVLB  0
10C6:  RCALL  0E48
10C8:  MOVFF  390,FEA
10CC:  MOVFF  38F,FE9
10D0:  MOVLB  3
10D2:  MOVF   x88,W
10D4:  ADDWF  00,F
10D6:  MOVF   x89,W
10D8:  ADDWFC 01,F
10DA:  MOVF   x8A,W
10DC:  ADDWFC 02,F
10DE:  MOVF   x8B,W
10E0:  ADDWFC 03,F
10E2:  MOVFF  03,38B
10E6:  MOVFF  02,38A
10EA:  MOVFF  01,389
10EE:  MOVFF  00,388
10F2:  MOVFF  FEA,392
10F6:  MOVFF  FE9,391
10FA:  CLRF   x96
10FC:  CLRF   x95
10FE:  CLRF   x94
1100:  MOVLW  3C
1102:  MOVWF  x93
1104:  MOVFF  03,39A
1108:  MOVFF  02,399
110C:  MOVFF  01,398
1110:  MOVFF  00,397
1114:  MOVLB  0
1116:  RCALL  0E48
1118:  MOVFF  392,FEA
111C:  MOVFF  391,FE9
1120:  MOVF   00,W
1122:  MOVLB  3
1124:  ADDWF  x84,W
1126:  MOVWF  x7C
1128:  MOVF   01,W
112A:  ADDWFC x85,W
112C:  MOVWF  x7D
112E:  MOVF   02,W
1130:  ADDWFC x86,W
1132:  MOVWF  x7E
1134:  MOVF   03,W
1136:  ADDWFC x87,W
1138:  MOVWF  x7F
....................    return t;    
113A:  MOVFF  37C,00
113E:  MOVFF  37D,01
1142:  MOVFF  37E,02
1146:  MOVFF  37F,03
.................... } 
114A:  MOVLB  0
114C:  GOTO   129E (RETURN)
.................... //----------------------------------------------------------------------------------------------------- 
....................  
.................... /*------------------------------------------------------------------------------------------------------ 
.................... |  Sec2Date(unsigned long x, TDateSt *pD) 
.................... |  Convierte la fecha expresada en segundos a día, mes, año, día de la semana, horas, minutos y segundos. 
.................... |  Parametro: 'x'   : fecha en segundos 
.................... |   		  'pD'  : puntero a una estructura tipo TDateSt donde se devuelve el resultado 
.................... |  RETURN VALUE:  ninguno 
.................... ------------------------------------------------------------------------------------------------------*/ 
.................... void Sec2Date(int32 x, TDateSt *pD) 
.................... { 
....................    int32 iMin, iHor, iDay; 
....................    long   hpery; 
....................    int32 i, cumdays; 
....................  
....................    iMin = x / 60; 
....................    pD->sec = (char)(x - (60 * iMin)); 
....................    iHor = iMin / 60; 
....................    pD->min = (char)(iMin - 60 * iHor); 
....................    iDay = iHor / 24; 
....................    pD->hour = (char)(iHor - 24 * iDay); 
....................    i = (int32)(iHor / (1461L * 24L)); 
....................    cumdays = 1461L * i; 
....................    pD->year = (long)(i << 2); 
....................    pD->year += (long)1970; 
....................    iHor %= 1461L * 24L; 
....................    for (;;) { 
....................      hpery = 365 * 24; 
....................      if ((pD->year & 3) == 0) hpery += 24; 
....................      if (iHor < (int32)hpery) break; 
....................      cumdays += hpery / 24; 
....................      pD->year++; 
....................      iHor -= hpery; 
....................    } 
....................    iHor /= 24; 
....................    cumdays += (long)iHor + 4; 
....................    pD->dow = (char)((cumdays % 7)+1); 
....................    pD->day = (char)iHor; 
....................    iHor++; 
....................    if ((pD->year & 3) == 0) { 
....................      if (iHor > 60) 
....................         iHor--; 
....................      else 
....................         if (iHor == 60) { 
....................            pD->mon = 2; 
....................            pD->day = 29; 
....................            return; 
....................         } 
....................    } 
....................    for (pD->mon = 0; S2Ddays[pD->mon] < (int)iHor; pD->mon++)  iHor -= S2Ddays[pD->mon]; 
....................    pD->day = (char)iHor; 
....................    pD->mon += (char)1; 
....................    return; 
.................... } 
.................... //---------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | GetDateTime(char *dt) | Obtiene la fecha y hora del rtc y lo retorna en un string 
.................... | Parametro: puntero a char destino de cadena 
.................... | RETURN VALUE: ninguno 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... void GetDateTime(char *dt){ 
.................... 	BYTE  		hora, min, sec, dow, dia, mes, year; 
....................  
.................... 	rtc_get_date(dia, mes, year, dow); 
.................... 	rtc_get_time(hora, min, sec); 
.................... 	sprintf(dt, "%02d%02d%02d%02d%02d", year, mes, dia, hora, min);	 
.................... } 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | CurrDateTime(void) | Obtiene la fecha y hora del rtc y lo convierte retorna en segundos 
.................... | Parametro: puntero a char destino de cadena 
.................... | RETURN VALUE: unsigned long (segundos) 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... int32 CurrDateTime(void){ 
.................... 	BYTE  		hora, min, sec, dow, dia, mes, year; 
.................... 	TDateSt 	dt; 
....................  
.................... 	rtc_get_date(dia, mes, year, dow); 
.................... 	rtc_get_time(hora, min, sec); 
.................... 	// 
.................... 	sprintf(dtFecha, "%02d%02d%02d", year, mes, dia); 
*
1206:  MOVLW  01
1208:  MOVLB  1
120A:  MOVWF  x47
120C:  MOVLW  32
120E:  MOVWF  x46
1210:  MOVFF  371,3FD
1214:  MOVLW  01
1216:  MOVLB  3
1218:  MOVWF  xFE
121A:  MOVLB  0
121C:  RCALL  0CE0
121E:  MOVFF  370,3FD
1222:  MOVLW  01
1224:  MOVLB  3
1226:  MOVWF  xFE
1228:  MOVLB  0
122A:  RCALL  0CE0
122C:  MOVFF  36F,3FD
1230:  MOVLW  01
1232:  MOVLB  3
1234:  MOVWF  xFE
1236:  MOVLB  0
1238:  RCALL  0CE0
.................... 	sprintf(dtHora, "%02d:%02d", hora, min); 
123A:  MOVLW  01
123C:  MOVLB  1
123E:  MOVWF  x47
1240:  MOVLW  3C
1242:  MOVWF  x46
1244:  MOVFF  36B,3FD
1248:  MOVLW  01
124A:  MOVLB  3
124C:  MOVWF  xFE
124E:  MOVLB  0
1250:  RCALL  0CE0
1252:  MOVLW  3A
1254:  MOVLB  4
1256:  MOVWF  x0D
1258:  MOVLB  0
125A:  RCALL  0CBE
125C:  MOVFF  36C,3FD
1260:  MOVLW  01
1262:  MOVLB  3
1264:  MOVWF  xFE
1266:  MOVLB  0
1268:  RCALL  0CE0
.................... 	// 
.................... 	dt.hour = hora; 
126A:  MOVFF  36B,372
.................... 	dt.min = min; 
126E:  MOVFF  36C,373
.................... 	dt.sec = sec; 
1272:  MOVFF  36D,374
.................... 	dt.day = dia; 
1276:  MOVFF  36F,375
.................... 	dt.mon = mes; 
127A:  MOVFF  370,376
.................... 	dt.dow = dow; 
127E:  MOVFF  36E,377
.................... 	dt.year = year + 2000; 
1282:  MOVLW  D0
1284:  MOVLB  3
1286:  ADDWF  x71,W
1288:  MOVWF  x78
128A:  MOVLW  07
128C:  MOVWF  x79
128E:  BTFSC  FD8.0
1290:  INCF   x79,F
.................... 	return Date2Sec(&dt); 
1292:  MOVLW  03
1294:  MOVWF  x7B
1296:  MOVLW  72
1298:  MOVWF  x7A
129A:  MOVLB  0
129C:  BRA    0EA4
.................... } 
129E:  RETLW  00
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... long LeerSmsCmd(char *sms) ; 
.................... void Leer_sensores(char prog); 
.................... void GenerateToken(void); 
.................... void clear_var(char* var); 
.................... void verifica_eeprom(void); 
.................... long EnviarSms(char *sms, char *tel); 
.................... float obtenerPresion(void); 
.................... char obtenerIntensidad(int32 seconds, float countPrec); 
.................... void calcularTempHum(float & temp, float & truehumid);  
.................... void inicializa_eeprom(void); 
.................... float obtenerTempInt(void); 
.................... void reinicioOK(void); 
.................... void construirTextoSms(char* sms, char prog); 
.................... void concatVariableSeparator(char* sms); 
....................  
.................... // ------------------ Comienzo código ----------------------------------- 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... char telnum[] = "+5493416527105"; 
.................... char sepVar[] = "*"; 
.................... //char telnum[] = "+5493415460866"; 
.................... //------------------- Variables usadas como Banderas ------------------- 
.................... short		flagInt2Edge; 
.................... long  		adc_val, countPrec, timeMed, timeMedTmp, currSmsId, timeChkTmp, timeChk, timeRestart;			//16bits 
.................... float 		ctePluv;		 
.................... int   		runOk, resProc, idLastSmsOut, memoryFull, smsMemSnd, startMeasure, startCheck, startRestart,llueveAhora; 
.................... int32  	    secUltMed;	 
.................... BYTE		sensorHab;	// Tiene el estado de los sensores habilitados 
.................... char  		tokenSrv[3], tokenEma[3], smsText[SZ_SMSTXT], smsOut[SZ_SMSTXT], telaux[SZ_TELEFONO], charFloat1[10]; 
.................... long  		address, contData; 
.................... BYTE		data, temp; 
....................  
.................... struct medSrt{ 
.................... 	int32	dateTime;			// 4 Bytes Fecha y hora en binario 
.................... 	float	humedad;			// 4 Bytes 
.................... 	float	tempExt;			// 4 bytes 
.................... 	float	precip;				// 4 Bytes 
.................... 	char	intensidad;			// 1 Bytes 
.................... 	float	preasure;			// 4 bytes 
.................... 	long	reservado;			// 1 byte (reservado) 
.................... };								// 22 Bytes 
....................  
.................... struct medSrt dataMed; 
.................... struct medSrt readMed; 
....................  
.................... #define SZ_DATALOG	sizeof(dataMed)		// Tamaño de los registro de log (20) 
....................  
.................... struct alarmaSt { 
.................... 	char	activa;				// Indica alarma activa 
.................... 	char	variable;			// Variable a ser monitoreada 
.................... 	float	max_value;			// Valor maximo que dispara alarma 
.................... 	float	min_value;			// Valor minimo que dispara alarma 
.................... 	int8	cnValid;			// Contador para validar alarma 
.................... };								// 1 + 1 + 4 + 4 + 1 = 11 bytes 
....................  
.................... struct alarmaSt alarm[5];			// Matriz de deficion de alarmas 55 bytes 
....................  
.................... #define SZ_ALRMSTR	55			// Tamaño registro de alarma 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... |  void ReadAlarmStruct(void)	Lee alarmas guardadas en eeprom interna 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void ReadAlarmStruct(void) 
.................... { 
.................... 	long	addtmp; 
.................... 	char	*p; 
.................... 	int		i; 
.................... 	 
.................... 	p = &alarm[0]; 
*
0414:  MOVLW  03
0416:  MOVLB  3
0418:  MOVWF  x57
041A:  MOVLW  18
041C:  MOVWF  x56
.................... 	addtmp = ADDR_ALARM; 
041E:  CLRF   x55
0420:  MOVLW  32
0422:  MOVWF  x54
.................... 	for (i = 0; i < SZ_ALRMSTR; i++){ 
0424:  CLRF   x58
0426:  MOVF   x58,W
0428:  SUBLW  36
042A:  BNC   043C
.................... 		//TODO 
.................... 		//*p = read_eeprom(addtmp); 
.................... 		p++; 
042C:  INCF   x56,F
042E:  BTFSC  FD8.2
0430:  INCF   x57,F
.................... 		addtmp++; 
0432:  INCF   x54,F
0434:  BTFSC  FD8.2
0436:  INCF   x55,F
.................... 	} 
0438:  INCF   x58,F
043A:  BRA    0426
.................... } 
043C:  MOVLB  0
043E:  GOTO   4B5A (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... |  void WriteAlarmStruct(void)	Escribe alarmas en eeprom interna 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void WriteAlarmStruct(void) 
.................... { 
.................... 	long	addtmp; 
.................... 	char	*p; 
.................... 	int		i; 
.................... 	 
.................... 	p = &alarm[0]; 
*
49D8:  MOVLW  03
49DA:  MOVLB  3
49DC:  MOVWF  x57
49DE:  MOVLW  18
49E0:  MOVWF  x56
.................... 	addtmp = ADDR_ALARM; 
49E2:  CLRF   x55
49E4:  MOVLW  32
49E6:  MOVWF  x54
.................... 	for (i = 0; i < SZ_ALRMSTR; i++){ 
49E8:  CLRF   x58
49EA:  MOVF   x58,W
49EC:  SUBLW  36
49EE:  BNC   4A00
.................... 		//TODO write_eeprom (addtmp, *p); 
.................... 		p++; 
49F0:  INCF   x56,F
49F2:  BTFSC  FD8.2
49F4:  INCF   x57,F
.................... 		addtmp++; 
49F6:  INCF   x54,F
49F8:  BTFSC  FD8.2
49FA:  INCF   x55,F
.................... 	} 
49FC:  INCF   x58,F
49FE:  BRA    49EA
.................... } 
4A00:  MOVLB  0
4A02:  GOTO   4F1E (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | int CheckAlarmValues(void)   
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... int CheckAlarmValues(void) 
.................... { 
.................... 	int i, res; 
.................... 	char auxSms[10]; 
.................... 	Leer_sensores(1);						// Lee sensores 
*
3056:  MOVLW  01
3058:  MOVLB  3
305A:  MOVWF  x60
305C:  MOVLB  0
305E:  CALL   22E6
.................... 	res = 0; 
3062:  MOVLB  3
3064:  CLRF   x55
.................... 	for (i = 0; i < 5; i++){ 
3066:  CLRF   x54
3068:  MOVF   x54,W
306A:  SUBLW  04
306C:  BTFSS  FD8.0
306E:  BRA    3732
.................... 		if (alarm[i].activa){ 
3070:  MOVF   x54,W
3072:  MULLW  0B
3074:  MOVF   FF3,W
3076:  CLRF   x61
3078:  MOVWF  x60
307A:  MOVLW  18
307C:  ADDWF  x60,W
307E:  MOVWF  FE9
3080:  MOVLW  03
3082:  ADDWFC x61,W
3084:  MOVWF  FEA
3086:  MOVF   FEF,F
3088:  BTFSC  FD8.2
308A:  BRA    372A
.................... 			switch(alarm[i].variable){ 
308C:  MOVF   x54,W
308E:  MULLW  0B
3090:  MOVF   FF3,W
3092:  CLRF   x61
3094:  MOVWF  x60
3096:  MOVLW  01
3098:  ADDWF  x60,W
309A:  MOVWF  01
309C:  MOVLW  00
309E:  ADDWFC x61,W
30A0:  MOVWF  03
30A2:  MOVF   01,W
30A4:  ADDLW  18
30A6:  MOVWF  FE9
30A8:  MOVLW  03
30AA:  ADDWFC 03,W
30AC:  MOVWF  FEA
30AE:  MOVF   FEF,W
30B0:  XORLW  54
30B2:  MOVLB  0
30B4:  BZ    30CA
30B6:  XORLW  1C
30B8:  BTFSC  FD8.2
30BA:  BRA    33F6
30BC:  XORLW  04
30BE:  BTFSC  FD8.2
30C0:  BRA    3722
30C2:  XORLW  1C
30C4:  BTFSC  FD8.2
30C6:  BRA    3722
30C8:  BRA    3722
.................... 				case 'T':					// Temperatura 
.................... 					if (dataMed.tempExt > alarm[i].max_value){		// Verifica condicion de maximo 
30CA:  MOVLB  3
30CC:  MOVF   x54,W
30CE:  MULLW  0B
30D0:  MOVF   FF3,W
30D2:  CLRF   x61
30D4:  MOVWF  x60
30D6:  MOVLW  02
30D8:  ADDWF  x60,W
30DA:  MOVWF  01
30DC:  MOVLW  00
30DE:  ADDWFC x61,W
30E0:  MOVWF  03
30E2:  MOVF   01,W
30E4:  ADDLW  18
30E6:  MOVWF  FE9
30E8:  MOVLW  03
30EA:  ADDWFC 03,W
30EC:  MOVWF  FEA
30EE:  MOVFF  FEF,00
30F2:  MOVFF  FEC,01
30F6:  MOVFF  FEC,02
30FA:  MOVFF  FEC,03
30FE:  MOVFF  03,37A
3102:  MOVFF  02,379
3106:  MOVFF  01,378
310A:  MOVFF  00,377
310E:  MOVFF  2F5,37E
3112:  MOVFF  2F4,37D
3116:  MOVFF  2F3,37C
311A:  MOVFF  2F2,37B
311E:  MOVLB  0
3120:  CALL   19D0
3124:  BTFSS  FD8.0
3126:  BRA    3240
.................... 						alarm[i].cnValid++; 
3128:  MOVLB  3
312A:  MOVF   x54,W
312C:  MULLW  0B
312E:  MOVF   FF3,W
3130:  CLRF   x61
3132:  MOVWF  x60
3134:  MOVLW  0A
3136:  ADDWF  x60,W
3138:  MOVWF  01
313A:  MOVLW  00
313C:  ADDWFC x61,W
313E:  MOVWF  03
3140:  MOVF   01,W
3142:  ADDLW  18
3144:  MOVWF  FE9
3146:  MOVLW  03
3148:  ADDWFC 03,W
314A:  MOVWF  FEA
314C:  INCF   FEF,F
.................... 						if (alarm[i].cnValid > MAX_CNALARM){  
314E:  MOVF   x54,W
3150:  MULLW  0B
3152:  MOVF   FF3,W
3154:  CLRF   x61
3156:  MOVWF  x60
3158:  MOVLW  0A
315A:  ADDWF  x60,W
315C:  MOVWF  01
315E:  MOVLW  00
3160:  ADDWFC x61,W
3162:  MOVWF  03
3164:  MOVF   01,W
3166:  ADDLW  18
3168:  MOVWF  FE9
316A:  MOVLW  03
316C:  ADDWFC 03,W
316E:  MOVWF  FEA
3170:  MOVF   FEF,W
3172:  SUBLW  03
3174:  BC    323C
.................... 							res = 0x01;							// Activa condicion de alarma por maximo 
3176:  MOVLW  01
3178:  MOVWF  x55
.................... 							alarm[i].cnValid = 0;					// Pone contador de condicion de alarma en 0 
317A:  MOVF   x54,W
317C:  MULLW  0B
317E:  MOVF   FF3,W
3180:  CLRF   x61
3182:  MOVWF  x60
3184:  MOVLW  0A
3186:  ADDWF  x60,W
3188:  MOVWF  01
318A:  MOVLW  00
318C:  ADDWFC x61,W
318E:  MOVWF  03
3190:  MOVF   01,W
3192:  ADDLW  18
3194:  MOVWF  FE9
3196:  MOVLW  03
3198:  ADDWFC 03,W
319A:  MOVWF  FEA
319C:  CLRF   FEF
.................... 							GenerateToken(); 
319E:  MOVLB  0
31A0:  CALL   0DDA
.................... 							sprintf(auxSms, "%4f", dataMed.tempExt); 
31A4:  MOVLW  03
31A6:  MOVLB  1
31A8:  MOVWF  x47
31AA:  MOVLW  56
31AC:  MOVWF  x46
31AE:  MOVLW  89
31B0:  MOVWF  FE9
31B2:  MOVFF  2F5,3FF
31B6:  MOVFF  2F4,3FE
31BA:  MOVFF  2F3,3FD
31BE:  MOVFF  2F2,3FC
31C2:  MOVLW  06
31C4:  MOVLB  4
31C6:  MOVWF  x00
31C8:  MOVLB  0
31CA:  CALL   29A6
.................... 							auxSms[4] = 0; 
31CE:  MOVLB  3
31D0:  CLRF   x5A
.................... 							sprintf(smsOut, "A|T|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
31D2:  MOVLW  02
31D4:  MOVLB  1
31D6:  MOVWF  x47
31D8:  MOVLW  27
31DA:  MOVWF  x46
31DC:  MOVLW  60
31DE:  MOVWF  FF6
31E0:  MOVLW  02
31E2:  MOVWF  FF7
31E4:  MOVLW  04
31E6:  MOVLB  3
31E8:  MOVWF  x60
31EA:  MOVLB  0
31EC:  CALL   12A0
31F0:  MOVLW  03
31F2:  MOVWF  FEA
31F4:  MOVLW  56
31F6:  MOVWF  FE9
31F8:  CALL   12C8
31FC:  MOVLW  7C
31FE:  MOVLB  4
3200:  MOVWF  x0D
3202:  MOVLB  0
3204:  CALL   0CBE
3208:  MOVFF  17F,40D
320C:  CALL   0CBE
3210:  MOVFF  180,40D
3214:  CALL   0CBE
.................... 							idLastSmsOut = EnviarSms(smsOut, telnum);	 
3218:  MOVLW  02
321A:  MOVLB  3
321C:  MOVWF  x61
321E:  MOVLW  27
3220:  MOVWF  x60
3222:  MOVLW  01
3224:  MOVWF  x63
3226:  MOVLW  48
3228:  MOVWF  x62
322A:  MOVLB  0
322C:  CALL   131C
3230:  MOVFF  01,170
.................... 							return res; 
3234:  MOVLB  3
3236:  MOVFF  355,01
323A:  BRA    3736
.................... 						} 
.................... 					} 
.................... 					else{  
323C:  BRA    33F2
323E:  MOVLB  0
.................... 						if (dataMed.tempExt < alarm[i].min_value){	// Verifica condicion de minimo 
3240:  MOVLB  3
3242:  MOVF   x54,W
3244:  MULLW  0B
3246:  MOVF   FF3,W
3248:  CLRF   x61
324A:  MOVWF  x60
324C:  MOVLW  06
324E:  ADDWF  x60,W
3250:  MOVWF  01
3252:  MOVLW  00
3254:  ADDWFC x61,W
3256:  MOVWF  03
3258:  MOVF   01,W
325A:  ADDLW  18
325C:  MOVWF  FE9
325E:  MOVLW  03
3260:  ADDWFC 03,W
3262:  MOVWF  FEA
3264:  MOVFF  FEF,00
3268:  MOVFF  FEC,01
326C:  MOVFF  FEC,02
3270:  MOVFF  FEC,03
3274:  MOVFF  2F5,37A
3278:  MOVFF  2F4,379
327C:  MOVFF  2F3,378
3280:  MOVFF  2F2,377
3284:  MOVFF  03,37E
3288:  MOVFF  02,37D
328C:  MOVFF  01,37C
3290:  MOVFF  00,37B
3294:  MOVLB  0
3296:  CALL   19D0
329A:  BTFSS  FD8.0
329C:  BRA    33CC
.................... 							alarm[i].cnValid--; 
329E:  MOVLB  3
32A0:  MOVF   x54,W
32A2:  MULLW  0B
32A4:  MOVF   FF3,W
32A6:  CLRF   x61
32A8:  MOVWF  x60
32AA:  MOVLW  0A
32AC:  ADDWF  x60,W
32AE:  MOVWF  01
32B0:  MOVLW  00
32B2:  ADDWFC x61,W
32B4:  MOVWF  03
32B6:  MOVF   01,W
32B8:  ADDLW  18
32BA:  MOVWF  FE9
32BC:  MOVLW  03
32BE:  ADDWFC 03,W
32C0:  MOVWF  FEA
32C2:  DECF   FEF,F
.................... 							if ((alarm[i].cnValid * (-1)) > MAX_CNALARM){  
32C4:  MOVF   x54,W
32C6:  MULLW  0B
32C8:  MOVF   FF3,W
32CA:  CLRF   x61
32CC:  MOVWF  x60
32CE:  MOVLW  0A
32D0:  ADDWF  x60,W
32D2:  MOVWF  01
32D4:  MOVLW  00
32D6:  ADDWFC x61,W
32D8:  MOVWF  03
32DA:  MOVF   01,W
32DC:  ADDLW  18
32DE:  MOVWF  FE9
32E0:  MOVLW  03
32E2:  ADDWFC 03,W
32E4:  MOVWF  FEA
32E6:  MOVFF  FEF,404
32EA:  MOVLW  FF
32EC:  MOVLB  4
32EE:  MOVWF  x05
32F0:  MOVLB  0
32F2:  CALL   0A8E
32F6:  BTFSC  01.7
32F8:  BRA    33CA
32FA:  MOVF   01,W
32FC:  SUBLW  03
32FE:  BC    33CA
.................... 								res = 0x02;						// Activa condicion de alarma por mínimo 
3300:  MOVLW  02
3302:  MOVLB  3
3304:  MOVWF  x55
.................... 								alarm[i].cnValid = 0;				// Pone contador de condicion de alarma en 0 
3306:  MOVF   x54,W
3308:  MULLW  0B
330A:  MOVF   FF3,W
330C:  CLRF   x61
330E:  MOVWF  x60
3310:  MOVLW  0A
3312:  ADDWF  x60,W
3314:  MOVWF  01
3316:  MOVLW  00
3318:  ADDWFC x61,W
331A:  MOVWF  03
331C:  MOVF   01,W
331E:  ADDLW  18
3320:  MOVWF  FE9
3322:  MOVLW  03
3324:  ADDWFC 03,W
3326:  MOVWF  FEA
3328:  CLRF   FEF
.................... 								GenerateToken(); 
332A:  MOVLB  0
332C:  CALL   0DDA
.................... 								sprintf(auxSms, "%4f", dataMed.tempExt); 
3330:  MOVLW  03
3332:  MOVLB  1
3334:  MOVWF  x47
3336:  MOVLW  56
3338:  MOVWF  x46
333A:  MOVLW  89
333C:  MOVWF  FE9
333E:  MOVFF  2F5,3FF
3342:  MOVFF  2F4,3FE
3346:  MOVFF  2F3,3FD
334A:  MOVFF  2F2,3FC
334E:  MOVLW  06
3350:  MOVLB  4
3352:  MOVWF  x00
3354:  MOVLB  0
3356:  CALL   29A6
.................... 								auxSms[4] = 0; 
335A:  MOVLB  3
335C:  CLRF   x5A
.................... 								sprintf(smsOut, "A|T|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
335E:  MOVLW  02
3360:  MOVLB  1
3362:  MOVWF  x47
3364:  MOVLW  27
3366:  MOVWF  x46
3368:  MOVLW  6C
336A:  MOVWF  FF6
336C:  MOVLW  02
336E:  MOVWF  FF7
3370:  MOVLW  04
3372:  MOVLB  3
3374:  MOVWF  x60
3376:  MOVLB  0
3378:  CALL   12A0
337C:  MOVLW  03
337E:  MOVWF  FEA
3380:  MOVLW  56
3382:  MOVWF  FE9
3384:  CALL   12C8
3388:  MOVLW  7C
338A:  MOVLB  4
338C:  MOVWF  x0D
338E:  MOVLB  0
3390:  CALL   0CBE
3394:  MOVFF  17F,40D
3398:  CALL   0CBE
339C:  MOVFF  180,40D
33A0:  CALL   0CBE
.................... 								idLastSmsOut = EnviarSms(smsOut, telnum);	 
33A4:  MOVLW  02
33A6:  MOVLB  3
33A8:  MOVWF  x61
33AA:  MOVLW  27
33AC:  MOVWF  x60
33AE:  MOVLW  01
33B0:  MOVWF  x63
33B2:  MOVLW  48
33B4:  MOVWF  x62
33B6:  MOVLB  0
33B8:  CALL   131C
33BC:  MOVFF  01,170
.................... 								return res; 
33C0:  MOVLB  3
33C2:  MOVFF  355,01
33C6:  BRA    3736
33C8:  MOVLB  0
.................... 							} 
.................... 						} 
.................... 						else{ 
33CA:  BRA    33F4
.................... 							alarm[i].cnValid = 0;					// En estado normal pone contador de alarma en 0 
33CC:  MOVLB  3
33CE:  MOVF   x54,W
33D0:  MULLW  0B
33D2:  MOVF   FF3,W
33D4:  CLRF   x61
33D6:  MOVWF  x60
33D8:  MOVLW  0A
33DA:  ADDWF  x60,W
33DC:  MOVWF  01
33DE:  MOVLW  00
33E0:  ADDWFC x61,W
33E2:  MOVWF  03
33E4:  MOVF   01,W
33E6:  ADDLW  18
33E8:  MOVWF  FE9
33EA:  MOVLW  03
33EC:  ADDWFC 03,W
33EE:  MOVWF  FEA
33F0:  CLRF   FEF
33F2:  MOVLB  0
.................... 						} 
.................... 					} 
.................... 					break; 
33F4:  BRA    372C
.................... 				case 'H':					// Humedad 
.................... 					if (dataMed.humedad > alarm[i].max_value){		// Verifica condicion de maximo 
33F6:  MOVLB  3
33F8:  MOVF   x54,W
33FA:  MULLW  0B
33FC:  MOVF   FF3,W
33FE:  CLRF   x61
3400:  MOVWF  x60
3402:  MOVLW  02
3404:  ADDWF  x60,W
3406:  MOVWF  01
3408:  MOVLW  00
340A:  ADDWFC x61,W
340C:  MOVWF  03
340E:  MOVF   01,W
3410:  ADDLW  18
3412:  MOVWF  FE9
3414:  MOVLW  03
3416:  ADDWFC 03,W
3418:  MOVWF  FEA
341A:  MOVFF  FEF,00
341E:  MOVFF  FEC,01
3422:  MOVFF  FEC,02
3426:  MOVFF  FEC,03
342A:  MOVFF  03,37A
342E:  MOVFF  02,379
3432:  MOVFF  01,378
3436:  MOVFF  00,377
343A:  MOVFF  2F1,37E
343E:  MOVFF  2F0,37D
3442:  MOVFF  2EF,37C
3446:  MOVFF  2EE,37B
344A:  MOVLB  0
344C:  CALL   19D0
3450:  BTFSS  FD8.0
3452:  BRA    356C
.................... 						alarm[i].cnValid++; 
3454:  MOVLB  3
3456:  MOVF   x54,W
3458:  MULLW  0B
345A:  MOVF   FF3,W
345C:  CLRF   x61
345E:  MOVWF  x60
3460:  MOVLW  0A
3462:  ADDWF  x60,W
3464:  MOVWF  01
3466:  MOVLW  00
3468:  ADDWFC x61,W
346A:  MOVWF  03
346C:  MOVF   01,W
346E:  ADDLW  18
3470:  MOVWF  FE9
3472:  MOVLW  03
3474:  ADDWFC 03,W
3476:  MOVWF  FEA
3478:  INCF   FEF,F
.................... 						if (alarm[i].cnValid > MAX_CNALARM){  
347A:  MOVF   x54,W
347C:  MULLW  0B
347E:  MOVF   FF3,W
3480:  CLRF   x61
3482:  MOVWF  x60
3484:  MOVLW  0A
3486:  ADDWF  x60,W
3488:  MOVWF  01
348A:  MOVLW  00
348C:  ADDWFC x61,W
348E:  MOVWF  03
3490:  MOVF   01,W
3492:  ADDLW  18
3494:  MOVWF  FE9
3496:  MOVLW  03
3498:  ADDWFC 03,W
349A:  MOVWF  FEA
349C:  MOVF   FEF,W
349E:  SUBLW  03
34A0:  BC    3568
.................... 							res = 0x04;							// Activa condicion de alarma por maximo 
34A2:  MOVLW  04
34A4:  MOVWF  x55
.................... 							alarm[i].cnValid = 0; 
34A6:  MOVF   x54,W
34A8:  MULLW  0B
34AA:  MOVF   FF3,W
34AC:  CLRF   x61
34AE:  MOVWF  x60
34B0:  MOVLW  0A
34B2:  ADDWF  x60,W
34B4:  MOVWF  01
34B6:  MOVLW  00
34B8:  ADDWFC x61,W
34BA:  MOVWF  03
34BC:  MOVF   01,W
34BE:  ADDLW  18
34C0:  MOVWF  FE9
34C2:  MOVLW  03
34C4:  ADDWFC 03,W
34C6:  MOVWF  FEA
34C8:  CLRF   FEF
.................... 							GenerateToken(); 
34CA:  MOVLB  0
34CC:  CALL   0DDA
.................... 							sprintf(auxSms, "%4f", dataMed.humedad); 
34D0:  MOVLW  03
34D2:  MOVLB  1
34D4:  MOVWF  x47
34D6:  MOVLW  56
34D8:  MOVWF  x46
34DA:  MOVLW  89
34DC:  MOVWF  FE9
34DE:  MOVFF  2F1,3FF
34E2:  MOVFF  2F0,3FE
34E6:  MOVFF  2EF,3FD
34EA:  MOVFF  2EE,3FC
34EE:  MOVLW  06
34F0:  MOVLB  4
34F2:  MOVWF  x00
34F4:  MOVLB  0
34F6:  CALL   29A6
.................... 							auxSms[4] = 0; 
34FA:  MOVLB  3
34FC:  CLRF   x5A
.................... 							sprintf(smsOut, "A|H|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
34FE:  MOVLW  02
3500:  MOVLB  1
3502:  MOVWF  x47
3504:  MOVLW  27
3506:  MOVWF  x46
3508:  MOVLW  78
350A:  MOVWF  FF6
350C:  MOVLW  02
350E:  MOVWF  FF7
3510:  MOVLW  04
3512:  MOVLB  3
3514:  MOVWF  x60
3516:  MOVLB  0
3518:  CALL   12A0
351C:  MOVLW  03
351E:  MOVWF  FEA
3520:  MOVLW  56
3522:  MOVWF  FE9
3524:  CALL   12C8
3528:  MOVLW  7C
352A:  MOVLB  4
352C:  MOVWF  x0D
352E:  MOVLB  0
3530:  CALL   0CBE
3534:  MOVFF  17F,40D
3538:  CALL   0CBE
353C:  MOVFF  180,40D
3540:  CALL   0CBE
.................... 							idLastSmsOut = EnviarSms(smsOut, telnum);	 
3544:  MOVLW  02
3546:  MOVLB  3
3548:  MOVWF  x61
354A:  MOVLW  27
354C:  MOVWF  x60
354E:  MOVLW  01
3550:  MOVWF  x63
3552:  MOVLW  48
3554:  MOVWF  x62
3556:  MOVLB  0
3558:  CALL   131C
355C:  MOVFF  01,170
.................... 							return res; 
3560:  MOVLB  3
3562:  MOVFF  355,01
3566:  BRA    3736
.................... 						} 
.................... 					} 
.................... 					else{  
3568:  BRA    371E
356A:  MOVLB  0
.................... 						if (dataMed.humedad < alarm[i].min_value){	// Verifica condicion de minimo 
356C:  MOVLB  3
356E:  MOVF   x54,W
3570:  MULLW  0B
3572:  MOVF   FF3,W
3574:  CLRF   x61
3576:  MOVWF  x60
3578:  MOVLW  06
357A:  ADDWF  x60,W
357C:  MOVWF  01
357E:  MOVLW  00
3580:  ADDWFC x61,W
3582:  MOVWF  03
3584:  MOVF   01,W
3586:  ADDLW  18
3588:  MOVWF  FE9
358A:  MOVLW  03
358C:  ADDWFC 03,W
358E:  MOVWF  FEA
3590:  MOVFF  FEF,00
3594:  MOVFF  FEC,01
3598:  MOVFF  FEC,02
359C:  MOVFF  FEC,03
35A0:  MOVFF  2F1,37A
35A4:  MOVFF  2F0,379
35A8:  MOVFF  2EF,378
35AC:  MOVFF  2EE,377
35B0:  MOVFF  03,37E
35B4:  MOVFF  02,37D
35B8:  MOVFF  01,37C
35BC:  MOVFF  00,37B
35C0:  MOVLB  0
35C2:  CALL   19D0
35C6:  BTFSS  FD8.0
35C8:  BRA    36F8
.................... 							alarm[i].cnValid--; 
35CA:  MOVLB  3
35CC:  MOVF   x54,W
35CE:  MULLW  0B
35D0:  MOVF   FF3,W
35D2:  CLRF   x61
35D4:  MOVWF  x60
35D6:  MOVLW  0A
35D8:  ADDWF  x60,W
35DA:  MOVWF  01
35DC:  MOVLW  00
35DE:  ADDWFC x61,W
35E0:  MOVWF  03
35E2:  MOVF   01,W
35E4:  ADDLW  18
35E6:  MOVWF  FE9
35E8:  MOVLW  03
35EA:  ADDWFC 03,W
35EC:  MOVWF  FEA
35EE:  DECF   FEF,F
.................... 							if ((alarm[i].cnValid * (-1)) > MAX_CNALARM){  
35F0:  MOVF   x54,W
35F2:  MULLW  0B
35F4:  MOVF   FF3,W
35F6:  CLRF   x61
35F8:  MOVWF  x60
35FA:  MOVLW  0A
35FC:  ADDWF  x60,W
35FE:  MOVWF  01
3600:  MOVLW  00
3602:  ADDWFC x61,W
3604:  MOVWF  03
3606:  MOVF   01,W
3608:  ADDLW  18
360A:  MOVWF  FE9
360C:  MOVLW  03
360E:  ADDWFC 03,W
3610:  MOVWF  FEA
3612:  MOVFF  FEF,404
3616:  MOVLW  FF
3618:  MOVLB  4
361A:  MOVWF  x05
361C:  MOVLB  0
361E:  CALL   0A8E
3622:  BTFSC  01.7
3624:  BRA    36F6
3626:  MOVF   01,W
3628:  SUBLW  03
362A:  BC    36F6
.................... 								res = 0x10;						// Activa condicion de alarma por mínimo 
362C:  MOVLW  10
362E:  MOVLB  3
3630:  MOVWF  x55
.................... 								alarm[i].cnValid = 0; 
3632:  MOVF   x54,W
3634:  MULLW  0B
3636:  MOVF   FF3,W
3638:  CLRF   x61
363A:  MOVWF  x60
363C:  MOVLW  0A
363E:  ADDWF  x60,W
3640:  MOVWF  01
3642:  MOVLW  00
3644:  ADDWFC x61,W
3646:  MOVWF  03
3648:  MOVF   01,W
364A:  ADDLW  18
364C:  MOVWF  FE9
364E:  MOVLW  03
3650:  ADDWFC 03,W
3652:  MOVWF  FEA
3654:  CLRF   FEF
.................... 								GenerateToken(); 
3656:  MOVLB  0
3658:  CALL   0DDA
.................... 								sprintf(auxSms, "%4f", dataMed.humedad); 
365C:  MOVLW  03
365E:  MOVLB  1
3660:  MOVWF  x47
3662:  MOVLW  56
3664:  MOVWF  x46
3666:  MOVLW  89
3668:  MOVWF  FE9
366A:  MOVFF  2F1,3FF
366E:  MOVFF  2F0,3FE
3672:  MOVFF  2EF,3FD
3676:  MOVFF  2EE,3FC
367A:  MOVLW  06
367C:  MOVLB  4
367E:  MOVWF  x00
3680:  MOVLB  0
3682:  CALL   29A6
.................... 								auxSms[4] = 0; 
3686:  MOVLB  3
3688:  CLRF   x5A
.................... 								sprintf(smsOut, "A|H|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
368A:  MOVLW  02
368C:  MOVLB  1
368E:  MOVWF  x47
3690:  MOVLW  27
3692:  MOVWF  x46
3694:  MOVLW  84
3696:  MOVWF  FF6
3698:  MOVLW  02
369A:  MOVWF  FF7
369C:  MOVLW  04
369E:  MOVLB  3
36A0:  MOVWF  x60
36A2:  MOVLB  0
36A4:  CALL   12A0
36A8:  MOVLW  03
36AA:  MOVWF  FEA
36AC:  MOVLW  56
36AE:  MOVWF  FE9
36B0:  CALL   12C8
36B4:  MOVLW  7C
36B6:  MOVLB  4
36B8:  MOVWF  x0D
36BA:  MOVLB  0
36BC:  CALL   0CBE
36C0:  MOVFF  17F,40D
36C4:  CALL   0CBE
36C8:  MOVFF  180,40D
36CC:  CALL   0CBE
.................... 								idLastSmsOut = EnviarSms(smsOut, telnum);	 
36D0:  MOVLW  02
36D2:  MOVLB  3
36D4:  MOVWF  x61
36D6:  MOVLW  27
36D8:  MOVWF  x60
36DA:  MOVLW  01
36DC:  MOVWF  x63
36DE:  MOVLW  48
36E0:  MOVWF  x62
36E2:  MOVLB  0
36E4:  CALL   131C
36E8:  MOVFF  01,170
.................... 								return res; 
36EC:  MOVLB  3
36EE:  MOVFF  355,01
36F2:  BRA    3736
36F4:  MOVLB  0
.................... 							} 
.................... 						} 
.................... 						else{ 
36F6:  BRA    3720
.................... 							alarm[i].cnValid = 0;					// En estado normal pone contador de alarma en 0 
36F8:  MOVLB  3
36FA:  MOVF   x54,W
36FC:  MULLW  0B
36FE:  MOVF   FF3,W
3700:  CLRF   x61
3702:  MOVWF  x60
3704:  MOVLW  0A
3706:  ADDWF  x60,W
3708:  MOVWF  01
370A:  MOVLW  00
370C:  ADDWFC x61,W
370E:  MOVWF  03
3710:  MOVF   01,W
3712:  ADDLW  18
3714:  MOVWF  FE9
3716:  MOVLW  03
3718:  ADDWFC 03,W
371A:  MOVWF  FEA
371C:  CLRF   FEF
371E:  MOVLB  0
.................... 						} 
.................... 					} 
.................... 					break; 
3720:  BRA    372C
.................... 				case 'L':					// Precipitacion 
.................... 				case 'P':					// Presion 
.................... 				default: 
.................... 					return 0; 
3722:  MOVLW  00
3724:  MOVWF  01
3726:  MOVLB  3
3728:  BRA    3736
372A:  MOVLB  0
.................... 			} 
.................... 		} 
.................... 	} 
372C:  MOVLB  3
372E:  INCF   x54,F
3730:  BRA    3068
.................... 	return 0; 
3732:  MOVLW  00
3734:  MOVWF  01
.................... } 
3736:  MOVLB  0
3738:  GOTO   4D1E (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | char reinicioOK(void); 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void reinicioOK(void){ 
*
13B6:  MOVF   FD0,W
13B8:  ANDLW  0F
13BA:  BTFSS  FD0.4
13BC:  MOVLW  00
13BE:  BSF    FD0.0
13C0:  BSF    FD0.1
13C2:  BSF    FD0.4
13C4:  BSF    FD8.3
13C6:  BSF    FD8.4
13C8:  MOVLB  3
13CA:  MOVWF  x54
.................... 	int cause = restart_cause(); 
.................... 	delay_ms(16000); 
13CC:  MOVLW  40
13CE:  MOVWF  x55
13D0:  MOVLW  FA
13D2:  MOVWF  x74
13D4:  MOVLB  0
13D6:  CALL   058A
13DA:  MOVLB  3
13DC:  DECFSZ x55,F
13DE:  BRA    13D0
.................... 	//output_bit(LED1, 0); 
.................... 	//output_bit(LED2, 1); 
.................... 	GenerateToken(); 
13E0:  MOVLB  0
13E2:  RCALL  0DDA
.................... 	CurrDateTime(); 
13E4:  RCALL  1150
.................... 	sprintf(smsOut, "EST|%s|%s|ON|%i|%c%c",dtFecha, dtHora, cause, tokenEma[0], tokenEma[1]); 
13E6:  MOVLW  02
13E8:  MOVLB  1
13EA:  MOVWF  x47
13EC:  MOVLW  27
13EE:  MOVWF  x46
13F0:  MOVLW  90
13F2:  MOVWF  FF6
13F4:  MOVLW  02
13F6:  MOVWF  FF7
13F8:  MOVLW  04
13FA:  MOVLB  3
13FC:  MOVWF  x60
13FE:  MOVLB  0
1400:  RCALL  12A0
1402:  MOVLW  01
1404:  MOVWF  FEA
1406:  MOVLW  32
1408:  MOVWF  FE9
140A:  RCALL  12C8
140C:  MOVLW  7C
140E:  MOVLB  4
1410:  MOVWF  x0D
1412:  MOVLB  0
1414:  RCALL  0CBE
1416:  MOVLW  01
1418:  MOVWF  FEA
141A:  MOVLW  3C
141C:  MOVWF  FE9
141E:  RCALL  12C8
1420:  MOVLW  99
1422:  MOVWF  FF6
1424:  MOVLW  02
1426:  MOVWF  FF7
1428:  MOVLW  04
142A:  MOVLB  3
142C:  MOVWF  x60
142E:  MOVLB  0
1430:  RCALL  12A0
1432:  MOVFF  354,3FD
1436:  MOVLW  1F
1438:  MOVLB  3
143A:  MOVWF  xFE
143C:  MOVLB  0
143E:  RCALL  0CE0
1440:  MOVLW  7C
1442:  MOVLB  4
1444:  MOVWF  x0D
1446:  MOVLB  0
1448:  RCALL  0CBE
144A:  MOVFF  17F,40D
144E:  RCALL  0CBE
1450:  MOVFF  180,40D
1454:  RCALL  0CBE
.................... 	EnviarSms(smsOut, telnum); 
1456:  MOVLW  02
1458:  MOVLB  3
145A:  MOVWF  x61
145C:  MOVLW  27
145E:  MOVWF  x60
1460:  MOVLW  01
1462:  MOVWF  x63
1464:  MOVLW  48
1466:  MOVWF  x62
1468:  MOVLB  0
146A:  RCALL  131C
.................... } 
146C:  GOTO   4BF0 (RETURN)
....................  
....................  
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void concatVariableSeparator(char* sms) 
.................... | Concatena el separador de variables * , si el texto no esta vacio 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void concatVariableSeparator(char* sms) 
.................... { 
.................... 	if(strlen(sms) != 0) { 
*
2C1A:  MOVFF  3FD,3FF
2C1E:  MOVFF  3FC,3FE
2C22:  BRA    2BD8
2C24:  MOVF   01,F
2C26:  BZ    2C3E
.................... 	    strcat(sms,sepVar); 
2C28:  MOVFF  3FD,3FF
2C2C:  MOVFF  3FC,3FE
2C30:  MOVLW  01
2C32:  MOVLB  4
2C34:  MOVWF  x01
2C36:  MOVLW  57
2C38:  MOVWF  x00
2C3A:  MOVLB  0
2C3C:  RCALL  2B64
.................... 	} 
.................... } 
2C3E:  RETLW  00
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void construirTextoSms(char* sms, char prog) 
.................... | Construye el SMS a enviar dependiendo los sensores que estan habilitados o no 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void construirTextoSms(char* sms, char prog) 
.................... { 
.................... 	char auxVar[SZ_SMSTXT]; 
.................... 	clear_var(auxVar); 
2C40:  MOVLW  03
2C42:  MOVLB  3
2C44:  MOVWF  xFD
2C46:  MOVLW  57
2C48:  MOVWF  xFC
2C4A:  MOVLB  0
2C4C:  CALL   0A6C
....................  
.................... 	if (sensorHab & TEMP_HUM_S){		// Sensor de temperatura y humedad habilitado ? 
2C50:  MOVLB  1
2C52:  BTFSS  x7B.1
2C54:  BRA    2D18
.................... 		//Temp 
.................... 		sprintf(charFloat1, "T:%2.1f",dataMed.tempExt); 
2C56:  MOVLW  02
2C58:  MOVWF  x47
2C5A:  MOVLW  DA
2C5C:  MOVWF  x46
2C5E:  MOVLW  54
2C60:  MOVLB  4
2C62:  MOVWF  x0D
2C64:  MOVLB  0
2C66:  CALL   0CBE
2C6A:  MOVLW  3A
2C6C:  MOVLB  4
2C6E:  MOVWF  x0D
2C70:  MOVLB  0
2C72:  CALL   0CBE
2C76:  MOVLW  01
2C78:  MOVWF  FE9
2C7A:  MOVFF  2F5,3FF
2C7E:  MOVFF  2F4,3FE
2C82:  MOVFF  2F3,3FD
2C86:  MOVFF  2F2,3FC
2C8A:  MOVLB  4
2C8C:  MOVWF  x00
2C8E:  MOVLB  0
2C90:  RCALL  29A6
.................... 		charFloat1[6] = 0; 
2C92:  MOVLB  2
2C94:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2C96:  MOVLW  03
2C98:  MOVLB  3
2C9A:  MOVWF  xFF
2C9C:  MOVLW  57
2C9E:  MOVWF  xFE
2CA0:  MOVLW  02
2CA2:  MOVLB  4
2CA4:  MOVWF  x01
2CA6:  MOVLW  DA
2CA8:  MOVWF  x00
2CAA:  MOVLB  0
2CAC:  RCALL  2B64
.................... 		//Humedad 
.................... 		concatVariableSeparator(auxVar); 
2CAE:  MOVLW  03
2CB0:  MOVLB  3
2CB2:  MOVWF  xFD
2CB4:  MOVLW  57
2CB6:  MOVWF  xFC
2CB8:  MOVLB  0
2CBA:  RCALL  2C1A
.................... 	 	sprintf(charFloat1, "H:%2.1f",dataMed.humedad); 
2CBC:  MOVLW  02
2CBE:  MOVLB  1
2CC0:  MOVWF  x47
2CC2:  MOVLW  DA
2CC4:  MOVWF  x46
2CC6:  MOVLW  48
2CC8:  MOVLB  4
2CCA:  MOVWF  x0D
2CCC:  MOVLB  0
2CCE:  CALL   0CBE
2CD2:  MOVLW  3A
2CD4:  MOVLB  4
2CD6:  MOVWF  x0D
2CD8:  MOVLB  0
2CDA:  CALL   0CBE
2CDE:  MOVLW  01
2CE0:  MOVWF  FE9
2CE2:  MOVFF  2F1,3FF
2CE6:  MOVFF  2F0,3FE
2CEA:  MOVFF  2EF,3FD
2CEE:  MOVFF  2EE,3FC
2CF2:  MOVLB  4
2CF4:  MOVWF  x00
2CF6:  MOVLB  0
2CF8:  RCALL  29A6
.................... 		charFloat1[6] = 0; 
2CFA:  MOVLB  2
2CFC:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2CFE:  MOVLW  03
2D00:  MOVLB  3
2D02:  MOVWF  xFF
2D04:  MOVLW  57
2D06:  MOVWF  xFE
2D08:  MOVLW  02
2D0A:  MOVLB  4
2D0C:  MOVWF  x01
2D0E:  MOVLW  DA
2D10:  MOVWF  x00
2D12:  MOVLB  0
2D14:  RCALL  2B64
2D16:  MOVLB  1
.................... 	} 
.................... 	if (sensorHab & RAINFALL_S){		// Sensor de precipitacion habilitado ? 
2D18:  BTFSS  x7B.2
2D1A:  BRA    2DE0
.................... 		//Precipitacion 
.................... 		concatVariableSeparator(auxVar); 
2D1C:  MOVLW  03
2D1E:  MOVLB  3
2D20:  MOVWF  xFD
2D22:  MOVLW  57
2D24:  MOVWF  xFC
2D26:  MOVLB  0
2D28:  RCALL  2C1A
.................... 		sprintf(charFloat1, "L:%2.1f", dataMed.precip); 
2D2A:  MOVLW  02
2D2C:  MOVLB  1
2D2E:  MOVWF  x47
2D30:  MOVLW  DA
2D32:  MOVWF  x46
2D34:  MOVLW  4C
2D36:  MOVLB  4
2D38:  MOVWF  x0D
2D3A:  MOVLB  0
2D3C:  CALL   0CBE
2D40:  MOVLW  3A
2D42:  MOVLB  4
2D44:  MOVWF  x0D
2D46:  MOVLB  0
2D48:  CALL   0CBE
2D4C:  MOVLW  01
2D4E:  MOVWF  FE9
2D50:  MOVFF  2F9,3FF
2D54:  MOVFF  2F8,3FE
2D58:  MOVFF  2F7,3FD
2D5C:  MOVFF  2F6,3FC
2D60:  MOVLB  4
2D62:  MOVWF  x00
2D64:  MOVLB  0
2D66:  RCALL  29A6
.................... 		charFloat1[6] = 0; 
2D68:  MOVLB  2
2D6A:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2D6C:  MOVLW  03
2D6E:  MOVLB  3
2D70:  MOVWF  xFF
2D72:  MOVLW  57
2D74:  MOVWF  xFE
2D76:  MOVLW  02
2D78:  MOVLB  4
2D7A:  MOVWF  x01
2D7C:  MOVLW  DA
2D7E:  MOVWF  x00
2D80:  MOVLB  0
2D82:  RCALL  2B64
.................... 		if (llueveAhora) {	      //Si llueveAhora = 1, mandar intensidad	 
2D84:  MOVLB  1
2D86:  MOVF   x76,F
2D88:  BZ    2DE0
.................... 			//Intensidad 
.................... 			concatVariableSeparator(auxVar); 
2D8A:  MOVLW  03
2D8C:  MOVLB  3
2D8E:  MOVWF  xFD
2D90:  MOVLW  57
2D92:  MOVWF  xFC
2D94:  MOVLB  0
2D96:  RCALL  2C1A
.................... 			sprintf(charFloat1, "I:%c", dataMed.intensidad); 
2D98:  MOVLW  02
2D9A:  MOVLB  1
2D9C:  MOVWF  x47
2D9E:  MOVLW  DA
2DA0:  MOVWF  x46
2DA2:  MOVLW  49
2DA4:  MOVLB  4
2DA6:  MOVWF  x0D
2DA8:  MOVLB  0
2DAA:  CALL   0CBE
2DAE:  MOVLW  3A
2DB0:  MOVLB  4
2DB2:  MOVWF  x0D
2DB4:  MOVLB  0
2DB6:  CALL   0CBE
2DBA:  MOVFF  2FA,40D
2DBE:  CALL   0CBE
.................... 			charFloat1[3] = 0; 
2DC2:  MOVLB  2
2DC4:  CLRF   xDD
.................... 			strcat(auxVar,charFloat1); 
2DC6:  MOVLW  03
2DC8:  MOVLB  3
2DCA:  MOVWF  xFF
2DCC:  MOVLW  57
2DCE:  MOVWF  xFE
2DD0:  MOVLW  02
2DD2:  MOVLB  4
2DD4:  MOVWF  x01
2DD6:  MOVLW  DA
2DD8:  MOVWF  x00
2DDA:  MOVLB  0
2DDC:  RCALL  2B64
2DDE:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & PREASURE_S){		// Sensor de presion habilitado ? 
2DE0:  BTFSS  x7B.3
2DE2:  BRA    2E4E
.................... 		//Presion 
.................... 		concatVariableSeparator(auxVar); 
2DE4:  MOVLW  03
2DE6:  MOVLB  3
2DE8:  MOVWF  xFD
2DEA:  MOVLW  57
2DEC:  MOVWF  xFC
2DEE:  MOVLB  0
2DF0:  RCALL  2C1A
.................... 		sprintf(charFloat1, "P:%4.1f", dataMed.preasure); 
2DF2:  MOVLW  02
2DF4:  MOVLB  1
2DF6:  MOVWF  x47
2DF8:  MOVLW  DA
2DFA:  MOVWF  x46
2DFC:  MOVLW  50
2DFE:  MOVLB  4
2E00:  MOVWF  x0D
2E02:  MOVLB  0
2E04:  CALL   0CBE
2E08:  MOVLW  3A
2E0A:  MOVLB  4
2E0C:  MOVWF  x0D
2E0E:  MOVLB  0
2E10:  CALL   0CBE
2E14:  MOVLW  03
2E16:  MOVWF  FE9
2E18:  MOVFF  2FE,3FF
2E1C:  MOVFF  2FD,3FE
2E20:  MOVFF  2FC,3FD
2E24:  MOVFF  2FB,3FC
2E28:  MOVLW  01
2E2A:  MOVLB  4
2E2C:  MOVWF  x00
2E2E:  MOVLB  0
2E30:  RCALL  29A6
.................... 		charFloat1[8] = 0; 
2E32:  MOVLB  2
2E34:  CLRF   xE2
.................... 		strcat(auxVar,charFloat1); 
2E36:  MOVLW  03
2E38:  MOVLB  3
2E3A:  MOVWF  xFF
2E3C:  MOVLW  57
2E3E:  MOVWF  xFE
2E40:  MOVLW  02
2E42:  MOVLB  4
2E44:  MOVWF  x01
2E46:  MOVLW  DA
2E48:  MOVWF  x00
2E4A:  MOVLB  0
2E4C:  RCALL  2B64
.................... 	} 
.................... 	 
.................... 	clear_var(sms); 
2E4E:  MOVFF  355,3FD
2E52:  MOVFF  354,3FC
2E56:  MOVLB  0
2E58:  CALL   0A6C
.................... 	if (prog){						// Si es programada es <> 0  
2E5C:  MOVLB  3
2E5E:  MOVF   x56,F
2E60:  BZ    2EE4
.................... 		GenerateToken(); 
2E62:  MOVLB  0
2E64:  CALL   0DDA
.................... 		sprintf(sms, "D|%s|%s|%s|%c%c",dtFecha, dtHora, auxVar, tokenEma[0], tokenEma[1]);	 
2E68:  MOVFF  355,147
2E6C:  MOVFF  354,146
2E70:  MOVLW  44
2E72:  MOVLB  4
2E74:  MOVWF  x0D
2E76:  MOVLB  0
2E78:  CALL   0CBE
2E7C:  MOVLW  7C
2E7E:  MOVLB  4
2E80:  MOVWF  x0D
2E82:  MOVLB  0
2E84:  CALL   0CBE
2E88:  MOVLW  01
2E8A:  MOVWF  FEA
2E8C:  MOVLW  32
2E8E:  MOVWF  FE9
2E90:  CALL   12C8
2E94:  MOVLW  7C
2E96:  MOVLB  4
2E98:  MOVWF  x0D
2E9A:  MOVLB  0
2E9C:  CALL   0CBE
2EA0:  MOVLW  01
2EA2:  MOVWF  FEA
2EA4:  MOVLW  3C
2EA6:  MOVWF  FE9
2EA8:  CALL   12C8
2EAC:  MOVLW  7C
2EAE:  MOVLB  4
2EB0:  MOVWF  x0D
2EB2:  MOVLB  0
2EB4:  CALL   0CBE
2EB8:  MOVLW  03
2EBA:  MOVWF  FEA
2EBC:  MOVLW  57
2EBE:  MOVWF  FE9
2EC0:  CALL   12C8
2EC4:  MOVLW  7C
2EC6:  MOVLB  4
2EC8:  MOVWF  x0D
2ECA:  MOVLB  0
2ECC:  CALL   0CBE
2ED0:  MOVFF  17F,40D
2ED4:  CALL   0CBE
2ED8:  MOVFF  180,40D
2EDC:  CALL   0CBE
.................... 	}else{ 
2EE0:  BRA    2F5C
2EE2:  MOVLB  3
.................... 		sprintf(sms, "R|%s|%s|%s|%c%c",dtFecha, dtHora, auxVar, tokenSrv[0], tokenSrv[1]); 
2EE4:  MOVFF  355,147
2EE8:  MOVFF  354,146
2EEC:  MOVLW  52
2EEE:  MOVLB  4
2EF0:  MOVWF  x0D
2EF2:  MOVLB  0
2EF4:  CALL   0CBE
2EF8:  MOVLW  7C
2EFA:  MOVLB  4
2EFC:  MOVWF  x0D
2EFE:  MOVLB  0
2F00:  CALL   0CBE
2F04:  MOVLW  01
2F06:  MOVWF  FEA
2F08:  MOVLW  32
2F0A:  MOVWF  FE9
2F0C:  CALL   12C8
2F10:  MOVLW  7C
2F12:  MOVLB  4
2F14:  MOVWF  x0D
2F16:  MOVLB  0
2F18:  CALL   0CBE
2F1C:  MOVLW  01
2F1E:  MOVWF  FEA
2F20:  MOVLW  3C
2F22:  MOVWF  FE9
2F24:  CALL   12C8
2F28:  MOVLW  7C
2F2A:  MOVLB  4
2F2C:  MOVWF  x0D
2F2E:  MOVLB  0
2F30:  CALL   0CBE
2F34:  MOVLW  03
2F36:  MOVWF  FEA
2F38:  MOVLW  57
2F3A:  MOVWF  FE9
2F3C:  CALL   12C8
2F40:  MOVLW  7C
2F42:  MOVLB  4
2F44:  MOVWF  x0D
2F46:  MOVLB  0
2F48:  CALL   0CBE
2F4C:  MOVFF  17C,40D
2F50:  CALL   0CBE
2F54:  MOVFF  17D,40D
2F58:  CALL   0CBE
.................... 	} 
.................... } 
2F5C:  RETLW  00
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void calcularTempHum(float & temp, float & truehumid);  
.................... | Calcula la temperatura y humedad haciendo promedios KTESHT_QTY 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void calcularTempHum(float & temp, float & truehumid) 
.................... { 
.................... 	float acumTemp = 0; 
.................... 	float acumHum = 0; 
.................... 	char i; 
.................... 	for (i = 0; i < KTESHT_QTY; i++){ 
.................... 		float auxTemp; 
.................... 		float auxHum; 
.................... 		sht_rd(auxTemp, auxHum); 
.................... 		acumTemp = acumTemp + auxTemp; 
.................... 		acumHum = acumHum + auxHum; 
.................... 	} 
.................... 	temp = acumTemp/KTESHT_QTY; 
.................... 	truehumid = acumHum/KTESHT_QTY; 
.................... } 
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | float obtenerPresion(void) 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... float obtenerPresion(void) 
.................... { 
*
2152:  MOVLB  3
2154:  CLRF   x6E
2156:  CLRF   x6D
2158:  CLRF   x6C
215A:  CLRF   x6B
.................... 	float acum = 0; 
.................... 	float pre; 
.................... 	set_adc_channel(0); 
215C:  MOVLW  00
215E:  MOVWF  01
2160:  MOVF   FC2,W
2162:  ANDLW  C3
2164:  IORWF  01,W
2166:  MOVWF  FC2
.................... 	delay_ms(20); 
2168:  MOVLW  14
216A:  MOVWF  x74
216C:  MOVLB  0
216E:  CALL   058A
.................... 	char i; 
.................... 	for (i = 0; i < KTEMPX_QTY; i++){ 
2172:  MOVLB  3
2174:  CLRF   x73
2176:  MOVF   x73,W
2178:  SUBLW  0E
217A:  BNC   2270
.................... 		adc_val = read_adc(); 
217C:  BSF    FC2.1
217E:  BTFSC  FC2.1
2180:  BRA    217E
2182:  MOVFF  FC4,15B
2186:  MOVLB  1
2188:  MOVFF  FC3,15A
.................... 		while(!adc_done()); 
218C:  BTFSC  FC2.1
218E:  BRA    218C
.................... 		acum = acum + (float) ((adc_val * KTEMPX) + 10.56)*10;		//*10 kPa a Hpa	// Lee presion del MPX 
2190:  MOVFF  15B,3A6
2194:  MOVFF  15A,3A5
2198:  MOVLB  0
219A:  CALL   162C
219E:  MOVFF  03,410
21A2:  MOVFF  02,40F
21A6:  MOVFF  01,40E
21AA:  MOVFF  00,40D
21AE:  MOVLW  D2
21B0:  MOVLB  4
21B2:  MOVWF  x14
21B4:  MOVLW  6F
21B6:  MOVWF  x13
21B8:  MOVLW  5F
21BA:  MOVWF  x12
21BC:  MOVLW  7B
21BE:  MOVWF  x11
21C0:  MOVLB  0
21C2:  CALL   1662
21C6:  MOVFF  00,374
21CA:  MOVFF  01,375
21CE:  MOVFF  02,376
21D2:  MOVFF  03,377
21D6:  BCF    FD8.1
21D8:  MOVFF  03,3A8
21DC:  MOVFF  02,3A7
21E0:  MOVFF  01,3A6
21E4:  MOVFF  00,3A5
21E8:  MOVLW  C3
21EA:  MOVLB  3
21EC:  MOVWF  xAC
21EE:  MOVLW  F5
21F0:  MOVWF  xAB
21F2:  MOVLW  28
21F4:  MOVWF  xAA
21F6:  MOVLW  82
21F8:  MOVWF  xA9
21FA:  MOVLB  0
21FC:  CALL   1758
2200:  MOVFF  00,374
2204:  MOVFF  01,375
2208:  MOVFF  02,376
220C:  MOVFF  03,377
2210:  MOVFF  03,410
2214:  MOVFF  02,40F
2218:  MOVFF  01,40E
221C:  MOVFF  00,40D
2220:  MOVLB  4
2222:  CLRF   x14
2224:  CLRF   x13
2226:  MOVLW  20
2228:  MOVWF  x12
222A:  MOVLW  82
222C:  MOVWF  x11
222E:  MOVLB  0
2230:  CALL   1662
2234:  BCF    FD8.1
2236:  MOVFF  36E,3A8
223A:  MOVFF  36D,3A7
223E:  MOVFF  36C,3A6
2242:  MOVFF  36B,3A5
2246:  MOVFF  03,3AC
224A:  MOVFF  02,3AB
224E:  MOVFF  01,3AA
2252:  MOVFF  00,3A9
2256:  CALL   1758
225A:  MOVFF  03,36E
225E:  MOVFF  02,36D
2262:  MOVFF  01,36C
2266:  MOVFF  00,36B
.................... 	} 
226A:  MOVLB  3
226C:  INCF   x73,F
226E:  BRA    2176
.................... 	pre = ((acum/KTEMPX_QTY) + KTEMPX_CORR); 
2270:  MOVFF  36E,3A8
2274:  MOVFF  36D,3A7
2278:  MOVFF  36C,3A6
227C:  MOVFF  36B,3A5
2280:  CLRF   xAC
2282:  CLRF   xAB
2284:  MOVLW  70
2286:  MOVWF  xAA
2288:  MOVLW  82
228A:  MOVWF  xA9
228C:  MOVLB  0
228E:  RCALL  1FF4
2290:  MOVFF  00,374
2294:  MOVFF  01,375
2298:  MOVFF  02,376
229C:  MOVFF  03,377
22A0:  BCF    FD8.1
22A2:  MOVFF  03,3A8
22A6:  MOVFF  02,3A7
22AA:  MOVFF  01,3A6
22AE:  MOVFF  00,3A5
22B2:  MOVLB  3
22B4:  CLRF   xAC
22B6:  CLRF   xAB
22B8:  CLRF   xAA
22BA:  CLRF   xA9
22BC:  MOVLB  0
22BE:  CALL   1758
22C2:  MOVFF  03,372
22C6:  MOVFF  02,371
22CA:  MOVFF  01,370
22CE:  MOVFF  00,36F
.................... 	return pre; 
22D2:  MOVFF  36F,00
22D6:  MOVFF  370,01
22DA:  MOVFF  371,02
22DE:  MOVFF  372,03
.................... } 
22E2:  GOTO   2760 (RETURN)
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | char obtenerIntensidad(int32 seconds, float countPrec) 
.................... | Obtiene la intensidad de la lluvia teniendo en cuenta los umbrales definidos de debil, moderado, fuerte,  
.................... | muy fuerte y torrencial 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... char obtenerIntensidad(int32 seconds, float countPrec) 
.................... { 
.................... 	if ( countPrec == 0 ) { 
*
1B04:  MOVFF  372,37A
1B08:  MOVFF  371,379
1B0C:  MOVFF  370,378
1B10:  MOVFF  36F,377
1B14:  MOVLB  3
1B16:  CLRF   x7E
1B18:  CLRF   x7D
1B1A:  CLRF   x7C
1B1C:  CLRF   x7B
1B1E:  MOVLB  0
1B20:  RCALL  19D0
1B22:  BNZ   1B2C
.................... 		return 'X';	 
1B24:  MOVLW  58
1B26:  MOVWF  01
1B28:  BRA    1CB4
.................... 	} else {	 
1B2A:  BRA    1CB4
.................... 		float ratio = seconds/K_TIME_MED; 
1B2C:  MOVFF  36E,410
1B30:  MOVFF  36D,40F
1B34:  MOVFF  36C,40E
1B38:  MOVFF  36B,40D
1B3C:  MOVLB  4
1B3E:  CLRF   x14
1B40:  CLRF   x13
1B42:  MOVLW  06
1B44:  MOVWF  x12
1B46:  MOVLW  CC
1B48:  MOVWF  x11
1B4A:  MOVLB  0
1B4C:  RCALL  1A4A
1B4E:  MOVFF  03,37A
1B52:  MOVFF  02,379
1B56:  MOVFF  01,378
1B5A:  MOVFF  00,377
1B5E:  BRA    1ACA
1B60:  MOVFF  03,376
1B64:  MOVFF  02,375
1B68:  MOVFF  01,374
1B6C:  MOVFF  00,373
.................... 		if ( countPrec <= (U_DEBIL*ratio) ) { 
1B70:  MOVLB  4
1B72:  CLRF   x10
1B74:  CLRF   x0F
1B76:  CLRF   x0E
1B78:  MOVLW  7F
1B7A:  MOVWF  x0D
1B7C:  MOVFF  376,414
1B80:  MOVFF  375,413
1B84:  MOVFF  374,412
1B88:  MOVFF  373,411
1B8C:  MOVLB  0
1B8E:  RCALL  1662
1B90:  MOVFF  372,37A
1B94:  MOVFF  371,379
1B98:  MOVFF  370,378
1B9C:  MOVFF  36F,377
1BA0:  MOVFF  03,37E
1BA4:  MOVFF  02,37D
1BA8:  MOVFF  01,37C
1BAC:  MOVFF  00,37B
1BB0:  RCALL  19D0
1BB2:  BC    1BB6
1BB4:  BNZ   1BBE
.................... 			return '0'; 
1BB6:  MOVLW  30
1BB8:  MOVWF  01
1BBA:  BRA    1CB4
.................... 		} else  { 
1BBC:  BRA    1CB4
.................... 	        	if ( countPrec <= (U_MOD*ratio) ) { 
1BBE:  MOVLB  4
1BC0:  CLRF   x10
1BC2:  CLRF   x0F
1BC4:  MOVLW  70
1BC6:  MOVWF  x0E
1BC8:  MOVLW  81
1BCA:  MOVWF  x0D
1BCC:  MOVFF  376,414
1BD0:  MOVFF  375,413
1BD4:  MOVFF  374,412
1BD8:  MOVFF  373,411
1BDC:  MOVLB  0
1BDE:  RCALL  1662
1BE0:  MOVFF  372,37A
1BE4:  MOVFF  371,379
1BE8:  MOVFF  370,378
1BEC:  MOVFF  36F,377
1BF0:  MOVFF  03,37E
1BF4:  MOVFF  02,37D
1BF8:  MOVFF  01,37C
1BFC:  MOVFF  00,37B
1C00:  RCALL  19D0
1C02:  BC    1C06
1C04:  BNZ   1C0E
.................... 				return '1'; 
1C06:  MOVLW  31
1C08:  MOVWF  01
1C0A:  BRA    1CB4
.................... 			} else { 
1C0C:  BRA    1CB4
.................... 				if ( countPrec <= (U_FUERTE*ratio) ) { 
1C0E:  MOVLB  4
1C10:  CLRF   x10
1C12:  CLRF   x0F
1C14:  MOVLW  70
1C16:  MOVWF  x0E
1C18:  MOVLW  82
1C1A:  MOVWF  x0D
1C1C:  MOVFF  376,414
1C20:  MOVFF  375,413
1C24:  MOVFF  374,412
1C28:  MOVFF  373,411
1C2C:  MOVLB  0
1C2E:  RCALL  1662
1C30:  MOVFF  372,37A
1C34:  MOVFF  371,379
1C38:  MOVFF  370,378
1C3C:  MOVFF  36F,377
1C40:  MOVFF  03,37E
1C44:  MOVFF  02,37D
1C48:  MOVFF  01,37C
1C4C:  MOVFF  00,37B
1C50:  RCALL  19D0
1C52:  BC    1C56
1C54:  BNZ   1C5E
.................... 					return '2'; 
1C56:  MOVLW  32
1C58:  MOVWF  01
1C5A:  BRA    1CB4
.................... 				} else { 
1C5C:  BRA    1CB4
.................... 					if ( countPrec <= (U_MUYFUERTE*ratio) ) { 
1C5E:  MOVLB  4
1C60:  CLRF   x10
1C62:  CLRF   x0F
1C64:  MOVLW  70
1C66:  MOVWF  x0E
1C68:  MOVLW  83
1C6A:  MOVWF  x0D
1C6C:  MOVFF  376,414
1C70:  MOVFF  375,413
1C74:  MOVFF  374,412
1C78:  MOVFF  373,411
1C7C:  MOVLB  0
1C7E:  RCALL  1662
1C80:  MOVFF  372,37A
1C84:  MOVFF  371,379
1C88:  MOVFF  370,378
1C8C:  MOVFF  36F,377
1C90:  MOVFF  03,37E
1C94:  MOVFF  02,37D
1C98:  MOVFF  01,37C
1C9C:  MOVFF  00,37B
1CA0:  RCALL  19D0
1CA2:  BC    1CA6
1CA4:  BNZ   1CAE
.................... 						return '3'; 
1CA6:  MOVLW  33
1CA8:  MOVWF  01
1CAA:  BRA    1CB4
.................... 					} else { 
1CAC:  BRA    1CB4
.................... 						return '4'; 
1CAE:  MOVLW  34
1CB0:  MOVWF  01
1CB2:  BRA    1CB4
.................... 					} 
.................... 				} 
.................... 			} 
....................     		} 
.................... 	} 
.................... } 
1CB4:  RETLW  00
....................  
.................... //-------------------------------------------------------------------------------------------------------------- 
.................... //--------------------------------------- Rutinas que atienden las interrupciones ------------------------------ 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
.................... 	timeMedTmp--; 
*
02A6:  MOVLB  1
02A8:  MOVF   x60,W
02AA:  BTFSC  FD8.2
02AC:  DECF   x61,F
02AE:  DECF   x60,F
.................... 	if (timeMedTmp == 0){ 
02B0:  MOVF   x60,F
02B2:  BNZ   02C4
02B4:  MOVF   x61,F
02B6:  BNZ   02C4
.................... 		timeMedTmp = timeMed; 
02B8:  MOVFF  15F,161
02BC:  MOVFF  15E,160
.................... 		startMeasure = 1;			// Indica iniciar lectura de sensores 
02C0:  MOVLW  01
02C2:  MOVWF  x73
.................... 	} 	 
.................... 	timeChkTmp--; 
02C4:  MOVF   x64,W
02C6:  BTFSC  FD8.2
02C8:  DECF   x65,F
02CA:  DECF   x64,F
.................... 	if (timeChkTmp == 0){ 
02CC:  MOVF   x64,F
02CE:  BNZ   02E0
02D0:  MOVF   x65,F
02D2:  BNZ   02E0
.................... 		timeChkTmp = timeChk; 
02D4:  MOVFF  167,165
02D8:  MOVFF  166,164
.................... 		startCheck = 1;				// Indica iniciar lectura de variables de estado 
02DC:  MOVLW  01
02DE:  MOVWF  x74
.................... 	} 
.................... 	timeRestart--; 
02E0:  MOVF   x68,W
02E2:  BTFSC  FD8.2
02E4:  DECF   x69,F
02E6:  DECF   x68,F
.................... 	if (timeRestart == 0){ 
02E8:  MOVF   x68,F
02EA:  BNZ   02FC
02EC:  MOVF   x69,F
02EE:  BNZ   02FC
.................... 		timeRestart = K_TIME_RESTART; 
02F0:  MOVLW  17
02F2:  MOVWF  x69
02F4:  MOVLW  70
02F6:  MOVWF  x68
.................... 		startRestart = 1;				// Indica iniciar lectura de variables de estado 
02F8:  MOVLW  01
02FA:  MOVWF  x75
.................... 	} 
.................... } 
....................  
02FC:  BCF    FF2.2
02FE:  MOVLB  0
0300:  GOTO   006C
.................... #int_EXT2 
.................... void  EXT2_isr(void){				// Rutina de atencion a la interrupcion del pluviometro 
.................... 	if (flagInt2Edge == 0){   		// Flanco de Subida 
0304:  MOVLB  1
0306:  BTFSC  x59.0
0308:  BRA    0316
....................   		ext_int_edge(2, H_TO_L);  	// Configuro flanco de Bajada 
030A:  BCF    FF1.4
....................   		flagInt2Edge = 1;    		// Indico que el siguiente flanco será de Bajada 
030C:  BSF    x59.0
.................... 		countPrec++; 
030E:  INCF   x5C,F
0310:  BTFSC  FD8.2
0312:  INCF   x5D,F
.................... 	    //output_bit(LED1, 1); 
....................  	}  
.................... 	else {           				// Flanco de Bajada 
0314:  BRA    031A
....................    		ext_int_edge(2, L_TO_H);  	// Configuro flanco de subida 
0316:  BSF    FF1.4
....................   		flagInt2Edge = 0;    		// Indico que el siguiente flanco será de Subida 
0318:  BCF    x59.0
.................... 	    //output_bit(LED1, 0); 
....................  	} 
.................... } 
.................... //--------------------------------------------------------------------------------------------- 
....................  
.................... //Recepción de datos de modem gsm 
031A:  BCF    FF0.1
031C:  MOVLB  0
031E:  GOTO   006C
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
.................... 	  if(kbhit(SIM300)){ 
*
033A:  BTFSS  F9E.5
033C:  BRA    0382
.................... 	    if (buf_index < BUFFER_SIZE){  
033E:  MOVLB  1
0340:  INCFSZ x17,W
0342:  BRA    0346
0344:  BRA    0380
.................... 		    buffer[buf_index]=fgetc(SIM300); 
0346:  CLRF   03
0348:  MOVF   x17,W
034A:  ADDLW  17
034C:  MOVWF  FE9
034E:  MOVLW  00
0350:  ADDWFC 03,W
0352:  MOVWF  FEA
0354:  MOVFF  FEA,422
0358:  MOVFF  FE9,421
035C:  MOVLB  0
035E:  BRA    0322
0360:  MOVFF  422,FEA
0364:  MOVFF  421,FE9
0368:  MOVFF  01,FEF
.................... 		    buf_index++;  
036C:  MOVLB  1
036E:  INCF   x17,F
.................... 		    buffer[buf_index] = 0;  
0370:  CLRF   03
0372:  MOVF   x17,W
0374:  ADDLW  17
0376:  MOVWF  FE9
0378:  MOVLW  00
037A:  ADDWFC 03,W
037C:  MOVWF  FEA
037E:  CLRF   FEF
0380:  MOVLB  0
.................... 	    }  
.................... 	} 
.................... } 
.................... //--------------------------------------- Rutinas que atienden las interrupciones ------------------------------ 
....................  
.................... /************************************************************************************************ 
.................... | void GetEEPROMMed(long inx) Obtiene medicion almacenada y llena la estructura destino 
.................... | Retorna: llena variable readMed con los valores de medicion 
.................... | 
.................... ************************************************************************************************/ 
0382:  BCF    F9E.5
0384:  GOTO   006C
.................... void GetEEPROMMed(long inx) 
.................... { 
.................... 	char	*ptData, i; 
.................... 	address = INI_LOG_MEM + (inx * SZ_DATALOG); 
*
1E02:  MOVFF  37A,37F
1E06:  MOVFF  379,37E
1E0A:  MOVLB  3
1E0C:  CLRF   x81
1E0E:  MOVLW  17
1E10:  MOVWF  x80
1E12:  MOVLB  0
1E14:  RCALL  1CB6
1E16:  MOVF   01,W
1E18:  ADDLW  02
1E1A:  MOVLB  2
1E1C:  MOVWF  xE4
1E1E:  MOVLW  00
1E20:  ADDWFC 02,W
1E22:  MOVWF  xE5
.................... 	ptData = (char*)(&readMed); 
1E24:  MOVLW  03
1E26:  MOVLB  3
1E28:  MOVWF  x7F
1E2A:  MOVLW  01
1E2C:  MOVFF  37F,37C
1E30:  MOVWF  x7B
.................... 	for (i = 0; i < SZ_DATALOG; i++){ 
1E32:  CLRF   x7D
1E34:  MOVF   x7D,W
1E36:  SUBLW  16
1E38:  BNC   1E74
.................... 		*ptData = read_ext_eeprom(address); 
1E3A:  MOVFF  37C,03
1E3E:  MOVFF  37B,37E
1E42:  MOVFF  37C,37F
1E46:  MOVFF  2E5,381
1E4A:  MOVFF  2E4,380
1E4E:  MOVLB  0
1E50:  RCALL  1D86
1E52:  MOVFF  37F,FEA
1E56:  MOVFF  37E,FE9
1E5A:  MOVFF  01,FEF
.................... 		ptData++; 
1E5E:  MOVLB  3
1E60:  INCF   x7B,F
1E62:  BTFSC  FD8.2
1E64:  INCF   x7C,F
.................... 		address++; 
1E66:  MOVLB  2
1E68:  INCF   xE4,F
1E6A:  BTFSC  FD8.2
1E6C:  INCF   xE5,F
.................... 	} 
1E6E:  MOVLB  3
1E70:  INCF   x7D,F
1E72:  BRA    1E34
.................... }    
1E74:  MOVLB  0
1E76:  RETLW  00
.................... //-------------------------------------------------------------     
....................  
....................  
.................... /*-------------------------------------------------------------------------------------------------- 
.................... GetLastRainMed() | Toma las mediciones de las ultimas XX horas de precipitaciones  
.................... 					y las retorna para su envio 
.................... ---------------------------------------------------------------------------------------------------*/ 
.................... long GetLastRainMed(void) 
.................... { 
.................... 	long cnRain; 
.................... 	signed long int i; 
.................... 	int32  	dtLast, dtNew;	 
.................... 	//Si no hay medidas previas retornar 0 
.................... 	if (contData == 0 ) { 
*
1EB4:  MOVLB  2
1EB6:  MOVF   xE6,F
1EB8:  BNZ   1EC6
1EBA:  MOVF   xE7,F
1EBC:  BNZ   1EC6
.................... 	  return 0; 
1EBE:  MOVLW  00
1EC0:  MOVWF  01
1EC2:  MOVWF  02
1EC4:  BRA    1FEE
.................... 	} 
.................... 	GetEEPROMMed(contData-1);		//Ultima medicion  
1EC6:  MOVLW  01
1EC8:  SUBWF  xE6,W
1ECA:  MOVLB  3
1ECC:  MOVWF  x77
1ECE:  MOVLW  00
1ED0:  MOVLB  2
1ED2:  SUBWFB xE7,W
1ED4:  MOVLB  3
1ED6:  MOVWF  x78
1ED8:  MOVWF  x7A
1EDA:  MOVFF  377,379
1EDE:  MOVLB  0
1EE0:  RCALL  1E02
.................... 	dtLast = readMed.dateTime; 
1EE2:  MOVFF  304,372
1EE6:  MOVFF  303,371
1EEA:  MOVFF  302,370
1EEE:  MOVFF  301,36F
.................... 	cnRain = readMed.precip; 
1EF2:  MOVFF  310,37A
1EF6:  MOVFF  30F,379
1EFA:  MOVFF  30E,378
1EFE:  MOVFF  30D,377
1F02:  RCALL  1E78
1F04:  MOVFF  02,36C
1F08:  MOVFF  01,36B
.................... 	dtNew = dtLast - (int32)(K_LLUVIA_H * 3600); 
1F0C:  MOVLW  80
1F0E:  MOVLB  3
1F10:  SUBWF  x6F,W
1F12:  MOVWF  x73
1F14:  MOVLW  51
1F16:  SUBWFB x70,W
1F18:  MOVWF  x74
1F1A:  MOVLW  01
1F1C:  SUBWFB x71,W
1F1E:  MOVWF  x75
1F20:  MOVLW  00
1F22:  SUBWFB x72,W
1F24:  MOVWF  x76
.................... 	if (contData == 1){ 
1F26:  MOVLB  2
1F28:  DECFSZ xE6,W
1F2A:  BRA    1F3C
1F2C:  MOVF   xE7,F
1F2E:  BNZ   1F3C
.................... 		return cnRain; 
1F30:  MOVFF  36B,01
1F34:  MOVFF  36C,02
1F38:  MOVLB  2
1F3A:  BRA    1FEE
.................... 	} 
.................... 	for (i = (contData-2); i >= 0; i--){ 
1F3C:  MOVLW  02
1F3E:  SUBWF  xE6,W
1F40:  MOVWF  00
1F42:  MOVLW  00
1F44:  SUBWFB xE7,W
1F46:  MOVWF  03
1F48:  MOVFF  00,36D
1F4C:  MOVLB  3
1F4E:  MOVWF  x6E
1F50:  BTFSC  x6E.7
1F52:  BRA    1FE4
1F54:  BRA    1F56
.................... 		GetEEPROMMed(i); 
1F56:  MOVFF  36E,37A
1F5A:  MOVFF  36D,379
1F5E:  MOVLB  0
1F60:  RCALL  1E02
.................... 		if (readMed.dateTime > dtNew){ 
1F62:  MOVLB  3
1F64:  MOVF   x76,W
1F66:  SUBWF  x04,W
1F68:  BNC   1FD4
1F6A:  BNZ   1F82
1F6C:  MOVF   x75,W
1F6E:  SUBWF  x03,W
1F70:  BNC   1FD4
1F72:  BNZ   1F82
1F74:  MOVF   x74,W
1F76:  SUBWF  x02,W
1F78:  BNC   1FD4
1F7A:  BNZ   1F82
1F7C:  MOVF   x01,W
1F7E:  SUBWF  x73,W
1F80:  BC    1FD4
.................... 			cnRain += readMed.precip; 
1F82:  MOVFF  36C,3A6
1F86:  MOVFF  36B,3A5
1F8A:  MOVLB  0
1F8C:  CALL   162C
1F90:  BCF    FD8.1
1F92:  MOVFF  03,3A8
1F96:  MOVFF  02,3A7
1F9A:  MOVFF  01,3A6
1F9E:  MOVFF  00,3A5
1FA2:  MOVFF  310,3AC
1FA6:  MOVFF  30F,3AB
1FAA:  MOVFF  30E,3AA
1FAE:  MOVFF  30D,3A9
1FB2:  CALL   1758
1FB6:  MOVFF  03,37A
1FBA:  MOVFF  02,379
1FBE:  MOVFF  01,378
1FC2:  MOVFF  00,377
1FC6:  RCALL  1E78
1FC8:  MOVFF  02,36C
1FCC:  MOVFF  01,36B
.................... 		} 
.................... 		else break;					// Acumula hasta K_LLUVIA_H horas 
1FD0:  BRA    1FD8
1FD2:  MOVLB  3
1FD4:  BRA    1FE4
1FD6:  MOVLB  0
.................... 	} 
1FD8:  MOVLB  3
1FDA:  MOVF   x6D,W
1FDC:  BTFSC  FD8.2
1FDE:  DECF   x6E,F
1FE0:  DECF   x6D,F
1FE2:  BRA    1F50
.................... 	return cnRain; 
1FE4:  MOVFF  36B,01
1FE8:  MOVFF  36C,02
1FEC:  MOVLB  2
.................... } 
1FEE:  MOVLB  0
1FF0:  GOTO   2700 (RETURN)
....................  
.................... /*------------------------------------------------------------------------------------------------ 
.................... | Leer_sensores(char prog) 
.................... | Lee sensores y los almacena en una estructura generica 
.................... | Parametro de entrada: prog <> 0 medida programada, 0 a pedido del usuario 
.................... ------------------------------------------------------------------------------------------------*/ 
.................... void Leer_sensores(char prog) 
.................... { 
.................... 	dataMed.dateTime = CurrDateTime();	// Obtiene la fecha y hora actual y la convierte en segundos 
*
22E6:  CALL   1150
22EA:  MOVFF  03,2ED
22EE:  MOVFF  02,2EC
22F2:  MOVFF  01,2EB
22F6:  MOVFF  00,2EA
.................... 	if (sensorHab & TEMP_HUM_S){		// Sensor de temperatura y humedad habilitado ? 
22FA:  MOVLB  1
22FC:  BTFSS  x7B.1
22FE:  BRA    2602
.................... 		sht_rd(dataMed.tempExt, dataMed.humedad); 
.................... 		//Chequeo posible error de medida 
.................... 		if (dataMed.humedad < 0 ){ 
*
25D2:  MOVFF  2F1,37A
25D6:  MOVFF  2F0,379
25DA:  MOVFF  2EF,378
25DE:  MOVFF  2EE,377
25E2:  MOVLB  3
25E4:  CLRF   x7E
25E6:  CLRF   x7D
25E8:  CLRF   x7C
25EA:  CLRF   x7B
25EC:  MOVLB  0
25EE:  CALL   19D0
25F2:  BNC   2600
.................... 			dataMed.humedad = 0;		 
25F4:  MOVLB  2
25F6:  CLRF   xF1
25F8:  CLRF   xF0
25FA:  CLRF   xEF
25FC:  CLRF   xEE
25FE:  MOVLB  0
2600:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & RAINFALL_S){		// Sensor de precipitacion habilitado ? 
2602:  BTFSS  x7B.2
2604:  BRA    2758
.................... 		llueveAhora = 0;		 
2606:  CLRF   x76
.................... 		if (countPrec != 0) { 
2608:  MOVF   x5C,F
260A:  BNZ   2610
260C:  MOVF   x5D,F
260E:  BZ    2614
.................... 			llueveAhora = 1;		 
2610:  MOVLW  01
2612:  MOVWF  x76
.................... 		} 
.................... 		int32 seconds = (dataMed.dateTime - secUltMed); 
.................... 		float actual = ((float)(countPrec * ctePluv)); 
2614:  MOVF   x77,W
2616:  MOVLB  2
2618:  SUBWF  xEA,W
261A:  MOVLB  3
261C:  MOVWF  x61
261E:  MOVLB  1
2620:  MOVF   x78,W
2622:  MOVLB  2
2624:  SUBWFB xEB,W
2626:  MOVLB  3
2628:  MOVWF  x62
262A:  MOVLB  1
262C:  MOVF   x79,W
262E:  MOVLB  2
2630:  SUBWFB xEC,W
2632:  MOVLB  3
2634:  MOVWF  x63
2636:  MOVLB  1
2638:  MOVF   x7A,W
263A:  MOVLB  2
263C:  SUBWFB xED,W
263E:  MOVLB  3
2640:  MOVWF  x64
2642:  MOVFF  15D,3A6
2646:  MOVFF  15C,3A5
264A:  MOVLB  0
264C:  CALL   162C
2650:  MOVFF  03,410
2654:  MOVFF  02,40F
2658:  MOVFF  01,40E
265C:  MOVFF  00,40D
2660:  MOVFF  16D,414
2664:  MOVFF  16C,413
2668:  MOVFF  16B,412
266C:  MOVFF  16A,411
2670:  CALL   1662
2674:  MOVFF  03,368
2678:  MOVFF  02,367
267C:  MOVFF  01,366
2680:  MOVFF  00,365
.................... 		if (prog){						// Si es programada es <> 0  
2684:  MOVLB  3
2686:  MOVF   x60,F
2688:  BZ    26CE
.................... 			dataMed.precip = actual ; 
268A:  MOVFF  368,2F9
268E:  MOVFF  367,2F8
2692:  MOVFF  366,2F7
2696:  MOVFF  365,2F6
.................... 			dataMed.intensidad = obtenerIntensidad(seconds, dataMed.precip); 
269A:  MOVFF  364,36E
269E:  MOVFF  363,36D
26A2:  MOVFF  362,36C
26A6:  MOVFF  361,36B
26AA:  MOVFF  2F9,372
26AE:  MOVFF  2F8,371
26B2:  MOVFF  2F7,370
26B6:  MOVFF  2F6,36F
26BA:  MOVLB  0
26BC:  CALL   1B04
26C0:  MOVFF  01,2FA
.................... 			countPrec = 0; 
26C4:  MOVLB  1
26C6:  CLRF   x5D
26C8:  CLRF   x5C
.................... 		} 
.................... 		else{ 
26CA:  BRA    2758
26CC:  MOVLB  3
.................... 		    long acumulado = 0; 
26CE:  CLRF   x6A
26D0:  CLRF   x69
.................... 			//Quiero mostrarle al usuario, lo acumulado + los precipitado en el lapso de tiempo de la ultima   
.................... 			//medida programada y ahora 
.................... 			dataMed.intensidad = obtenerIntensidad(seconds, actual); 
26D2:  MOVFF  364,36E
26D6:  MOVFF  363,36D
26DA:  MOVFF  362,36C
26DE:  MOVFF  361,36B
26E2:  MOVFF  368,372
26E6:  MOVFF  367,371
26EA:  MOVFF  366,370
26EE:  MOVFF  365,36F
26F2:  MOVLB  0
26F4:  CALL   1B04
26F8:  MOVFF  01,2FA
.................... 			acumulado = GetLastRainMed()  + countPrec; 
26FC:  GOTO   1EB4
2700:  MOVLB  1
2702:  MOVF   x5C,W
2704:  MOVLB  3
2706:  ADDWF  01,W
2708:  MOVWF  x69
270A:  MOVLB  1
270C:  MOVF   x5D,W
270E:  MOVLB  3
2710:  ADDWFC 02,W
2712:  MOVWF  x6A
.................... 			dataMed.precip =  ((float)(acumulado * ctePluv)); 
2714:  MOVFF  36A,3A6
2718:  MOVFF  369,3A5
271C:  MOVLB  0
271E:  CALL   162C
2722:  MOVFF  03,410
2726:  MOVFF  02,40F
272A:  MOVFF  01,40E
272E:  MOVFF  00,40D
2732:  MOVFF  16D,414
2736:  MOVFF  16C,413
273A:  MOVFF  16B,412
273E:  MOVFF  16A,411
2742:  CALL   1662
2746:  MOVFF  03,2F9
274A:  MOVFF  02,2F8
274E:  MOVFF  01,2F7
2752:  MOVFF  00,2F6
2756:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & PREASURE_S){		// Sensor de presion habilitado ? 
2758:  BTFSS  x7B.3
275A:  BRA    2772
.................... 		dataMed.preasure = obtenerPresion(); 
275C:  MOVLB  0
275E:  BRA    2152
2760:  MOVFF  03,2FE
2764:  MOVFF  02,2FD
2768:  MOVFF  01,2FC
276C:  MOVFF  00,2FB
2770:  MOVLB  1
.................... 	} 
.................... 	secUltMed = dataMed.dateTime; 
2772:  MOVFF  2ED,17A
2776:  MOVFF  2EC,179
277A:  MOVFF  2EB,178
277E:  MOVFF  2EA,177
.................... } 
2782:  MOVLB  0
2784:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | StoreMed2EEPROM(void) Almacena medicion en memoria 
.................... | CN_MEMDATA_L 
.................... | CN_MEMDATA_H 
.................... | INI_LOG_MEM	 
.................... | 
.................... ************************************************************************************************/ 
.................... void StoreMed2EEPROM(void) 
.................... { 
.................... 	BYTE	*ptData, i; 
....................  
.................... 	address = CN_MEMDATA_L; 
*
2850:  MOVLB  2
2852:  CLRF   xE5
2854:  CLRF   xE4
.................... 	contData = read_ext_eeprom(address); 
2856:  MOVFF  2E5,381
285A:  MOVFF  2E4,380
285E:  MOVLB  0
2860:  CALL   1D86
2864:  MOVLB  2
2866:  CLRF   xE7
2868:  MOVFF  01,2E6
.................... 	address = CN_MEMDATA_H; 
286C:  CLRF   xE5
286E:  MOVLW  01
2870:  MOVWF  xE4
.................... 	contData += (read_ext_eeprom(address) * 256); 
2872:  MOVFF  2E5,381
2876:  MOVFF  2E4,380
287A:  MOVLB  0
287C:  CALL   1D86
2880:  MOVLB  3
2882:  CLRF   x7F
2884:  MOVFF  01,37E
2888:  MOVLW  01
288A:  MOVWF  x81
288C:  CLRF   x80
288E:  MOVLB  0
2890:  CALL   1CB6
2894:  MOVF   01,W
2896:  MOVLB  2
2898:  ADDWF  xE6,F
289A:  MOVF   02,W
289C:  ADDWFC xE7,F
.................... 	address = INI_LOG_MEM + (contData * SZ_DATALOG); 
289E:  MOVFF  2E7,37F
28A2:  MOVFF  2E6,37E
28A6:  MOVLB  3
28A8:  CLRF   x81
28AA:  MOVLW  17
28AC:  MOVWF  x80
28AE:  MOVLB  0
28B0:  CALL   1CB6
28B4:  MOVF   01,W
28B6:  ADDLW  02
28B8:  MOVLB  2
28BA:  MOVWF  xE4
28BC:  MOVLW  00
28BE:  ADDWFC 02,W
28C0:  MOVWF  xE5
.................... 	ptData = &dataMed; 
28C2:  MOVLW  02
28C4:  MOVLB  3
28C6:  MOVWF  x55
28C8:  MOVLW  EA
28CA:  MOVWF  x54
.................... 	for (i = 0; i < SZ_DATALOG; i++){ 
28CC:  CLRF   x56
28CE:  MOVF   x56,W
28D0:  SUBLW  16
28D2:  BNC   2906
.................... 		data = *ptData; 
28D4:  MOVFF  354,FE9
28D8:  MOVFF  355,FEA
28DC:  MOVFF  FEF,2E8
28E0:  MOVLB  2
.................... 		write_ext_eeprom(address, data); 
28E2:  MOVFF  2E5,393
28E6:  MOVFF  2E4,392
28EA:  MOVFF  2E8,394
28EE:  MOVLB  0
28F0:  RCALL  2786
.................... 		address++; 
28F2:  MOVLB  2
28F4:  INCF   xE4,F
28F6:  BTFSC  FD8.2
28F8:  INCF   xE5,F
.................... 		ptData++; 
28FA:  MOVLB  3
28FC:  INCF   x54,F
28FE:  BTFSC  FD8.2
2900:  INCF   x55,F
.................... 	} 
2902:  INCF   x56,F
2904:  BRA    28CE
.................... 	contData++; 
2906:  MOVLB  2
2908:  INCF   xE6,F
290A:  BTFSC  FD8.2
290C:  INCF   xE7,F
.................... 	address = CN_MEMDATA_L; 
290E:  CLRF   xE5
2910:  CLRF   xE4
.................... 	data = contData & 0x00FF; 
2912:  MOVFF  2E6,2E8
.................... 	write_ext_eeprom(address, data); 
2916:  MOVFF  2E5,393
291A:  MOVFF  2E4,392
291E:  MOVFF  2E8,394
2922:  MOVLB  0
2924:  RCALL  2786
.................... 	address = CN_MEMDATA_H; 
2926:  MOVLB  2
2928:  CLRF   xE5
292A:  MOVLW  01
292C:  MOVWF  xE4
.................... 	data = contData >> 8; 
292E:  MOVFF  2E7,2E8
.................... 	write_ext_eeprom(address, data); 
2932:  MOVFF  2E5,393
2936:  MOVFF  2E4,392
293A:  MOVFF  2E8,394
293E:  MOVLB  0
2940:  RCALL  2786
.................... 	 
.................... 	if (contData > MAX_LOG_CNT){ 
2942:  MOVLB  2
2944:  MOVF   xE7,W
2946:  SUBLW  02
2948:  BC    295C
294A:  XORLW  FF
294C:  BNZ   2954
294E:  MOVF   xE6,W
2950:  SUBLW  E8
2952:  BC    295C
.................... 		memoryFull = 1;  
2954:  MOVLW  01
2956:  MOVLB  1
2958:  MOVWF  x71
295A:  MOVLB  2
.................... 	} 
.................... } 
295C:  MOVLB  0
295E:  GOTO   4C0E (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Funcion para lectura de los sms 
.................... | Parametro de entrada: variable para almacenar el contenido del sms 
.................... ************************************************************************************************/ 
.................... long LeerSmsCmd(char *sms)  
.................... { 
*
3978:  MOVLB  3
397A:  CLRF   x56
.................... 	int  rta = 0; 
.................... 	char *pt, sepCh[2];	 
.................... 	char *ptr; 
.................... 	char *ptr2; 
.................... 	int	 i; 
.................... 	//Chequeo en las otras posiciones en caso que se hay encolado algun SMS 
.................... 	clear_buffer_gsm(); 
397C:  MOVLB  0
397E:  CALL   06F0
.................... 	fprintf(SIM300,"AT+CMGR=%d,0\r",guia); 
3982:  MOVLW  88
3984:  MOVWF  FF6
3986:  MOVLW  03
3988:  MOVWF  FF7
398A:  MOVLW  08
398C:  MOVLB  3
398E:  MOVWF  x65
3990:  MOVLB  0
3992:  CALL   08DC
3996:  MOVFF  130,362
399A:  MOVLW  1F
399C:  MOVLB  3
399E:  MOVWF  x63
39A0:  MOVLB  0
39A2:  CALL   0932
39A6:  MOVLW  2C
39A8:  BTFSS  F9E.4
39AA:  BRA    39A8
39AC:  MOVWF  FAD
39AE:  MOVLW  30
39B0:  BTFSS  F9E.4
39B2:  BRA    39B0
39B4:  MOVWF  FAD
39B6:  MOVLW  0D
39B8:  BTFSS  F9E.4
39BA:  BRA    39B8
39BC:  MOVWF  FAD
.................... 	delay_ms(2000); 
39BE:  MOVLW  08
39C0:  MOVLB  3
39C2:  MOVWF  x61
39C4:  MOVLW  FA
39C6:  MOVWF  x74
39C8:  MOVLB  0
39CA:  CALL   058A
39CE:  MOVLB  3
39D0:  DECFSZ x61,F
39D2:  BRA    39C4
.................... 	if(gprs_response(sms_noleido,1000)!=0){   // Verifica si hay un Mensaje no leido 
39D4:  MOVLW  01
39D6:  MOVWF  x66
39D8:  MOVLW  27
39DA:  MOVWF  x65
39DC:  MOVLW  03
39DE:  MOVWF  x68
39E0:  MOVLW  E8
39E2:  MOVWF  x67
39E4:  MOVLB  0
39E6:  CALL   0662
39EA:  MOVFF  02,362
39EE:  MOVFF  01,361
39F2:  MOVLB  3
39F4:  MOVF   x61,F
39F6:  BNZ   39FE
39F8:  MOVF   x62,F
39FA:  BTFSC  FD8.2
39FC:  BRA    3B6C
.................... 		pt = gprs_response(telnum,1000); 
39FE:  MOVLW  01
3A00:  MOVWF  x66
3A02:  MOVLW  48
3A04:  MOVWF  x65
3A06:  MOVLW  03
3A08:  MOVWF  x68
3A0A:  MOVLW  E8
3A0C:  MOVWF  x67
3A0E:  MOVLB  0
3A10:  CALL   0662
3A14:  MOVFF  02,358
3A18:  MOVFF  01,357
.................... 		if(pt!=0){ 
3A1C:  MOVLB  3
3A1E:  MOVF   x57,F
3A20:  BNZ   3A28
3A22:  MOVF   x58,F
3A24:  BTFSC  FD8.2
3A26:  BRA    3B58
.................... 			clear_var(smsText); 
3A28:  MOVLW  01
3A2A:  MOVWF  xFD
3A2C:  MOVLW  82
3A2E:  MOVWF  xFC
3A30:  MOVLB  0
3A32:  CALL   0A6C
.................... 			strcpy(sepCh, "\""); 
3A36:  MOVLW  03
3A38:  MOVWF  FEA
3A3A:  MOVLW  59
3A3C:  MOVWF  FE9
3A3E:  MOVFF  FF2,361
3A42:  BCF    FF2.7
3A44:  MOVLW  00
3A46:  CALL   00E0
3A4A:  TBLRD*-
3A4C:  TBLRD*+
3A4E:  MOVF   FF5,W
3A50:  MOVWF  FEE
3A52:  IORLW  00
3A54:  BNZ   3A4C
3A56:  MOVLB  3
3A58:  BTFSC  x61.7
3A5A:  BSF    FF2.7
.................... 			ptr = strtok(pt, sepCh); 
3A5C:  MOVFF  358,393
3A60:  MOVFF  357,392
3A64:  MOVLW  03
3A66:  MOVWF  x95
3A68:  MOVLW  59
3A6A:  MOVWF  x94
3A6C:  MOVLB  0
3A6E:  RCALL  3846
3A70:  MOVFF  02,35C
3A74:  MOVFF  01,35B
.................... 			do { 
.................... 				ptr2 = ptr; 
3A78:  MOVFF  35C,35E
3A7C:  MOVFF  35B,35D
.................... 			} while((ptr = strtok( NULL, sepCh)) != NULL ); 
3A80:  MOVLB  3
3A82:  CLRF   x93
3A84:  CLRF   x92
3A86:  MOVLW  03
3A88:  MOVWF  x95
3A8A:  MOVLW  59
3A8C:  MOVWF  x94
3A8E:  MOVLB  0
3A90:  RCALL  3846
3A92:  MOVFF  02,35C
3A96:  MOVFF  01,35B
3A9A:  MOVLB  3
3A9C:  MOVF   x5B,F
3A9E:  BTFSC  FD8.2
3AA0:  BRA    3AA6
3AA2:  MOVLB  0
3AA4:  BRA    3A78
3AA6:  MOVF   x5C,F
3AA8:  BTFSC  FD8.2
3AAA:  BRA    3AB0
3AAC:  MOVLB  0
3AAE:  BRA    3A78
.................... 			strcpy(sepCh, "\r"); 
3AB0:  MOVLW  03
3AB2:  MOVWF  FEA
3AB4:  MOVLW  59
3AB6:  MOVWF  FE9
3AB8:  MOVFF  FF2,361
3ABC:  BCF    FF2.7
3ABE:  MOVLW  00
3AC0:  MOVLB  0
3AC2:  CALL   00FC
3AC6:  TBLRD*-
3AC8:  TBLRD*+
3ACA:  MOVF   FF5,W
3ACC:  MOVWF  FEE
3ACE:  IORLW  00
3AD0:  BNZ   3AC8
3AD2:  MOVLB  3
3AD4:  BTFSC  x61.7
3AD6:  BSF    FF2.7
.................... 			strtok(NULL, sepCh); 
3AD8:  CLRF   x93
3ADA:  CLRF   x92
3ADC:  MOVLW  03
3ADE:  MOVWF  x95
3AE0:  MOVLW  59
3AE2:  MOVWF  x94
3AE4:  MOVLB  0
3AE6:  RCALL  3846
.................... 			ptr2++; 
3AE8:  MOVLB  3
3AEA:  INCF   x5D,F
3AEC:  BTFSC  FD8.2
3AEE:  INCF   x5E,F
.................... 			ptr2++; 
3AF0:  INCF   x5D,F
3AF2:  BTFSC  FD8.2
3AF4:  INCF   x5E,F
.................... 			for (i = 0; i < SZ_SMSTXT; i++){ 
3AF6:  CLRF   x5F
3AF8:  MOVF   x5F,W
3AFA:  SUBLW  A4
3AFC:  BNC   3B3C
.................... 				if ((ptr2[i] == '\r') || (ptr2[i] == '\n')){ 
3AFE:  CLRF   03
3B00:  MOVF   x5F,W
3B02:  ADDWF  x5D,W
3B04:  MOVWF  FE9
3B06:  MOVF   x5E,W
3B08:  ADDWFC 03,W
3B0A:  MOVWF  FEA
3B0C:  MOVF   FEF,W
3B0E:  SUBLW  0D
3B10:  BZ    3B26
3B12:  CLRF   03
3B14:  MOVF   x5F,W
3B16:  ADDWF  x5D,W
3B18:  MOVWF  FE9
3B1A:  MOVF   x5E,W
3B1C:  ADDWFC 03,W
3B1E:  MOVWF  FEA
3B20:  MOVF   FEF,W
3B22:  SUBLW  0A
3B24:  BNZ   3B38
.................... 					ptr2[i] = 0; 
3B26:  CLRF   03
3B28:  MOVF   x5F,W
3B2A:  ADDWF  x5D,W
3B2C:  MOVWF  FE9
3B2E:  MOVF   x5E,W
3B30:  ADDWFC 03,W
3B32:  MOVWF  FEA
3B34:  CLRF   FEF
.................... 					break; 
3B36:  BRA    3B3C
.................... 				} 
.................... 			} 
3B38:  INCF   x5F,F
3B3A:  BRA    3AF8
.................... 			strcpy(sms,ptr2); 
3B3C:  MOVFF  355,FEA
3B40:  MOVFF  354,FE9
3B44:  MOVFF  35E,FE2
3B48:  MOVFF  35D,FE1
3B4C:  MOVF   FE7,F
3B4E:  MOVFF  FE6,FEE
3B52:  BNZ   3B4C
.................... 			rta = guia; 
3B54:  MOVFF  130,356
.................... 		} 
.................... 		int resp = borrar_sms(); 
3B58:  MOVLB  0
3B5A:  BRA    38FE
3B5C:  MOVFF  01,360
.................... 		if (!resp){ 
3B60:  MOVLB  3
3B62:  MOVF   x60,F
3B64:  BNZ   3B6C
.................... 			guia++; 
3B66:  MOVLB  1
3B68:  INCF   x30,F
3B6A:  MOVLB  3
.................... 		} 
.................... 	}  
....................     return rta; 
3B6C:  CLRF   03
3B6E:  MOVFF  356,01
3B72:  MOVFF  03,02
.................... } 
3B76:  MOVLB  0
3B78:  GOTO   4E40 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Funcion para enviar los sms 
.................... | Parametro de entrada: variable para almacenar el contenido del sms, numero donde enviar el sms 
.................... ************************************************************************************************/ 
.................... long EnviarSms(char *sms, char *tel) 
.................... {	 
.................... 	char	tmOut; 
.................... 	clear_buffer_gsm(); 
*
131C:  CALL   06F0
.................... 	fprintf(SIM300,"AT+CMGS=\"%s\"\r",tel); // Teléfono al cúal le enviaremos el mensaje. 
1320:  MOVLW  96
1322:  MOVWF  FF6
1324:  MOVLW  03
1326:  MOVWF  FF7
1328:  MOVLW  09
132A:  MOVLB  3
132C:  MOVWF  x65
132E:  MOVLB  0
1330:  CALL   08DC
1334:  MOVFF  363,FEA
1338:  MOVFF  362,FE9
133C:  RCALL  12EC
133E:  MOVLW  22
1340:  BTFSS  F9E.4
1342:  BRA    1340
1344:  MOVWF  FAD
1346:  MOVLW  0D
1348:  BTFSS  F9E.4
134A:  BRA    1348
134C:  MOVWF  FAD
.................... 	tmOut = 150; 
134E:  MOVLW  96
1350:  MOVLB  3
1352:  MOVWF  x64
.................... 	do { 
.................... 		tmOut--; 
1354:  DECF   x64,F
.................... 	}while((gprs_response(caracter,2000) == NULL) && (tmOut != 0)); 
1356:  MOVLW  01
1358:  MOVWF  x66
135A:  MOVLW  2E
135C:  MOVWF  x65
135E:  MOVLW  07
1360:  MOVWF  x68
1362:  MOVLW  D0
1364:  MOVWF  x67
1366:  MOVLB  0
1368:  CALL   0662
136C:  MOVFF  02,366
1370:  MOVFF  01,365
1374:  MOVLB  3
1376:  MOVF   x65,F
1378:  BNZ   1382
137A:  MOVF   x66,F
137C:  BNZ   1382
137E:  MOVF   x64,F
1380:  BNZ   1354
.................... 	 
.................... 	fprintf(SIM300,"%s",sms);             // Imprimimos mensaje a enviar.  
1382:  MOVFF  361,FEA
1386:  MOVFF  360,FE9
138A:  MOVLB  0
138C:  RCALL  12EC
.................... 	delay_ms(2000);   
138E:  MOVLW  08
1390:  MOVLB  3
1392:  MOVWF  x65
1394:  MOVLW  FA
1396:  MOVWF  x74
1398:  MOVLB  0
139A:  CALL   058A
139E:  MOVLB  3
13A0:  DECFSZ x65,F
13A2:  BRA    1394
.................... 	fputc(0x1A,SIM300);                   // Comando para enviar el mensaje. Equivale al CRTL+Z. 
13A4:  MOVLW  1A
13A6:  MOVLB  0
13A8:  BRA    1312
.................... 	clear_buffer_gsm(); 
13AA:  CALL   06F0
....................   return 0; 
13AE:  MOVLW  00
13B0:  MOVWF  01
13B2:  MOVWF  02
.................... } 
13B4:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | Limpia el buffer usado para guardar comunicacion con modem gsm 
.................... ************************************************************************************************/ 
.................... void clear_var(char* sms)  /*borra el buffer sms */ 
.................... {  
*
0A6C:  MOVLB  3
0A6E:  CLRF   xFE
....................   int erase = 0;  
....................   while(erase < SZ_SMSTXT) { 
0A70:  MOVF   xFE,W
0A72:  SUBLW  A4
0A74:  BNC   0A8A
.................... 	sms[erase] = '\0'; 
0A76:  CLRF   03
0A78:  MOVF   xFE,W
0A7A:  ADDWF  xFC,W
0A7C:  MOVWF  FE9
0A7E:  MOVF   xFD,W
0A80:  ADDWFC 03,W
0A82:  MOVWF  FEA
0A84:  CLRF   FEF
.................... 	erase++; 
0A86:  INCF   xFE,F
....................   } 
0A88:  BRA    0A70
.................... }  
0A8A:  MOVLB  0
0A8C:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | Inicializa la EEPROM 
.................... ************************************************************************************************/ 
.................... void inicializa_eeprom(void) 
.................... { 
.................... 	contData = 0; 
*
3F66:  MOVLB  2
3F68:  CLRF   xE7
3F6A:  CLRF   xE6
.................... 	memoryFull = 0;  
3F6C:  MOVLB  1
3F6E:  CLRF   x71
.................... 	address = CN_MEMDATA_L; 
3F70:  MOVLB  2
3F72:  CLRF   xE5
3F74:  CLRF   xE4
.................... 	write_ext_eeprom(address, 0); 
3F76:  MOVFF  2E5,393
3F7A:  MOVFF  2E4,392
3F7E:  MOVLB  3
3F80:  CLRF   x94
3F82:  MOVLB  0
3F84:  CALL   2786
.................... 	address = CN_MEMDATA_H; 
3F88:  MOVLB  2
3F8A:  CLRF   xE5
3F8C:  MOVLW  01
3F8E:  MOVWF  xE4
.................... 	write_ext_eeprom(address, 0); 
3F90:  MOVFF  2E5,393
3F94:  MOVFF  2E4,392
3F98:  MOVLB  3
3F9A:  CLRF   x94
3F9C:  MOVLB  0
3F9E:  CALL   2786
.................... } 
3FA2:  GOTO   47BE (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Verifica si la memoria EEPROM esta llena o no 
.................... ************************************************************************************************/ 
.................... void verifica_eeprom(void)  /*borra el buffer sms */ 
.................... {  
.................... 	//--- Verifica condicion de memoria al inicio 
.................... 	address = CN_MEMDATA_L; 
.................... 	contData = read_ext_eeprom(address); 
.................... 	address = CN_MEMDATA_H; 
.................... 	contData += (read_ext_eeprom(address) * 256); 
.................... 	if (contData > MAX_LOG_CNT){ 
.................... 		memoryFull = 1;     
.................... 	} 
.................... 	//--- Verifica condicion de memoria al inicio 
.................... }  
....................  
....................  
.................... /************************************************************************************************ 
.................... | int  ProcessMessage(char *msg) 
.................... | Analiza el string del mensaje recibido y procesa el comando correspondiente 
.................... | 
.................... ************************************************************************************************/ 
.................... int  ProcessMessage(char *msg) 
.................... { 
.................... 	char 	aux[30], aux2[8], sepCh[2], *ptr, *telnumaux; 
.................... 	BYTE  	hora, min, dia, mes, year; 
.................... 	BYTE	typeAlrm, i, done; 
.................... 	float	maxAlrm, minAlrm; 
.................... 	 
.................... 	memset(aux, 0, sizeof(aux)); 
3FA6:  MOVLW  03
3FA8:  MOVWF  FEA
3FAA:  MOVLW  56
3FAC:  MOVWF  FE9
3FAE:  MOVLB  3
3FB0:  CLRF   x92
3FB2:  CLRF   x94
3FB4:  MOVLW  1E
3FB6:  MOVWF  x93
3FB8:  MOVLB  0
3FBA:  BRA    3B7C
.................... 	strcpy(aux, msg); 
3FBC:  MOVLW  03
3FBE:  MOVWF  FEA
3FC0:  MOVLW  56
3FC2:  MOVWF  FE9
3FC4:  MOVFF  355,FE2
3FC8:  MOVFF  354,FE1
3FCC:  MOVF   FE7,F
3FCE:  MOVFF  FE6,FEE
3FD2:  BNZ   3FCC
.................... 	strcpy(sepCh, "|"); 
3FD4:  MOVLW  03
3FD6:  MOVWF  FEA
3FD8:  MOVLW  7C
3FDA:  MOVWF  FE9
3FDC:  MOVFF  FF2,392
3FE0:  BCF    FF2.7
3FE2:  MOVLW  00
3FE4:  CALL   0118
3FE8:  TBLRD*-
3FEA:  TBLRD*+
3FEC:  MOVF   FF5,W
3FEE:  MOVWF  FEE
3FF0:  IORLW  00
3FF2:  BNZ   3FEA
3FF4:  MOVLB  3
3FF6:  BTFSC  x92.7
3FF8:  BSF    FF2.7
.................... 	ptr = strtok(aux, sepCh); 
3FFA:  MOVLW  03
3FFC:  MOVWF  x93
3FFE:  MOVLW  56
4000:  MOVWF  x92
4002:  MOVLW  03
4004:  MOVWF  x95
4006:  MOVLW  7C
4008:  MOVWF  x94
400A:  MOVLB  0
400C:  RCALL  3846
400E:  MOVFF  02,37F
4012:  MOVFF  01,37E
.................... 	strcpy(aux2, "AA"); 
4016:  MOVLW  03
4018:  MOVWF  FEA
401A:  MOVLW  74
401C:  MOVWF  FE9
401E:  MOVFF  FF2,392
4022:  BCF    FF2.7
4024:  MOVLW  00
4026:  CALL   0134
402A:  TBLRD*-
402C:  TBLRD*+
402E:  MOVF   FF5,W
4030:  MOVWF  FEE
4032:  IORLW  00
4034:  BNZ   402C
4036:  MOVLB  3
4038:  BTFSC  x92.7
403A:  BSF    FF2.7
.................... 	if (strcmp(ptr, aux2) == 0) { 
403C:  MOVFF  37F,393
4040:  MOVFF  37E,392
4044:  MOVLW  03
4046:  MOVWF  x95
4048:  MOVLW  74
404A:  MOVWF  x94
404C:  MOVLB  0
404E:  RCALL  3B9C
4050:  MOVF   01,F
4052:  BTFSS  FD8.2
4054:  BRA    4398
.................... 		//------------------------------------ Procesa Alta de alarma -------------------------------- 
.................... 		ptr = strtok(null, sepCh); 
4056:  MOVLB  3
4058:  CLRF   x93
405A:  CLRF   x92
405C:  MOVLW  03
405E:  MOVWF  x95
4060:  MOVLW  7C
4062:  MOVWF  x94
4064:  MOVLB  0
4066:  CALL   3846
406A:  MOVFF  02,37F
406E:  MOVFF  01,37E
.................... 		if (ptr != NULL) typeAlrm = *ptr;		// Tipo alarma 
4072:  MOVLB  3
4074:  MOVF   x7E,F
4076:  BNZ   407C
4078:  MOVF   x7F,F
407A:  BZ    408A
407C:  MOVFF  37E,FE9
4080:  MOVFF  37F,FEA
4084:  MOVFF  FEF,387
.................... 		else return TYP_SMS_ERR; 
4088:  BRA    4092
408A:  MOVLW  F0
408C:  MOVWF  01
408E:  GOTO   494C
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
4092:  CLRF   x93
4094:  CLRF   x92
4096:  MOVLW  03
4098:  MOVWF  x95
409A:  MOVLW  7C
409C:  MOVWF  x94
409E:  MOVLB  0
40A0:  CALL   3846
40A4:  MOVFF  02,37F
40A8:  MOVFF  01,37E
.................... 		if (ptr != NULL) maxAlrm = atof(ptr);	// Valor maximo 
40AC:  MOVLB  3
40AE:  MOVF   x7E,F
40B0:  BNZ   40B6
40B2:  MOVF   x7F,F
40B4:  BZ    40DA
40B6:  MOVFF  37F,393
40BA:  MOVFF  37E,392
40BE:  CLRF   x95
40C0:  CLRF   x94
40C2:  MOVLB  0
40C4:  RCALL  3C14
40C6:  MOVFF  03,38D
40CA:  MOVFF  02,38C
40CE:  MOVFF  01,38B
40D2:  MOVFF  00,38A
.................... 		else return TYP_SMS_ERR; 
40D6:  BRA    40E2
40D8:  MOVLB  3
40DA:  MOVLW  F0
40DC:  MOVWF  01
40DE:  GOTO   494C
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
40E2:  MOVLB  3
40E4:  CLRF   x93
40E6:  CLRF   x92
40E8:  MOVLW  03
40EA:  MOVWF  x95
40EC:  MOVLW  7C
40EE:  MOVWF  x94
40F0:  MOVLB  0
40F2:  CALL   3846
40F6:  MOVFF  02,37F
40FA:  MOVFF  01,37E
.................... 		if (ptr != NULL) minAlrm = atof(ptr);	// Valor minimo 
40FE:  MOVLB  3
4100:  MOVF   x7E,F
4102:  BNZ   4108
4104:  MOVF   x7F,F
4106:  BZ    412C
4108:  MOVFF  37F,393
410C:  MOVFF  37E,392
4110:  CLRF   x95
4112:  CLRF   x94
4114:  MOVLB  0
4116:  RCALL  3C14
4118:  MOVFF  03,391
411C:  MOVFF  02,390
4120:  MOVFF  01,38F
4124:  MOVFF  00,38E
.................... 		else return TYP_SMS_ERR; 
4128:  BRA    4134
412A:  MOVLB  3
412C:  MOVLW  F0
412E:  MOVWF  01
4130:  GOTO   494C
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
4134:  MOVLB  3
4136:  CLRF   x93
4138:  CLRF   x92
413A:  MOVLW  03
413C:  MOVWF  x95
413E:  MOVLW  7C
4140:  MOVWF  x94
4142:  MOVLB  0
4144:  CALL   3846
4148:  MOVFF  02,37F
414C:  MOVFF  01,37E
.................... 		if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4150:  MOVLB  3
4152:  MOVF   x7E,F
4154:  BNZ   415A
4156:  MOVF   x7F,F
4158:  BZ    4174
415A:  MOVLW  01
415C:  MOVWF  FEA
415E:  MOVLW  7C
4160:  MOVWF  FE9
4162:  MOVFF  37F,FE2
4166:  MOVFF  37E,FE1
416A:  MOVF   FE7,F
416C:  MOVFF  FE6,FEE
4170:  BNZ   416A
.................... 		else return TYP_SMS_ERR; 
4172:  BRA    417C
4174:  MOVLW  F0
4176:  MOVWF  01
4178:  GOTO   494C
.................... 		// 
.................... 		done = 0; 
417C:  CLRF   x89
.................... 		for (i = 0; i < 5; i++){ 
417E:  CLRF   x88
4180:  MOVF   x88,W
4182:  SUBLW  04
4184:  BTFSS  FD8.0
4186:  BRA    4282
.................... 			if (alarm[i].variable == typeAlrm){ 
4188:  MOVF   x88,W
418A:  MULLW  0B
418C:  MOVF   FF3,W
418E:  CLRF   x93
4190:  MOVWF  x92
4192:  MOVLW  01
4194:  ADDWF  x92,W
4196:  MOVWF  01
4198:  MOVLW  00
419A:  ADDWFC x93,W
419C:  MOVWF  03
419E:  MOVF   01,W
41A0:  ADDLW  18
41A2:  MOVWF  FE9
41A4:  MOVLW  03
41A6:  ADDWFC 03,W
41A8:  MOVWF  FEA
41AA:  MOVF   x87,W
41AC:  SUBWF  FEF,W
41AE:  BNZ   427E
.................... 				alarm[i].activa 	= 1; 
41B0:  MOVF   x88,W
41B2:  MULLW  0B
41B4:  MOVF   FF3,W
41B6:  CLRF   x93
41B8:  MOVWF  x92
41BA:  MOVLW  18
41BC:  ADDWF  x92,W
41BE:  MOVWF  FE9
41C0:  MOVLW  03
41C2:  ADDWFC x93,W
41C4:  MOVWF  FEA
41C6:  MOVLW  01
41C8:  MOVWF  FEF
.................... 				alarm[i].variable 	= typeAlrm; 
41CA:  MOVF   x88,W
41CC:  MULLW  0B
41CE:  MOVF   FF3,W
41D0:  CLRF   x93
41D2:  MOVWF  x92
41D4:  MOVLW  01
41D6:  ADDWF  x92,W
41D8:  MOVWF  01
41DA:  MOVLW  00
41DC:  ADDWFC x93,W
41DE:  MOVWF  03
41E0:  MOVF   01,W
41E2:  ADDLW  18
41E4:  MOVWF  FE9
41E6:  MOVLW  03
41E8:  ADDWFC 03,W
41EA:  MOVWF  FEA
41EC:  MOVFF  387,FEF
.................... 				alarm[i].max_value 	= maxAlrm; 
41F0:  MOVF   x88,W
41F2:  MULLW  0B
41F4:  MOVF   FF3,W
41F6:  CLRF   x93
41F8:  MOVWF  x92
41FA:  MOVLW  02
41FC:  ADDWF  x92,W
41FE:  MOVWF  01
4200:  MOVLW  00
4202:  ADDWFC x93,W
4204:  MOVWF  03
4206:  MOVF   01,W
4208:  ADDLW  18
420A:  MOVWF  FE9
420C:  MOVLW  03
420E:  ADDWFC 03,W
4210:  MOVWF  FEA
4212:  MOVFF  38A,FEF
4216:  MOVFF  38B,FEC
421A:  MOVFF  38C,FEC
421E:  MOVFF  38D,FEC
.................... 				alarm[i].min_value 	= minAlrm; 
4222:  MOVF   x88,W
4224:  MULLW  0B
4226:  MOVF   FF3,W
4228:  CLRF   x93
422A:  MOVWF  x92
422C:  MOVLW  06
422E:  ADDWF  x92,W
4230:  MOVWF  01
4232:  MOVLW  00
4234:  ADDWFC x93,W
4236:  MOVWF  03
4238:  MOVF   01,W
423A:  ADDLW  18
423C:  MOVWF  FE9
423E:  MOVLW  03
4240:  ADDWFC 03,W
4242:  MOVWF  FEA
4244:  MOVFF  38E,FEF
4248:  MOVFF  38F,FEC
424C:  MOVFF  390,FEC
4250:  MOVFF  391,FEC
.................... 				alarm[i].cnValid	= 0; 
4254:  MOVF   x88,W
4256:  MULLW  0B
4258:  MOVF   FF3,W
425A:  CLRF   x93
425C:  MOVWF  x92
425E:  MOVLW  0A
4260:  ADDWF  x92,W
4262:  MOVWF  01
4264:  MOVLW  00
4266:  ADDWFC x93,W
4268:  MOVWF  03
426A:  MOVF   01,W
426C:  ADDLW  18
426E:  MOVWF  FE9
4270:  MOVLW  03
4272:  ADDWFC 03,W
4274:  MOVWF  FEA
4276:  CLRF   FEF
.................... 				done = 1; 
4278:  MOVLW  01
427A:  MOVWF  x89
.................... 				break; 
427C:  BRA    4282
.................... 			} 
.................... 		} 
427E:  INCF   x88,F
4280:  BRA    4180
.................... 		if (done == 0){								// No existe variable en tabla de alarmas  
4282:  MOVF   x89,F
4284:  BTFSS  FD8.2
4286:  BRA    437E
.................... 			for (i = 0; i < 5; i++){ 
4288:  CLRF   x88
428A:  MOVF   x88,W
428C:  SUBLW  04
428E:  BNC   437C
.................... 				if (alarm[i].activa == 0){			// Actualiza valores de alarma y la activa 
4290:  MOVF   x88,W
4292:  MULLW  0B
4294:  MOVF   FF3,W
4296:  CLRF   x93
4298:  MOVWF  x92
429A:  MOVLW  18
429C:  ADDWF  x92,W
429E:  MOVWF  FE9
42A0:  MOVLW  03
42A2:  ADDWFC x93,W
42A4:  MOVWF  FEA
42A6:  MOVF   FEF,F
42A8:  BNZ   4378
.................... 					alarm[i].activa 	= 1; 
42AA:  MOVF   x88,W
42AC:  MULLW  0B
42AE:  MOVF   FF3,W
42B0:  CLRF   x93
42B2:  MOVWF  x92
42B4:  MOVLW  18
42B6:  ADDWF  x92,W
42B8:  MOVWF  FE9
42BA:  MOVLW  03
42BC:  ADDWFC x93,W
42BE:  MOVWF  FEA
42C0:  MOVLW  01
42C2:  MOVWF  FEF
.................... 					alarm[i].variable 	= typeAlrm; 
42C4:  MOVF   x88,W
42C6:  MULLW  0B
42C8:  MOVF   FF3,W
42CA:  CLRF   x93
42CC:  MOVWF  x92
42CE:  MOVLW  01
42D0:  ADDWF  x92,W
42D2:  MOVWF  01
42D4:  MOVLW  00
42D6:  ADDWFC x93,W
42D8:  MOVWF  03
42DA:  MOVF   01,W
42DC:  ADDLW  18
42DE:  MOVWF  FE9
42E0:  MOVLW  03
42E2:  ADDWFC 03,W
42E4:  MOVWF  FEA
42E6:  MOVFF  387,FEF
.................... 					alarm[i].max_value 	= maxAlrm; 
42EA:  MOVF   x88,W
42EC:  MULLW  0B
42EE:  MOVF   FF3,W
42F0:  CLRF   x93
42F2:  MOVWF  x92
42F4:  MOVLW  02
42F6:  ADDWF  x92,W
42F8:  MOVWF  01
42FA:  MOVLW  00
42FC:  ADDWFC x93,W
42FE:  MOVWF  03
4300:  MOVF   01,W
4302:  ADDLW  18
4304:  MOVWF  FE9
4306:  MOVLW  03
4308:  ADDWFC 03,W
430A:  MOVWF  FEA
430C:  MOVFF  38A,FEF
4310:  MOVFF  38B,FEC
4314:  MOVFF  38C,FEC
4318:  MOVFF  38D,FEC
.................... 					alarm[i].min_value 	= minAlrm; 
431C:  MOVF   x88,W
431E:  MULLW  0B
4320:  MOVF   FF3,W
4322:  CLRF   x93
4324:  MOVWF  x92
4326:  MOVLW  06
4328:  ADDWF  x92,W
432A:  MOVWF  01
432C:  MOVLW  00
432E:  ADDWFC x93,W
4330:  MOVWF  03
4332:  MOVF   01,W
4334:  ADDLW  18
4336:  MOVWF  FE9
4338:  MOVLW  03
433A:  ADDWFC 03,W
433C:  MOVWF  FEA
433E:  MOVFF  38E,FEF
4342:  MOVFF  38F,FEC
4346:  MOVFF  390,FEC
434A:  MOVFF  391,FEC
.................... 					alarm[i].cnValid	= 0; 
434E:  MOVF   x88,W
4350:  MULLW  0B
4352:  MOVF   FF3,W
4354:  CLRF   x93
4356:  MOVWF  x92
4358:  MOVLW  0A
435A:  ADDWF  x92,W
435C:  MOVWF  01
435E:  MOVLW  00
4360:  ADDWFC x93,W
4362:  MOVWF  03
4364:  MOVF   01,W
4366:  ADDLW  18
4368:  MOVWF  FE9
436A:  MOVLW  03
436C:  ADDWFC 03,W
436E:  MOVWF  FEA
4370:  CLRF   FEF
.................... 					done = 1; 
4372:  MOVLW  01
4374:  MOVWF  x89
.................... 					break; 
4376:  BRA    437C
.................... 				} 
.................... 			} 
4378:  INCF   x88,F
437A:  BRA    428A
.................... 		} 
.................... 		else { 
437C:  BRA    4384
.................... 			return TYP_SMS_AA;	 
437E:  MOVLW  02
4380:  MOVWF  01
4382:  BRA    494C
.................... 		} 
.................... 		if (done == 0) return TYP_SMS_ERR;		// Si no encuentra lugar libre para alarma sale con error 
4384:  MOVF   x89,F
4386:  BNZ   438E
4388:  MOVLW  F0
438A:  MOVWF  01
438C:  BRA    494C
.................... 		//-------------------------------------------------------------------------------------------- 
.................... 		return TYP_SMS_AA; 
438E:  MOVLW  02
4390:  MOVWF  01
4392:  BRA    494C
.................... 	} 
.................... 	else{ 
4394:  BRA    494C
4396:  MOVLB  0
.................... 		strcpy(aux2, "BA"); 
4398:  MOVLW  03
439A:  MOVWF  FEA
439C:  MOVLW  74
439E:  MOVWF  FE9
43A0:  MOVFF  FF2,392
43A4:  BCF    FF2.7
43A6:  MOVLW  00
43A8:  CALL   0152
43AC:  TBLRD*-
43AE:  TBLRD*+
43B0:  MOVF   FF5,W
43B2:  MOVWF  FEE
43B4:  IORLW  00
43B6:  BNZ   43AE
43B8:  MOVLB  3
43BA:  BTFSC  x92.7
43BC:  BSF    FF2.7
.................... 		if (strcmp(ptr, aux2) == 0) { 
43BE:  MOVFF  37F,393
43C2:  MOVFF  37E,392
43C6:  MOVLW  03
43C8:  MOVWF  x95
43CA:  MOVLW  74
43CC:  MOVWF  x94
43CE:  MOVLB  0
43D0:  CALL   3B9C
43D4:  MOVF   01,F
43D6:  BTFSS  FD8.2
43D8:  BRA    44E4
.................... 			//-------------------------------- Procesa Baja de alarma -------------------------------- 
.................... 			ptr = strtok(null, sepCh); 
43DA:  MOVLB  3
43DC:  CLRF   x93
43DE:  CLRF   x92
43E0:  MOVLW  03
43E2:  MOVWF  x95
43E4:  MOVLW  7C
43E6:  MOVWF  x94
43E8:  MOVLB  0
43EA:  CALL   3846
43EE:  MOVFF  02,37F
43F2:  MOVFF  01,37E
.................... 			if (ptr != NULL) typeAlrm = *ptr;		// Tipo alarma 
43F6:  MOVLB  3
43F8:  MOVF   x7E,F
43FA:  BNZ   4400
43FC:  MOVF   x7F,F
43FE:  BZ    440E
4400:  MOVFF  37E,FE9
4404:  MOVFF  37F,FEA
4408:  MOVFF  FEF,387
.................... 			else return TYP_SMS_ERR; 
440C:  BRA    4414
440E:  MOVLW  F0
4410:  MOVWF  01
4412:  BRA    494C
.................... 			// 
.................... 			ptr = strtok(null, sepCh); 
4414:  CLRF   x93
4416:  CLRF   x92
4418:  MOVLW  03
441A:  MOVWF  x95
441C:  MOVLW  7C
441E:  MOVWF  x94
4420:  MOVLB  0
4422:  CALL   3846
4426:  MOVFF  02,37F
442A:  MOVFF  01,37E
.................... 			if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
442E:  MOVLB  3
4430:  MOVF   x7E,F
4432:  BNZ   4438
4434:  MOVF   x7F,F
4436:  BZ    4452
4438:  MOVLW  01
443A:  MOVWF  FEA
443C:  MOVLW  7C
443E:  MOVWF  FE9
4440:  MOVFF  37F,FE2
4444:  MOVFF  37E,FE1
4448:  MOVF   FE7,F
444A:  MOVFF  FE6,FEE
444E:  BNZ   4448
.................... 			else return TYP_SMS_ERR; 
4450:  BRA    4458
4452:  MOVLW  F0
4454:  MOVWF  01
4456:  BRA    494C
.................... 			// 
.................... 			done = 0; 
4458:  CLRF   x89
.................... 			for (i = 0; i < 5; i++){ 
445A:  CLRF   x88
445C:  MOVF   x88,W
445E:  SUBLW  04
4460:  BNC   44D0
.................... 				if (alarm[i].variable == typeAlrm){		// Busca alarma para eliminar 
4462:  MOVF   x88,W
4464:  MULLW  0B
4466:  MOVF   FF3,W
4468:  CLRF   x93
446A:  MOVWF  x92
446C:  MOVLW  01
446E:  ADDWF  x92,W
4470:  MOVWF  01
4472:  MOVLW  00
4474:  ADDWFC x93,W
4476:  MOVWF  03
4478:  MOVF   01,W
447A:  ADDLW  18
447C:  MOVWF  FE9
447E:  MOVLW  03
4480:  ADDWFC 03,W
4482:  MOVWF  FEA
4484:  MOVF   x87,W
4486:  SUBWF  FEF,W
4488:  BNZ   44CC
.................... 					alarm[i].activa 	= 0; 
448A:  MOVF   x88,W
448C:  MULLW  0B
448E:  MOVF   FF3,W
4490:  CLRF   x93
4492:  MOVWF  x92
4494:  MOVLW  18
4496:  ADDWF  x92,W
4498:  MOVWF  FE9
449A:  MOVLW  03
449C:  ADDWFC x93,W
449E:  MOVWF  FEA
44A0:  CLRF   FEF
.................... 					alarm[i].cnValid	= 0; 
44A2:  MOVF   x88,W
44A4:  MULLW  0B
44A6:  MOVF   FF3,W
44A8:  CLRF   x93
44AA:  MOVWF  x92
44AC:  MOVLW  0A
44AE:  ADDWF  x92,W
44B0:  MOVWF  01
44B2:  MOVLW  00
44B4:  ADDWFC x93,W
44B6:  MOVWF  03
44B8:  MOVF   01,W
44BA:  ADDLW  18
44BC:  MOVWF  FE9
44BE:  MOVLW  03
44C0:  ADDWFC 03,W
44C2:  MOVWF  FEA
44C4:  CLRF   FEF
.................... 					done = 1; 
44C6:  MOVLW  01
44C8:  MOVWF  x89
.................... 					break; 
44CA:  BRA    44D0
.................... 				} 
.................... 			} 
44CC:  INCF   x88,F
44CE:  BRA    445C
.................... 			if (done == 0) return TYP_SMS_ERR;		// Si no encuentra alarma sale con error 
44D0:  MOVF   x89,F
44D2:  BNZ   44DA
44D4:  MOVLW  F0
44D6:  MOVWF  01
44D8:  BRA    494C
.................... 			//---------------------------------------------------------------------------------------- 
.................... 			return TYP_SMS_BA; 
44DA:  MOVLW  03
44DC:  MOVWF  01
44DE:  BRA    494C
.................... 		} 
.................... 		else{ 
44E0:  BRA    494C
44E2:  MOVLB  0
.................... 			strcpy(aux2, "CLIMA"); 
44E4:  MOVLW  03
44E6:  MOVWF  FEA
44E8:  MOVLW  74
44EA:  MOVWF  FE9
44EC:  MOVFF  FF2,392
44F0:  BCF    FF2.7
44F2:  MOVLW  00
44F4:  CALL   0170
44F8:  TBLRD*-
44FA:  TBLRD*+
44FC:  MOVF   FF5,W
44FE:  MOVWF  FEE
4500:  IORLW  00
4502:  BNZ   44FA
4504:  MOVLB  3
4506:  BTFSC  x92.7
4508:  BSF    FF2.7
.................... 			if (strcmp(ptr, aux2) == 0) { 
450A:  MOVFF  37F,393
450E:  MOVFF  37E,392
4512:  MOVLW  03
4514:  MOVWF  x95
4516:  MOVLW  74
4518:  MOVWF  x94
451A:  MOVLB  0
451C:  CALL   3B9C
4520:  MOVF   01,F
4522:  BNZ   4574
.................... 				//---------------------------- Procesa Pedido de medicion ---------------------------- 
.................... 				ptr = strtok(null, sepCh); 
4524:  MOVLB  3
4526:  CLRF   x93
4528:  CLRF   x92
452A:  MOVLW  03
452C:  MOVWF  x95
452E:  MOVLW  7C
4530:  MOVWF  x94
4532:  MOVLB  0
4534:  CALL   3846
4538:  MOVFF  02,37F
453C:  MOVFF  01,37E
.................... 				if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4540:  MOVLB  3
4542:  MOVF   x7E,F
4544:  BNZ   454A
4546:  MOVF   x7F,F
4548:  BZ    4564
454A:  MOVLW  01
454C:  MOVWF  FEA
454E:  MOVLW  7C
4550:  MOVWF  FE9
4552:  MOVFF  37F,FE2
4556:  MOVFF  37E,FE1
455A:  MOVF   FE7,F
455C:  MOVFF  FE6,FEE
4560:  BNZ   455A
.................... 				else return TYP_SMS_ERR; 
4562:  BRA    456A
4564:  MOVLW  F0
4566:  MOVWF  01
4568:  BRA    494C
.................... 				//------------------------------------------------------------------------------------ 
.................... 				return TYP_SMS_CON; 
456A:  MOVLW  01
456C:  MOVWF  01
456E:  BRA    494C
.................... 			} 
.................... 			else { 
4570:  BRA    494C
4572:  MOVLB  0
.................... 				strcpy(aux2, "SETRTC"); 
4574:  MOVLW  03
4576:  MOVWF  FEA
4578:  MOVLW  74
457A:  MOVWF  FE9
457C:  MOVFF  FF2,392
4580:  BCF    FF2.7
4582:  MOVLW  00
4584:  CALL   0190
4588:  TBLRD*-
458A:  TBLRD*+
458C:  MOVF   FF5,W
458E:  MOVWF  FEE
4590:  IORLW  00
4592:  BNZ   458A
4594:  MOVLB  3
4596:  BTFSC  x92.7
4598:  BSF    FF2.7
.................... 				if (strcmp(ptr, aux2) == 0){  
459A:  MOVFF  37F,393
459E:  MOVFF  37E,392
45A2:  MOVLW  03
45A4:  MOVWF  x95
45A6:  MOVLW  74
45A8:  MOVWF  x94
45AA:  MOVLB  0
45AC:  CALL   3B9C
45B0:  MOVF   01,F
45B2:  BTFSS  FD8.2
45B4:  BRA    477A
.................... 					//------------------------ Procesa Puesta en hora de RTC ------------------------- 
.................... 					ptr = strtok(NULL, sepCh); 
45B6:  MOVLB  3
45B8:  CLRF   x93
45BA:  CLRF   x92
45BC:  MOVLW  03
45BE:  MOVWF  x95
45C0:  MOVLW  7C
45C2:  MOVWF  x94
45C4:  MOVLB  0
45C6:  CALL   3846
45CA:  MOVFF  02,37F
45CE:  MOVFF  01,37E
.................... 					if (ptr != NULL) hora = atoi(ptr); 
45D2:  MOVLB  3
45D4:  MOVF   x7E,F
45D6:  BNZ   45DC
45D8:  MOVF   x7F,F
45DA:  BZ    45F2
45DC:  MOVFF  37F,3FE
45E0:  MOVFF  37E,3FD
45E4:  MOVLB  0
45E6:  CALL   0ADC
45EA:  MOVFF  01,382
.................... 					else return TYP_SMS_ERR; 
45EE:  BRA    45F8
45F0:  MOVLB  3
45F2:  MOVLW  F0
45F4:  MOVWF  01
45F6:  BRA    494C
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
45F8:  MOVLB  3
45FA:  CLRF   x93
45FC:  CLRF   x92
45FE:  MOVLW  03
4600:  MOVWF  x95
4602:  MOVLW  7C
4604:  MOVWF  x94
4606:  MOVLB  0
4608:  CALL   3846
460C:  MOVFF  02,37F
4610:  MOVFF  01,37E
.................... 					if (ptr != NULL) min = atoi(ptr); 
4614:  MOVLB  3
4616:  MOVF   x7E,F
4618:  BNZ   461E
461A:  MOVF   x7F,F
461C:  BZ    4634
461E:  MOVFF  37F,3FE
4622:  MOVFF  37E,3FD
4626:  MOVLB  0
4628:  CALL   0ADC
462C:  MOVFF  01,383
.................... 					else return TYP_SMS_ERR; 
4630:  BRA    463A
4632:  MOVLB  3
4634:  MOVLW  F0
4636:  MOVWF  01
4638:  BRA    494C
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
463A:  MOVLB  3
463C:  CLRF   x93
463E:  CLRF   x92
4640:  MOVLW  03
4642:  MOVWF  x95
4644:  MOVLW  7C
4646:  MOVWF  x94
4648:  MOVLB  0
464A:  CALL   3846
464E:  MOVFF  02,37F
4652:  MOVFF  01,37E
.................... 					if (ptr != NULL) dia = atoi(ptr); 
4656:  MOVLB  3
4658:  MOVF   x7E,F
465A:  BNZ   4660
465C:  MOVF   x7F,F
465E:  BZ    4676
4660:  MOVFF  37F,3FE
4664:  MOVFF  37E,3FD
4668:  MOVLB  0
466A:  CALL   0ADC
466E:  MOVFF  01,384
.................... 					else return TYP_SMS_ERR; 
4672:  BRA    467C
4674:  MOVLB  3
4676:  MOVLW  F0
4678:  MOVWF  01
467A:  BRA    494C
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
467C:  MOVLB  3
467E:  CLRF   x93
4680:  CLRF   x92
4682:  MOVLW  03
4684:  MOVWF  x95
4686:  MOVLW  7C
4688:  MOVWF  x94
468A:  MOVLB  0
468C:  CALL   3846
4690:  MOVFF  02,37F
4694:  MOVFF  01,37E
.................... 					if (ptr != NULL) mes = atoi(ptr); 
4698:  MOVLB  3
469A:  MOVF   x7E,F
469C:  BNZ   46A2
469E:  MOVF   x7F,F
46A0:  BZ    46B8
46A2:  MOVFF  37F,3FE
46A6:  MOVFF  37E,3FD
46AA:  MOVLB  0
46AC:  CALL   0ADC
46B0:  MOVFF  01,385
.................... 					else return TYP_SMS_ERR; 
46B4:  BRA    46BE
46B6:  MOVLB  3
46B8:  MOVLW  F0
46BA:  MOVWF  01
46BC:  BRA    494C
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
46BE:  MOVLB  3
46C0:  CLRF   x93
46C2:  CLRF   x92
46C4:  MOVLW  03
46C6:  MOVWF  x95
46C8:  MOVLW  7C
46CA:  MOVWF  x94
46CC:  MOVLB  0
46CE:  CALL   3846
46D2:  MOVFF  02,37F
46D6:  MOVFF  01,37E
.................... 					if (ptr != NULL) year = atoi(ptr+2); 
46DA:  MOVLB  3
46DC:  MOVF   x7E,F
46DE:  BNZ   46E4
46E0:  MOVF   x7F,F
46E2:  BZ    4704
46E4:  MOVLW  02
46E6:  ADDWF  x7E,W
46E8:  MOVWF  x92
46EA:  MOVLW  00
46EC:  ADDWFC x7F,W
46EE:  MOVWF  x93
46F0:  MOVWF  xFE
46F2:  MOVFF  392,3FD
46F6:  MOVLB  0
46F8:  CALL   0ADC
46FC:  MOVFF  01,386
.................... 					else return TYP_SMS_ERR; 
4700:  BRA    470A
4702:  MOVLB  3
4704:  MOVLW  F0
4706:  MOVWF  01
4708:  BRA    494C
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
470A:  MOVLB  3
470C:  CLRF   x93
470E:  CLRF   x92
4710:  MOVLW  03
4712:  MOVWF  x95
4714:  MOVLW  7C
4716:  MOVWF  x94
4718:  MOVLB  0
471A:  CALL   3846
471E:  MOVFF  02,37F
4722:  MOVFF  01,37E
.................... 					if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4726:  MOVLB  3
4728:  MOVF   x7E,F
472A:  BNZ   4730
472C:  MOVF   x7F,F
472E:  BZ    474A
4730:  MOVLW  01
4732:  MOVWF  FEA
4734:  MOVLW  7C
4736:  MOVWF  FE9
4738:  MOVFF  37F,FE2
473C:  MOVFF  37E,FE1
4740:  MOVF   FE7,F
4742:  MOVFF  FE6,FEE
4746:  BNZ   4740
.................... 					else return TYP_SMS_ERR; 
4748:  BRA    4750
474A:  MOVLW  F0
474C:  MOVWF  01
474E:  BRA    494C
....................  
.................... 					rtc_set_datetime(dia, mes, year, 1, hora, min); 
4750:  MOVFF  384,392
4754:  MOVFF  385,393
4758:  MOVFF  386,394
475C:  MOVLW  01
475E:  MOVWF  x95
4760:  MOVFF  382,396
4764:  MOVFF  383,397
4768:  MOVLB  0
476A:  GOTO   3EAA
....................  
.................... 					return TYP_SMS_RTC; 
476E:  MOVLW  05
4770:  MOVWF  01
4772:  MOVLB  3
4774:  BRA    494C
.................... 				} 
.................... 				else { 
4776:  BRA    494C
4778:  MOVLB  0
.................... 					// 
.................... 					strcpy(aux2, "INITMEM"); 
477A:  MOVLW  03
477C:  MOVWF  FEA
477E:  MOVLW  74
4780:  MOVWF  FE9
4782:  MOVFF  FF2,392
4786:  BCF    FF2.7
4788:  MOVLW  00
478A:  CALL   01B2
478E:  TBLRD*-
4790:  TBLRD*+
4792:  MOVF   FF5,W
4794:  MOVWF  FEE
4796:  IORLW  00
4798:  BNZ   4790
479A:  MOVLB  3
479C:  BTFSC  x92.7
479E:  BSF    FF2.7
.................... 					if (strcmp(ptr, aux2) == 0){  
47A0:  MOVFF  37F,393
47A4:  MOVFF  37E,392
47A8:  MOVLW  03
47AA:  MOVWF  x95
47AC:  MOVLW  74
47AE:  MOVWF  x94
47B0:  MOVLB  0
47B2:  CALL   3B9C
47B6:  MOVF   01,F
47B8:  BNZ   4806
.................... 						inicializa_eeprom(); 						// Inicializa memoria eeprom  
47BA:  GOTO   3F66
.................... 						ptr = strtok(NULL, sepCh); 
47BE:  MOVLB  3
47C0:  CLRF   x93
47C2:  CLRF   x92
47C4:  MOVLW  03
47C6:  MOVWF  x95
47C8:  MOVLW  7C
47CA:  MOVWF  x94
47CC:  MOVLB  0
47CE:  CALL   3846
47D2:  MOVFF  02,37F
47D6:  MOVFF  01,37E
.................... 					    if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
47DA:  MOVLB  3
47DC:  MOVF   x7E,F
47DE:  BNZ   47E4
47E0:  MOVF   x7F,F
47E2:  BZ    47FC
47E4:  MOVLW  01
47E6:  MOVWF  FEA
47E8:  MOVLW  7C
47EA:  MOVWF  FE9
47EC:  MOVFF  37F,FE2
47F0:  MOVFF  37E,FE1
47F4:  MOVF   FE7,F
47F6:  MOVFF  FE6,FEE
47FA:  BNZ   47F4
.................... 						 
.................... 						return TYP_SMS_INI; 
47FC:  MOVLW  04
47FE:  MOVWF  01
4800:  BRA    494C
.................... 					} 
.................... 					else { 
4802:  BRA    494C
4804:  MOVLB  0
.................... 						// 
.................... 						strcpy(aux2, "CNUMSRV"); 
4806:  MOVLW  03
4808:  MOVWF  FEA
480A:  MOVLW  74
480C:  MOVWF  FE9
480E:  MOVFF  FF2,392
4812:  BCF    FF2.7
4814:  MOVLW  00
4816:  CALL   01D4
481A:  TBLRD*-
481C:  TBLRD*+
481E:  MOVF   FF5,W
4820:  MOVWF  FEE
4822:  IORLW  00
4824:  BNZ   481C
4826:  MOVLB  3
4828:  BTFSC  x92.7
482A:  BSF    FF2.7
.................... 						strcpy(telaux, telnum); 
482C:  MOVLW  02
482E:  MOVWF  FEA
4830:  MOVLW  CC
4832:  MOVWF  FE9
4834:  MOVLW  01
4836:  MOVWF  FE2
4838:  MOVLW  48
483A:  MOVWF  FE1
483C:  MOVF   FE7,F
483E:  MOVFF  FE6,FEE
4842:  BNZ   483C
.................... 						if (strcmp(ptr, aux2) == 0){ 
4844:  MOVFF  37F,393
4848:  MOVFF  37E,392
484C:  MOVLW  03
484E:  MOVWF  x95
4850:  MOVLW  74
4852:  MOVWF  x94
4854:  MOVLB  0
4856:  CALL   3B9C
485A:  MOVF   01,F
485C:  BNZ   4908
.................... 							ptr = strtok(NULL, sepCh); 
485E:  MOVLB  3
4860:  CLRF   x93
4862:  CLRF   x92
4864:  MOVLW  03
4866:  MOVWF  x95
4868:  MOVLW  7C
486A:  MOVWF  x94
486C:  MOVLB  0
486E:  CALL   3846
4872:  MOVFF  02,37F
4876:  MOVFF  01,37E
.................... 							if (ptr != NULL) telnumaux = ptr; // Numero recibido 
487A:  MOVLB  3
487C:  MOVF   x7E,F
487E:  BNZ   4884
4880:  MOVF   x7F,F
4882:  BZ    488E
4884:  MOVFF  37F,381
4888:  MOVFF  37E,380
.................... 							else return TYP_SMS_ERR; 
488C:  BRA    4894
488E:  MOVLW  F0
4890:  MOVWF  01
4892:  BRA    494C
.................... 							//Escribir el tel num nuevo 
.................... 							for (i = 0; i < SZ_TELEFONO; i++){ 
4894:  CLRF   x88
4896:  MOVF   x88,W
4898:  SUBLW  0D
489A:  BNC   48A6
.................... 								//TODO write_eeprom(ADDR_TELEF1+i,*telnumaux); 
.................... 								 telnumaux++; 
489C:  INCF   x80,F
489E:  BTFSC  FD8.2
48A0:  INCF   x81,F
.................... 							} 
48A2:  INCF   x88,F
48A4:  BRA    4896
.................... 							//Leeer el num de tel nuevo 
.................... 							for (i = 0; i < SZ_TELEFONO; i++){ 
48A6:  CLRF   x88
48A8:  MOVF   x88,W
48AA:  SUBLW  0D
48AC:  BNC   48C2
.................... 								telnum[i] = '\0'; 
48AE:  CLRF   03
48B0:  MOVF   x88,W
48B2:  ADDLW  48
48B4:  MOVWF  FE9
48B6:  MOVLW  01
48B8:  ADDWFC 03,W
48BA:  MOVWF  FEA
48BC:  CLRF   FEF
.................... 							//TODO	telnum[i] = read_eeprom(ADDR_TELEF1+i); 
.................... 							} 
48BE:  INCF   x88,F
48C0:  BRA    48A8
.................... 							ptr = strtok(NULL, sepCh); 
48C2:  CLRF   x93
48C4:  CLRF   x92
48C6:  MOVLW  03
48C8:  MOVWF  x95
48CA:  MOVLW  7C
48CC:  MOVWF  x94
48CE:  MOVLB  0
48D0:  CALL   3846
48D4:  MOVFF  02,37F
48D8:  MOVFF  01,37E
.................... 							if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
48DC:  MOVLB  3
48DE:  MOVF   x7E,F
48E0:  BNZ   48E6
48E2:  MOVF   x7F,F
48E4:  BZ    48FE
48E6:  MOVLW  01
48E8:  MOVWF  FEA
48EA:  MOVLW  7C
48EC:  MOVWF  FE9
48EE:  MOVFF  37F,FE2
48F2:  MOVFF  37E,FE1
48F6:  MOVF   FE7,F
48F8:  MOVFF  FE6,FEE
48FC:  BNZ   48F6
.................... 							return TYP_SMS_CSERV; 
48FE:  MOVLW  06
4900:  MOVWF  01
4902:  BRA    494C
.................... 						}else{  
4904:  BRA    494C
4906:  MOVLB  0
.................... 							ptr = strtok(NULL, sepCh); 
4908:  MOVLB  3
490A:  CLRF   x93
490C:  CLRF   x92
490E:  MOVLW  03
4910:  MOVWF  x95
4912:  MOVLW  7C
4914:  MOVWF  x94
4916:  MOVLB  0
4918:  CALL   3846
491C:  MOVFF  02,37F
4920:  MOVFF  01,37E
.................... 							if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4924:  MOVLB  3
4926:  MOVF   x7E,F
4928:  BNZ   492E
492A:  MOVF   x7F,F
492C:  BZ    4946
492E:  MOVLW  01
4930:  MOVWF  FEA
4932:  MOVLW  7C
4934:  MOVWF  FE9
4936:  MOVFF  37F,FE2
493A:  MOVFF  37E,FE1
493E:  MOVF   FE7,F
4940:  MOVFF  FE6,FEE
4944:  BNZ   493E
.................... 							return TYP_SMS_ERR; 
4946:  MOVLW  F0
4948:  MOVWF  01
494A:  BRA    494C
.................... 						} 
.................... 					}				 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
494C:  MOVLB  0
494E:  GOTO   4E62 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | void GenerateToken(void) 
.................... | Crea el token para enviar por la estacion 
.................... ************************************************************************************************/ 
.................... void GenerateToken(void) 
.................... { 
.................... 	int valTkn; 
.................... 	tokenEma[2] = 0; 
*
0DDA:  MOVLB  1
0DDC:  CLRF   x81
.................... 	valTkn = atoi(tokenEma); 
0DDE:  MOVLW  01
0DE0:  MOVLB  3
0DE2:  MOVWF  xFE
0DE4:  MOVLW  7F
0DE6:  MOVWF  xFD
0DE8:  MOVLB  0
0DEA:  RCALL  0ADC
0DEC:  MOVFF  01,3FC
.................... 	valTkn++; 
0DF0:  MOVLB  3
0DF2:  INCF   xFC,F
.................... 	if (valTkn > 99) valTkn = 0; 
0DF4:  MOVF   xFC,W
0DF6:  SUBLW  63
0DF8:  BTFSS  FD8.0
0DFA:  CLRF   xFC
.................... 	sprintf(tokenEma, "%02d", valTkn); 
0DFC:  MOVLW  01
0DFE:  MOVLB  1
0E00:  MOVWF  x47
0E02:  MOVLW  7F
0E04:  MOVWF  x46
0E06:  MOVFF  3FC,3FD
0E0A:  MOVLW  01
0E0C:  MOVLB  3
0E0E:  MOVWF  xFE
0E10:  MOVLB  0
0E12:  RCALL  0CE0
.................... } 
0E14:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------- 
.................... // 
.................... //------------------------------ Comienzo del programa principal -------------------------------- 
.................... // 
.................... //----------------------------------------------------------------------------------------------- 
.................... void main() 
.................... { 
*
4A06:  CLRF   FF8
4A08:  BCF    FD0.7
4A0A:  BSF    07.7
4A0C:  CLRF   FEA
4A0E:  CLRF   FE9
4A10:  BCF    FB8.3
4A12:  MOVLW  0C
4A14:  MOVWF  FAF
4A16:  MOVLW  A2
4A18:  MOVWF  FAC
4A1A:  MOVLW  90
4A1C:  MOVWF  FAB
4A1E:  MOVLB  1
4A20:  CLRF   x17
4A22:  MOVF   FC1,W
4A24:  ANDLW  C0
4A26:  IORLW  0F
4A28:  MOVWF  FC1
4A2A:  MOVLW  07
4A2C:  MOVWF  FB4
4A2E:  CLRF   16
4A30:  CLRF   x1A
4A32:  CLRF   x1B
4A34:  MOVLW  4F
4A36:  MOVWF  x20
4A38:  MOVLW  4B
4A3A:  MOVWF  x21
4A3C:  CLRF   x22
4A3E:  MOVLW  52
4A40:  MOVWF  x23
4A42:  MOVLW  44
4A44:  MOVWF  x24
4A46:  MOVLW  59
4A48:  MOVWF  x25
4A4A:  CLRF   x26
4A4C:  MOVLW  55
4A4E:  MOVWF  x27
4A50:  MOVLW  4E
4A52:  MOVWF  x28
4A54:  MOVLW  52
4A56:  MOVWF  x29
4A58:  MOVLW  45
4A5A:  MOVWF  x2A
4A5C:  MOVLW  41
4A5E:  MOVWF  x2B
4A60:  MOVLW  44
4A62:  MOVWF  x2C
4A64:  CLRF   x2D
4A66:  MOVLW  3E
4A68:  MOVWF  x2E
4A6A:  CLRF   x2F
4A6C:  CLRF   x46
4A6E:  CLRF   x47
4A70:  MOVLW  2B
4A72:  MOVWF  x48
4A74:  MOVLW  35
4A76:  MOVWF  x49
4A78:  MOVLW  34
4A7A:  MOVWF  x4A
4A7C:  MOVLW  39
4A7E:  MOVWF  x4B
4A80:  MOVLW  33
4A82:  MOVWF  x4C
4A84:  MOVLW  34
4A86:  MOVWF  x4D
4A88:  MOVLW  31
4A8A:  MOVWF  x4E
4A8C:  MOVLW  36
4A8E:  MOVWF  x4F
4A90:  MOVLW  35
4A92:  MOVWF  x50
4A94:  MOVLW  32
4A96:  MOVWF  x51
4A98:  MOVLW  37
4A9A:  MOVWF  x52
4A9C:  MOVLW  31
4A9E:  MOVWF  x53
4AA0:  MOVLW  30
4AA2:  MOVWF  x54
4AA4:  MOVLW  35
4AA6:  MOVWF  x55
4AA8:  CLRF   x56
4AAA:  MOVLW  2A
4AAC:  MOVWF  x57
4AAE:  CLRF   x58
.................... 	int i; 
.................... 	// Desactivamos las interrupciones. 
.................... 	disable_interrupts(GLOBAL); 
4AB0:  BCF    FF2.6
4AB2:  BCF    FF2.7
4AB4:  BTFSC  FF2.7
4AB6:  BRA    4AB2
.................... 	disable_interrupts(INT_rda); 
4AB8:  BCF    F9D.5
.................... 	disable_interrupts(INT_EXT2); 
4ABA:  BCF    FF0.4
.................... 	//------------------------ Inicializar puertos -------------------	 
.................... 	set_tris_a(KIOPTOA); 
4ABC:  MOVLW  F3
4ABE:  MOVWF  F92
....................     set_tris_b(KIOPTOB); 
4AC0:  MOVLW  F7
4AC2:  MOVWF  F93
....................     set_tris_c(KIOPTOC); 
4AC4:  MOVLW  81
4AC6:  MOVWF  F94
....................  
.................... 	//Habilito el WatchDog 
.................... 	setup_wdt(WDT_ON); 
4AC8:  BSF    FD1.0
.................... 	// Configuramos el oscilador. 
.................... 	setup_oscillator(OSC_NORMAL);     
4ACA:  CLRF   FD3
4ACC:  MOVF   FD3,W
.................... 	port_b_pullups(TRUE); 
4ACE:  BCF    FF1.7
.................... 	// Configuramos el conversor AD. 
.................... 	setup_adc(ADC_CLOCK_INTERNAL);  
4AD0:  MOVF   FC0,W
4AD2:  ANDLW  C0
4AD4:  IORLW  07
4AD6:  MOVWF  FC0
4AD8:  BSF    FC0.7
4ADA:  BSF    FC2.0
.................... 	//setup_adc_ports(AN0_TO_AN1|VSS_VDD);      
....................     setup_adc_ports(AN0);  
4ADC:  MOVF   FC1,W
4ADE:  ANDLW  C0
4AE0:  IORLW  0E
4AE2:  MOVWF  FC1
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32);        //1.0 s overflow 
4AE4:  MOVLW  84
4AE6:  MOVWF  FD5
....................     setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
4AE8:  CLRF   FB1
....................     // 
.................... 	if (input(INP_PREC) == 0){   		// Estado inicial 
4AEA:  BTFSC  F81.0
4AEC:  BRA    4AF4
....................    		ext_int_edge(2, L_TO_H);  	// Configuro flanco de subida 
4AEE:  BSF    FF1.4
....................   		flagInt2Edge = 0;    		// Indico que el siguiente flanco será de Subida 
4AF0:  BCF    x59.0
....................  	}  
.................... 	else {    
4AF2:  BRA    4AF8
.................... 		ext_int_edge(2, H_TO_L);  	// Configuro flanco de Bajada 
4AF4:  BCF    FF1.4
....................   		flagInt2Edge = 1;    		// Indico que el siguiente flanco será de Bajada 
4AF6:  BSF    x59.0
....................  	}	 
....................  
.................... 	//----------------------- Inicializar variables ------------------ 
.................... 	runOk 		= 1; 
4AF8:  MOVLW  01
4AFA:  MOVWF  x6E
.................... 	guia        = 1; 
4AFC:  MOVWF  x30
.................... 	address 	= 0; 
4AFE:  MOVLB  2
4B00:  CLRF   xE5
4B02:  CLRF   xE4
.................... 	data 		= 0b10101010; 
4B04:  MOVLW  AA
4B06:  MOVWF  xE8
.................... 	temp		= 0; 
4B08:  CLRF   xE9
.................... 	adc_val 	= 0; 
4B0A:  MOVLB  1
4B0C:  CLRF   x5B
4B0E:  CLRF   x5A
.................... 	secUltMed   = 0; 
4B10:  CLRF   x7A
4B12:  CLRF   x79
4B14:  CLRF   x78
4B16:  CLRF   x77
.................... 	//TODO sensorHab 	= read_eeprom(ADDR_HAB_L);  
.................... 	//TODO timeMed 	= read_eeprom(ADDR_TMED_L) + (read_eeprom(ADDR_TMED_H) * 256); 
.................... 	timeMedTmp 	= timeMed; 
4B18:  MOVFF  15F,161
4B1C:  MOVFF  15E,160
.................... 	//TODO timeChk		= read_eeprom(ADDR_TCHK_L) + (read_eeprom(ADDR_TCHK_H) * 256); 
.................... 	timeChkTmp  = timeChk; 
4B20:  MOVFF  167,165
4B24:  MOVFF  166,164
.................... 	ctePluv 	= KTE_PLUV; 	//ctePluv		= read_eeprom(ADDR_KPLUV_L) + (read_eeprom(ADDR_KPLUV_H) * 256); 
4B28:  MOVLW  AE
4B2A:  MOVWF  x6D
4B2C:  MOVLW  47
4B2E:  MOVWF  x6C
4B30:  MOVLW  61
4B32:  MOVWF  x6B
4B34:  MOVLW  7D
4B36:  MOVWF  x6A
.................... 	timeRestart = K_TIME_RESTART; 
4B38:  MOVLW  17
4B3A:  MOVWF  x69
4B3C:  MOVLW  70
4B3E:  MOVWF  x68
.................... 	 
.................... 	//Escribir el telnum por defecto en la eeprom 
.................... 	for (i = 0; i < SZ_TELEFONO; i++){ 
4B40:  MOVLB  3
4B42:  CLRF   x4F
4B44:  MOVF   x4F,W
4B46:  SUBLW  0D
4B48:  BNC   4B4E
.................... 		 //TODO write_eeprom(ADDR_TELEF1+i, telnum[i]); 
.................... 	} 
4B4A:  INCF   x4F,F
4B4C:  BRA    4B44
.................... 							 
.................... 	contData	= 0; 
4B4E:  MOVLB  2
4B50:  CLRF   xE7
4B52:  CLRF   xE6
.................... 	ReadAlarmStruct();					// Lee alarmas guardadas en eeprom interna 
4B54:  MOVLB  0
4B56:  GOTO   0414
.................... 	//----------------------- Flags --------------------------------- 
.................... 	flagInt2Edge 	= 0;				// Indica flanco pluviometro 
4B5A:  MOVLB  1
4B5C:  BCF    x59.0
.................... 	memoryFull      = 0;                // Indica cuando no hay mas memoria 
4B5E:  CLRF   x71
.................... 	startMeasure 	= 0;				// Indica tiempo de iniciar mediciones 
4B60:  CLRF   x73
.................... 	startCheck	 	= 0;				// Indica tiempo de iniciar chequeo interno 
4B62:  CLRF   x74
....................  	startRestart 	= 0;				// Indica tiempo de iniciar reinicio de modem 
4B64:  CLRF   x75
.................... 	countPrec 		= 0;				// Contador de precipitaciones 
4B66:  CLRF   x5D
4B68:  CLRF   x5C
.................... 	smsMemSnd		= 0;				// Indica mensaje de memoria llena enviado 
4B6A:  CLRF   x72
.................... 	llueveAhora     = 0; 		//Indica si esta lloviendo en este momento 
4B6C:  CLRF   x76
.................... 	//---------------------------------------------------------------- 
.................... 	//------------------------ Habilitar Interrupciones -------------- 
.................... 	enable_interrupts(INT_TIMER0); 
4B6E:  BSF    FF2.5
....................    	enable_interrupts(INT_EXT2); 
4B70:  BSF    FF0.4
....................     enable_interrupts(INT_RDA); 
4B72:  BSF    F9D.5
.................... 	clear_interrupt(INT_TIMER0); 
4B74:  BCF    FF2.2
.................... 	clear_interrupt(INT_EXT2); 
4B76:  BCF    FF0.1
.................... 	clear_interrupt(INT_RDA); 
....................     enable_interrupts(GLOBAL); 
4B78:  MOVLW  C0
4B7A:  IORWF  FF2,F
.................... 	//------------------------ Inicializar dispositivos -------------- 
....................     rtc_init(); 
4B7C:  MOVLB  0
4B7E:  GOTO   04CC
....................     sht_init(); 
4B82:  GOTO   05BA
....................     init_ext_eeprom(); 
4B86:  GOTO   05CA
....................     //output_bit(LED1, 1); 
....................     //output_bit(LED2, 1); 
.................... 	delay_ms(500); 
4B8A:  MOVLW  02
4B8C:  MOVLB  3
4B8E:  MOVWF  x54
4B90:  MOVLW  FA
4B92:  MOVWF  x74
4B94:  MOVLB  0
4B96:  CALL   058A
4B9A:  MOVLB  3
4B9C:  DECFSZ x54,F
4B9E:  BRA    4B90
....................     //output_bit(LED1, 0); 
....................     //output_bit(LED2, 0); 
....................     delay_ms(500); 
4BA0:  MOVLW  02
4BA2:  MOVWF  x54
4BA4:  MOVLW  FA
4BA6:  MOVWF  x74
4BA8:  MOVLB  0
4BAA:  CALL   058A
4BAE:  MOVLB  3
4BB0:  DECFSZ x54,F
4BB2:  BRA    4BA4
.................... 	modulo_gsm_init();   		// inicio modem GSM 
4BB4:  MOVLB  0
4BB6:  CALL   0776
....................     delay_ms(90000);            // 90 segundos de yapa 
4BBA:  MOVLW  8B
4BBC:  MOVLB  3
4BBE:  MOVWF  x54
4BC0:  MOVLW  B0
4BC2:  MOVWF  x74
4BC4:  MOVLB  0
4BC6:  CALL   058A
4BCA:  MOVLB  3
4BCC:  DECFSZ x54,F
4BCE:  BRA    4BC0
4BD0:  CLRF   x74
4BD2:  MOVLB  0
4BD4:  CALL   058A
.................... 	//output_bit(LED1, 1); 
.................... 	borrar_sms_inicio(); 
4BD8:  GOTO   0A12
....................     clear_var(smsText);	    	//Inicializo smsText 
4BDC:  MOVLW  01
4BDE:  MOVLB  3
4BE0:  MOVWF  xFD
4BE2:  MOVLW  82
4BE4:  MOVWF  xFC
4BE6:  MOVLB  0
4BE8:  CALL   0A6C
.................... 	reinicioOK(); 
4BEC:  GOTO   13B6
....................  
....................     do{ 
.................... 		restart_wdt(); 
4BF0:  CLRWDT
.................... 		if ((startMeasure) && (!memoryFull)){ 
4BF2:  MOVLB  1
4BF4:  MOVF   x73,F
4BF6:  BZ    4C42
4BF8:  MOVF   x71,F
4BFA:  BNZ   4C42
.................... 			startMeasure = 0; 
4BFC:  CLRF   x73
.................... 			Leer_sensores(1);					// LLena la estructura de medicion con los valores sin convertir 
4BFE:  MOVLW  01
4C00:  MOVLB  3
4C02:  MOVWF  x60
4C04:  MOVLB  0
4C06:  CALL   22E6
.................... 			StoreMed2EEPROM();					// Guarda en memoria los valores medidos junto a la fecha y hora 
4C0A:  GOTO   2850
.................... 			construirTextoSms(smsOut,1); 
4C0E:  MOVLW  02
4C10:  MOVLB  3
4C12:  MOVWF  x55
4C14:  MOVLW  27
4C16:  MOVWF  x54
4C18:  MOVLW  01
4C1A:  MOVWF  x56
4C1C:  MOVLB  0
4C1E:  CALL   2C40
.................... 			idLastSmsOut = EnviarSms(smsOut, telnum);		 
4C22:  MOVLW  02
4C24:  MOVLB  3
4C26:  MOVWF  x61
4C28:  MOVLW  27
4C2A:  MOVWF  x60
4C2C:  MOVLW  01
4C2E:  MOVWF  x63
4C30:  MOVLW  48
4C32:  MOVWF  x62
4C34:  MOVLB  0
4C36:  CALL   131C
4C3A:  MOVFF  01,170
.................... 		} 
.................... 		else{ 
4C3E:  BRA    4D08
4C40:  MOVLB  1
.................... 			if (memoryFull){ 
4C42:  MOVF   x71,F
4C44:  BZ    4D08
.................... 				//Ver accion en caso de memoria llena lo ideal seria un comando de inicializacion 
.................... 				if (smsMemSnd == 0){ 
4C46:  MOVF   x72,F
4C48:  BNZ   4D08
.................... 				    CurrDateTime(); 
4C4A:  MOVLB  0
4C4C:  CALL   1150
.................... 					GenerateToken(); 
4C50:  CALL   0DDA
.................... 					clear_var(smsOut); 
4C54:  MOVLW  02
4C56:  MOVLB  3
4C58:  MOVWF  xFD
4C5A:  MOVLW  27
4C5C:  MOVWF  xFC
4C5E:  MOVLB  0
4C60:  CALL   0A6C
.................... 					sprintf(smsOut, "EST|%s|%s|MEMFULL|%ld|%c%c", dtFecha, dtHora, contData, tokenEma[0], tokenEma[1]); 
4C64:  MOVLW  02
4C66:  MOVLB  1
4C68:  MOVWF  x47
4C6A:  MOVLW  27
4C6C:  MOVWF  x46
4C6E:  MOVLW  A4
4C70:  MOVWF  FF6
4C72:  MOVLW  03
4C74:  MOVWF  FF7
4C76:  MOVLW  04
4C78:  MOVLB  3
4C7A:  MOVWF  x60
4C7C:  MOVLB  0
4C7E:  CALL   12A0
4C82:  MOVLW  01
4C84:  MOVWF  FEA
4C86:  MOVLW  32
4C88:  MOVWF  FE9
4C8A:  CALL   12C8
4C8E:  MOVLW  7C
4C90:  MOVLB  4
4C92:  MOVWF  x0D
4C94:  MOVLB  0
4C96:  CALL   0CBE
4C9A:  MOVLW  01
4C9C:  MOVWF  FEA
4C9E:  MOVLW  3C
4CA0:  MOVWF  FE9
4CA2:  CALL   12C8
4CA6:  MOVLW  AD
4CA8:  MOVWF  FF6
4CAA:  MOVLW  03
4CAC:  MOVWF  FF7
4CAE:  MOVLW  09
4CB0:  MOVLB  3
4CB2:  MOVWF  x60
4CB4:  MOVLB  0
4CB6:  CALL   12A0
4CBA:  MOVLW  10
4CBC:  MOVWF  FE9
4CBE:  MOVFF  2E7,355
4CC2:  MOVFF  2E6,354
4CC6:  GOTO   2F5E
4CCA:  MOVLW  7C
4CCC:  MOVLB  4
4CCE:  MOVWF  x0D
4CD0:  MOVLB  0
4CD2:  CALL   0CBE
4CD6:  MOVFF  17F,40D
4CDA:  CALL   0CBE
4CDE:  MOVFF  180,40D
4CE2:  CALL   0CBE
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
4CE6:  MOVLW  02
4CE8:  MOVLB  3
4CEA:  MOVWF  x61
4CEC:  MOVLW  27
4CEE:  MOVWF  x60
4CF0:  MOVLW  01
4CF2:  MOVWF  x63
4CF4:  MOVLW  48
4CF6:  MOVWF  x62
4CF8:  MOVLB  0
4CFA:  CALL   131C
4CFE:  MOVFF  01,170
.................... 					smsMemSnd = 1; 
4D02:  MOVLW  01
4D04:  MOVLB  1
4D06:  MOVWF  x72
.................... 				} 
.................... 			} 
.................... 		} 
.................... 		if (startCheck){									// Verifica variables por alarmas 
4D08:  MOVLB  1
4D0A:  MOVF   x74,F
4D0C:  BZ    4E04
.................... 			CurrDateTime(); 
4D0E:  MOVLB  0
4D10:  CALL   1150
.................... 			float tempInt; 
.................... 			startCheck = 0; 
4D14:  MOVLB  1
4D16:  CLRF   x74
.................... 			CheckAlarmValues(); 
4D18:  MOVLB  0
4D1A:  GOTO   3056
.................... 			if (tempInt != 0){									// Verifica estado del equipo 
4D1E:  MOVFF  353,37A
4D22:  MOVFF  352,379
4D26:  MOVFF  351,378
4D2A:  MOVFF  350,377
4D2E:  MOVLB  3
4D30:  CLRF   x7E
4D32:  CLRF   x7D
4D34:  CLRF   x7C
4D36:  CLRF   x7B
4D38:  MOVLB  0
4D3A:  CALL   19D0
4D3E:  BZ    4E02
.................... 				GenerateToken(); 
4D40:  CALL   0DDA
.................... 				clear_var(smsOut); 
4D44:  MOVLW  02
4D46:  MOVLB  3
4D48:  MOVWF  xFD
4D4A:  MOVLW  27
4D4C:  MOVWF  xFC
4D4E:  MOVLB  0
4D50:  CALL   0A6C
.................... 				sprintf(smsOut, "EST|%s|%s|TEMP|%02.1f|%c%c", dtFecha, dtHora, tempInt,tokenEma[0], tokenEma[1]); 
4D54:  MOVLW  02
4D56:  MOVLB  1
4D58:  MOVWF  x47
4D5A:  MOVLW  27
4D5C:  MOVWF  x46
4D5E:  MOVLW  C0
4D60:  MOVWF  FF6
4D62:  MOVLW  03
4D64:  MOVWF  FF7
4D66:  MOVLW  04
4D68:  MOVLB  3
4D6A:  MOVWF  x60
4D6C:  MOVLB  0
4D6E:  CALL   12A0
4D72:  MOVLW  01
4D74:  MOVWF  FEA
4D76:  MOVLW  32
4D78:  MOVWF  FE9
4D7A:  CALL   12C8
4D7E:  MOVLW  7C
4D80:  MOVLB  4
4D82:  MOVWF  x0D
4D84:  MOVLB  0
4D86:  CALL   0CBE
4D8A:  MOVLW  01
4D8C:  MOVWF  FEA
4D8E:  MOVLW  3C
4D90:  MOVWF  FE9
4D92:  CALL   12C8
4D96:  MOVLW  C9
4D98:  MOVWF  FF6
4D9A:  MOVLW  03
4D9C:  MOVWF  FF7
4D9E:  MOVLW  06
4DA0:  MOVLB  3
4DA2:  MOVWF  x60
4DA4:  MOVLB  0
4DA6:  CALL   12A0
4DAA:  MOVLW  41
4DAC:  MOVWF  FE9
4DAE:  MOVFF  353,3FF
4DB2:  MOVFF  352,3FE
4DB6:  MOVFF  351,3FD
4DBA:  MOVFF  350,3FC
4DBE:  MOVLW  01
4DC0:  MOVLB  4
4DC2:  MOVWF  x00
4DC4:  MOVLB  0
4DC6:  CALL   29A6
4DCA:  MOVLW  7C
4DCC:  MOVLB  4
4DCE:  MOVWF  x0D
4DD0:  MOVLB  0
4DD2:  CALL   0CBE
4DD6:  MOVFF  17F,40D
4DDA:  CALL   0CBE
4DDE:  MOVFF  180,40D
4DE2:  CALL   0CBE
.................... 				idLastSmsOut = EnviarSms(smsOut, telnum);	// Alarma por temp. gabinete alta o baja 
4DE6:  MOVLW  02
4DE8:  MOVLB  3
4DEA:  MOVWF  x61
4DEC:  MOVLW  27
4DEE:  MOVWF  x60
4DF0:  MOVLW  01
4DF2:  MOVWF  x63
4DF4:  MOVLW  48
4DF6:  MOVWF  x62
4DF8:  MOVLB  0
4DFA:  CALL   131C
4DFE:  MOVFF  01,170
4E02:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 		if (startRestart){ 
4E04:  MOVF   x75,F
4E06:  BZ    4E30
.................... 			modulo_gsm_init();   		// inicio modem GSM 
4E08:  MOVLB  0
4E0A:  CALL   0776
.................... 			delay_ms(90000);            // 90 segundos de yapa 
4E0E:  MOVLW  8B
4E10:  MOVLB  3
4E12:  MOVWF  x54
4E14:  MOVLW  B0
4E16:  MOVWF  x74
4E18:  MOVLB  0
4E1A:  CALL   058A
4E1E:  MOVLB  3
4E20:  DECFSZ x54,F
4E22:  BRA    4E14
4E24:  CLRF   x74
4E26:  MOVLB  0
4E28:  CALL   058A
.................... 			//output_bit(LED1, 1); 
.................... 			startRestart = 0; 
4E2C:  MOVLB  1
4E2E:  CLRF   x75
.................... 		} 
.................... 		currSmsId = LeerSmsCmd(smsText);		// Lee sms y obtiene ID para su proceso posterior (borrado) 
4E30:  MOVLW  01
4E32:  MOVLB  3
4E34:  MOVWF  x55
4E36:  MOVLW  82
4E38:  MOVWF  x54
4E3A:  MOVLB  0
4E3C:  GOTO   3978
4E40:  MOVFF  02,163
4E44:  MOVFF  01,162
.................... 		if (currSmsId){									// Bandera que indica sms recibido 
4E48:  MOVLB  1
4E4A:  MOVF   x62,W
4E4C:  IORWF  x63,W
4E4E:  BTFSC  FD8.2
4E50:  BRA    50CE
.................... 			resProc = ProcessMessage(smsText); 
4E52:  MOVLW  01
4E54:  MOVLB  3
4E56:  MOVWF  x55
4E58:  MOVLW  82
4E5A:  MOVWF  x54
4E5C:  MOVLB  0
4E5E:  GOTO   3FA6
4E62:  MOVFF  01,16F
.................... 			clear_var(smsOut); 
4E66:  MOVLW  02
4E68:  MOVLB  3
4E6A:  MOVWF  xFD
4E6C:  MOVLW  27
4E6E:  MOVWF  xFC
4E70:  MOVLB  0
4E72:  CALL   0A6C
.................... 			switch (resProc){ 
4E76:  MOVLB  1
4E78:  MOVF   x6F,W
4E7A:  XORLW  04
4E7C:  MOVLB  0
4E7E:  BZ    4EA0
4E80:  XORLW  01
4E82:  BZ    4EA0
4E84:  XORLW  07
4E86:  BZ    4F1C
4E88:  XORLW  01
4E8A:  BZ    4F1C
4E8C:  XORLW  05
4E8E:  BTFSC  FD8.2
4E90:  BRA    4F9A
4E92:  XORLW  07
4E94:  BTFSC  FD8.2
4E96:  BRA    5016
4E98:  XORLW  F1
4E9A:  BTFSC  FD8.2
4E9C:  BRA    5050
4E9E:  BRA    5050
.................... 				case TYP_SMS_INI: 
.................... 				case TYP_SMS_RTC: 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
4EA0:  MOVLW  02
4EA2:  MOVLB  1
4EA4:  MOVWF  x47
4EA6:  MOVLW  27
4EA8:  MOVWF  x46
4EAA:  MOVLW  DC
4EAC:  MOVWF  FF6
4EAE:  MOVLW  03
4EB0:  MOVWF  FF7
4EB2:  MOVLW  04
4EB4:  MOVLB  3
4EB6:  MOVWF  x60
4EB8:  MOVLB  0
4EBA:  CALL   12A0
4EBE:  MOVLW  01
4EC0:  MOVLB  3
4EC2:  MOVWF  x54
4EC4:  MOVLW  30
4EC6:  MOVLB  4
4EC8:  MOVWF  x0D
4ECA:  MOVLB  0
4ECC:  CALL   0CBE
4ED0:  MOVLB  3
4ED2:  DECFSZ x54,F
4ED4:  BRA    4EC4
4ED6:  MOVFF  16F,354
4EDA:  MOVLW  03
4EDC:  MOVWF  x55
4EDE:  MOVLB  0
4EE0:  RCALL  4952
4EE2:  MOVLW  7C
4EE4:  MOVLB  4
4EE6:  MOVWF  x0D
4EE8:  MOVLB  0
4EEA:  CALL   0CBE
4EEE:  MOVFF  17C,40D
4EF2:  CALL   0CBE
4EF6:  MOVFF  17D,40D
4EFA:  CALL   0CBE
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
4EFE:  MOVLW  02
4F00:  MOVLB  3
4F02:  MOVWF  x61
4F04:  MOVLW  27
4F06:  MOVWF  x60
4F08:  MOVLW  01
4F0A:  MOVWF  x63
4F0C:  MOVLW  48
4F0E:  MOVWF  x62
4F10:  MOVLB  0
4F12:  CALL   131C
4F16:  MOVFF  01,170
.................... 					break; 
4F1A:  BRA    50CC
.................... 				case TYP_SMS_AA: 
.................... 				case TYP_SMS_BA: 
.................... 					WriteAlarmStruct(); 
4F1C:  BRA    49D8
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
4F1E:  MOVLW  02
4F20:  MOVLB  1
4F22:  MOVWF  x47
4F24:  MOVLW  27
4F26:  MOVWF  x46
4F28:  MOVLW  EA
4F2A:  MOVWF  FF6
4F2C:  MOVLW  03
4F2E:  MOVWF  FF7
4F30:  MOVLW  04
4F32:  MOVLB  3
4F34:  MOVWF  x60
4F36:  MOVLB  0
4F38:  CALL   12A0
4F3C:  MOVLW  01
4F3E:  MOVLB  3
4F40:  MOVWF  x54
4F42:  MOVLW  30
4F44:  MOVLB  4
4F46:  MOVWF  x0D
4F48:  MOVLB  0
4F4A:  CALL   0CBE
4F4E:  MOVLB  3
4F50:  DECFSZ x54,F
4F52:  BRA    4F42
4F54:  MOVFF  16F,354
4F58:  MOVLW  03
4F5A:  MOVWF  x55
4F5C:  MOVLB  0
4F5E:  RCALL  4952
4F60:  MOVLW  7C
4F62:  MOVLB  4
4F64:  MOVWF  x0D
4F66:  MOVLB  0
4F68:  CALL   0CBE
4F6C:  MOVFF  17C,40D
4F70:  CALL   0CBE
4F74:  MOVFF  17D,40D
4F78:  CALL   0CBE
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
4F7C:  MOVLW  02
4F7E:  MOVLB  3
4F80:  MOVWF  x61
4F82:  MOVLW  27
4F84:  MOVWF  x60
4F86:  MOVLW  01
4F88:  MOVWF  x63
4F8A:  MOVLW  48
4F8C:  MOVWF  x62
4F8E:  MOVLB  0
4F90:  CALL   131C
4F94:  MOVFF  01,170
.................... 					break; 
4F98:  BRA    50CC
.................... 				case TYP_SMS_CSERV: 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
4F9A:  MOVLW  02
4F9C:  MOVLB  1
4F9E:  MOVWF  x47
4FA0:  MOVLW  27
4FA2:  MOVWF  x46
4FA4:  MOVLW  F8
4FA6:  MOVWF  FF6
4FA8:  MOVLW  03
4FAA:  MOVWF  FF7
4FAC:  MOVLW  04
4FAE:  MOVLB  3
4FB0:  MOVWF  x60
4FB2:  MOVLB  0
4FB4:  CALL   12A0
4FB8:  MOVLW  01
4FBA:  MOVLB  3
4FBC:  MOVWF  x54
4FBE:  MOVLW  30
4FC0:  MOVLB  4
4FC2:  MOVWF  x0D
4FC4:  MOVLB  0
4FC6:  CALL   0CBE
4FCA:  MOVLB  3
4FCC:  DECFSZ x54,F
4FCE:  BRA    4FBE
4FD0:  MOVFF  16F,354
4FD4:  MOVLW  03
4FD6:  MOVWF  x55
4FD8:  MOVLB  0
4FDA:  RCALL  4952
4FDC:  MOVLW  7C
4FDE:  MOVLB  4
4FE0:  MOVWF  x0D
4FE2:  MOVLB  0
4FE4:  CALL   0CBE
4FE8:  MOVFF  17C,40D
4FEC:  CALL   0CBE
4FF0:  MOVFF  17D,40D
4FF4:  CALL   0CBE
.................... 					idLastSmsOut = EnviarSms(smsOut, telaux); 
4FF8:  MOVLW  02
4FFA:  MOVLB  3
4FFC:  MOVWF  x61
4FFE:  MOVLW  27
5000:  MOVWF  x60
5002:  MOVLW  02
5004:  MOVWF  x63
5006:  MOVLW  CC
5008:  MOVWF  x62
500A:  MOVLB  0
500C:  CALL   131C
5010:  MOVFF  01,170
.................... 					break; 
5014:  BRA    50CC
.................... 				case TYP_SMS_CON:	 
.................... 			        Leer_sensores(0);		//Lee las medidas de este momento 
5016:  MOVLB  3
5018:  CLRF   x60
501A:  MOVLB  0
501C:  CALL   22E6
.................... 					construirTextoSms(smsOut,0); 
5020:  MOVLW  02
5022:  MOVLB  3
5024:  MOVWF  x55
5026:  MOVLW  27
5028:  MOVWF  x54
502A:  CLRF   x56
502C:  MOVLB  0
502E:  CALL   2C40
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
5032:  MOVLW  02
5034:  MOVLB  3
5036:  MOVWF  x61
5038:  MOVLW  27
503A:  MOVWF  x60
503C:  MOVLW  01
503E:  MOVWF  x63
5040:  MOVLW  48
5042:  MOVWF  x62
5044:  MOVLB  0
5046:  CALL   131C
504A:  MOVFF  01,170
.................... 					break; 
504E:  BRA    50CC
.................... 				case TYP_SMS_ERR:	 
.................... 				default:	 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
5050:  MOVLW  02
5052:  MOVLB  1
5054:  MOVWF  x47
5056:  MOVLW  27
5058:  MOVWF  x46
505A:  MOVLW  06
505C:  MOVWF  FF6
505E:  MOVLW  04
5060:  MOVWF  FF7
5062:  MOVLW  04
5064:  MOVLB  3
5066:  MOVWF  x60
5068:  MOVLB  0
506A:  CALL   12A0
506E:  MOVLW  01
5070:  MOVLB  3
5072:  MOVWF  x54
5074:  MOVLW  30
5076:  MOVLB  4
5078:  MOVWF  x0D
507A:  MOVLB  0
507C:  CALL   0CBE
5080:  MOVLB  3
5082:  DECFSZ x54,F
5084:  BRA    5074
5086:  MOVFF  16F,354
508A:  MOVLW  03
508C:  MOVWF  x55
508E:  MOVLB  0
5090:  RCALL  4952
5092:  MOVLW  7C
5094:  MOVLB  4
5096:  MOVWF  x0D
5098:  MOVLB  0
509A:  CALL   0CBE
509E:  MOVFF  17C,40D
50A2:  CALL   0CBE
50A6:  MOVFF  17D,40D
50AA:  CALL   0CBE
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
50AE:  MOVLW  02
50B0:  MOVLB  3
50B2:  MOVWF  x61
50B4:  MOVLW  27
50B6:  MOVWF  x60
50B8:  MOVLW  01
50BA:  MOVWF  x63
50BC:  MOVLW  48
50BE:  MOVWF  x62
50C0:  MOVLB  0
50C2:  CALL   131C
50C6:  MOVFF  01,170
.................... 					break; 
50CA:  BRA    50CC
50CC:  MOVLB  1
.................... 			} 
.................... 		} 
....................     } while(runOk); 
50CE:  MOVF   x6E,F
50D0:  BTFSC  FD8.2
50D2:  BRA    50D8
50D4:  MOVLB  0
50D6:  BRA    4BF0
.................... } 
.................... //--------------------------------- 
50D8:  BRA    50D8

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 8700   PBADEN CCP2C1 LPT1OSC MCLR
   Word  4: 0000   NOSTVREN DEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPB
   Word  6: E00F   NOWRT NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 0F 00 CC 06 DC 05 

F00032: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00042: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00052: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00062: 00 00 00 00 00 00 00 00 
