CCS PCH C Compiler, Version 4.104, 5967               18-jun-13 01:27

               Filename: C:\ETA\fuentes\mainSrc.lst

               ROM used: 21212 bytes (66%)
                         Largest free fragment is 10720
               RAM used: 853 (56%) at main() level
                         1059 (69%) worst case
               Stack:    8 worst case (6 in main + 2 for interrupts)

*
0000:  GOTO   4AFA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   02A6
0054:  BTFSS  FF0.4
0056:  GOTO   0060
005A:  BTFSC  FF0.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   033E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F258.h> 
.................... //////// Standard Header file for the PIC18F258 device //////////////// 
.................... #device PIC18F258 
.................... #list 
....................  
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOLVP                    //No low voltage progming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES PROTECT                  //Code protected from reads 
.................... #FUSES HS			//High speed 
.................... #FUSES WDT128 
.................... #device ICD=TRUE 
.................... #device adc=10 
.................... #define FREQ_OSC 8000000  
.................... #define BAUD_RATE 9600 
.................... #use delay(clock=FREQ_OSC,RESTART_WDT) 
*
05D4:  MOVLW  03
05D6:  MOVWF  FEA
05D8:  MOVLW  74
05DA:  MOVWF  FE9
05DC:  MOVF   FEF,W
05DE:  BZ    0602
05E0:  MOVLW  02
05E2:  MOVWF  01
05E4:  MOVLW  BF
05E6:  MOVWF  00
05E8:  CLRWDT
05EA:  DECFSZ 00,F
05EC:  BRA    05E8
05EE:  DECFSZ 01,F
05F0:  BRA    05E4
05F2:  MOVLW  96
05F4:  MOVWF  00
05F6:  DECFSZ 00,F
05F8:  BRA    05F6
05FA:  BRA    05FC
05FC:  CLRWDT
05FE:  DECFSZ FEF,F
0600:  BRA    05E0
0602:  RETLW  00
.................... //-------------------------------------------- 
.................... // Configuracion del Puerto del GSM 
.................... // Nota:  modificar Pines y baudrate de acuerdo a la config de la placa 
.................... // Importante: ERRORS se utiliza para que la UART del PIC contemple variaciones en el baudrate 
.................... //-------------------------------------------- 
.................... #use rs232(baud=BAUD_RATE, xmit=PIN_C6,rcv=PIN_C7,errors,stream=SIM300)    
*
0326:  BTFSS  F9E.5
0328:  BRA    0326
032A:  MOVFF  FAB,16
032E:  MOVFF  FAE,01
0332:  BTFSS  16.1
0334:  BRA    033A
0336:  BCF    FAB.4
0338:  BSF    FAB.4
033A:  GOTO   0364 (RETURN)
*
1376:  BTFSS  F9E.4
1378:  BRA    1376
137A:  MOVWF  FAD
137C:  GOTO   140E (RETURN)
....................  
.................... //---------------------- IO Pines ---------------------------------------- 
.................... #define KIOPTOA     0b11110011 // E/S puerto A  
.................... #define KIOPTOB     0b11110111  // E/S puerto B 
.................... #define KIOPTOC     0b10000001  // E/S puerto C 
.................... #define LED1        PIN_A3      // Antes PIN_A4 
.................... #define LED2        PIN_A2      //  
....................  
.................... #define RTC_IO   	PIN_C5	// Pin I/O de rtc 
.................... #define RTC_SCLK 	PIN_C4	// Pin Sclk de rtc 
.................... #define RTC_RST  	PIN_C3	// Pin reset de rtc 
.................... // 
.................... #define EEPROM_SDA  PIN_A5  // Pin SDA memoria 
.................... #define EEPROM_SCL  PIN_A4  // Pin SCL memoria 
.................... // 
.................... #define	INP_PREC	PIN_B2	// Entrada pluviometro 
.................... #define	SIM300_PWR	PIN_B3	// Encendido SIM300 
.................... #define MODULO_POW 	PIN_C2	// Encendido Modulo 
.................... // 
.................... #define	TX_BUFFER_SIZE	100 
.................... #define	RX_BUFFER_SIZE	100 
.................... // 
.................... // --------------------- Constantes -------------------------------------- 
.................... // 
.................... #define SZ_SMSTXT       165				// Cantidad de caracteres x SMS  
.................... #define KTEMPX   		0.1091          // Constante para conversor A/D 
.................... #define KTEMPX_QTY		15              // Constante que define la cantidad de medidas a tomar para calcular la presion 
.................... #define KTEMPX_CORR     0               // Constante de correccion de la medida del sensor 
.................... #define KTESHT_QTY		5               // Constante que define la cantidad de medidas a tomar para calcular la humedad y presion 
.................... #define K_TIME_MED		1740			//  Segundos de intervalo entre mediciones 
.................... #define K_TIME_CHK		1500    		// Segundos para control de mediciones internas 
.................... #define K_TIME_RESTART	6000    		// Segundos entre intervalos de reinicio del modem 
.................... #define KTE_PLUV		0.44			// Constante de pluviometro 
.................... #define K_LLUVIA_H		24				// Cantidad de horas para obtener el acumulado de lluvia 
.................... #define KTE_MAXTI		60.0			// Máxima temperatura interna del equipo 
.................... #define KTE_MINTI		0.0				// Mínima temperatura interna del equipo 
.................... #define MAX_CNALARM		3				// Cantidad de mediciones seguidas para activar alarma 
.................... #define HAB_SEN_TI		0x01			// Sensor de temperatura interna habilitado 
.................... #define TEMP_HUM_S		0x02			// Sensor de temperatura y humedad habilitado 
.................... #define RAINFALL_S		0x04			// Sensor de precipitacion habilitado 
.................... #define PREASURE_S		0x08			// Sensor de presion habilitado 
.................... #define HAB_SENS5		0x10			// Reservado 
.................... #define HAB_SENS6		0x20			// Reservado 
.................... #define HAB_SENS7		0x40			// Reservado 
.................... #define HAB_SENS8		0x80			// Reservado 
....................  
.................... // -------------------------- RESPUESTAS---------------------------------- 
.................... #define TYP_SMS_ON		0			// Encendido 
.................... #define TYP_SMS_CON		1			// Consulta de variables actuales 
.................... #define TYP_SMS_AA		2			// Alta de una alarma 
.................... #define TYP_SMS_BA		3			// Baja de una alarma 
.................... #define TYP_SMS_INI		4			// Inicializar eprom 
.................... #define TYP_SMS_RTC		5			// Poner en fecha y hora el rtc 
.................... #define TYP_SMS_CSERV	6			// Cambiar numero de tel a reportar 
.................... #define TYP_SMS_ERR		240			// Error 
....................  
.................... //------------------- EEPROM INTERNA ---------------------------------- 
.................... #define ADDR_HAB_L		0x00			// Inicio memoria sensores habilitados 
.................... #define ADDR_HAB_H		0x01 
.................... #define ADDR_TMED_L		0x02			// Inicio memoria tiempo de medicion programado 
.................... #define ADDR_TMED_H		0x03 
.................... #define ADDR_TCHK_L		0x04			// Inicio memoria tiempo de control interno programado 
.................... #define ADDR_TCHK_H		0x05 
....................  
.................... #define ADDR_TELEF1		0x0A			// Inicio memoria Numero Telefono (20 bytes) 
.................... #define ADDR_TELEF2		0x1E			// Inicio memoria Numero Telefono (20 bytes) 
.................... #define ADDR_ALARM		0x32			// Inicio memoria alarmas 
....................  
.................... #define SZ_TELEFONO		14				// Tamaño del telefono 
.................... 	 
.................... //------------------- UMBRALES INTENSIDAD DE LLUVIA  ------------------------------ 
.................... #define U_DEBIL        		1 
.................... #define U_MOD	       		7.5 
.................... #define U_FUERTE       		15 
.................... #define U_MUYFUERTE    		30 
....................  
.................... #rom 0x0F00000={(HAB_SEN_TI | TEMP_HUM_S | RAINFALL_S | PREASURE_S), K_TIME_MED, K_TIME_CHK} 
.................... #rom (0x0F00000 +ADDR_ALARM) = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //------------------- EEPROM EXTERNA ---------------------------------- 
.................... #define MAX_LOG_CNT		1000			// Maximo nro. de registros 
.................... #define CN_MEMDATA_L	0x0000			// Contador registros 
.................... #define CN_MEMDATA_H	0x0001			// Contador registros 
.................... #define INI_LOG_MEM		0x0002			// Inicio memoria LOG 
.................... #define FIN_LOG_MEM		0xD7A2			// Fin Memoria LOG 
.................... #define INI_AUXEE		0xD7A3			// Inicio auxiliar 
.................... //------------------- Includes ---------------------------------------- 
.................... #include "modemGsm.c" 
.................... void clear_buffer_gsm(void); 
.................... char  *gprs_response(char *s, int16 timeout); 
.................... char  *match_response(char *sms, char *s, int16 timeout); 
.................... void enviar_sms(void); 
.................... void SimPowerOff(void); 
.................... void wait_response_ok(int16 timeout, int times); 
.................... void wait_for_call_ready(void); 
....................  
.................... #define BUFFER_SIZE 255  
.................... volatile int8 buffer[BUFFER_SIZE+1]; 
.................... int8 buf_index = 0;  
....................  
.................... //------------------------------------------------------- 
.................... //       MACROS 
.................... // NOTA : modificar en funcion al diseño de la placa 
.................... //------------------------------------------------------- 
.................... //Power Key 
.................... #define pk_on    output_high (PIN_B3) 
.................... #define pk_off   output_low (PIN_B3) 
.................... #define pk       input(PIN_B3) 
.................... #define fuente_on   output_high (PIN_C2) 
.................... #define fuente_off  output_low (PIN_C2) 
.................... #define fuente      input(PIN_C2) 
....................  
.................... // Punteros. 
.................... char *ptr; 
....................  
....................  
.................... //----------------------------------------------------- 
.................... //            LIBRERIAS 
.................... //----------------------------------------------------- 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
2BAC:  MOVFF  3FF,403
2BB0:  MOVFF  3FE,402
2BB4:  MOVFF  403,03
2BB8:  MOVLB  4
2BBA:  MOVFF  402,FE9
2BBE:  MOVFF  403,FEA
2BC2:  MOVF   FEF,F
2BC4:  BZ    2BD2
2BC6:  INCF   x02,F
2BC8:  BTFSC  FD8.2
2BCA:  INCF   x03,F
2BCC:  MOVLB  0
2BCE:  BRA    2BB4
2BD0:  MOVLB  4
....................    while(*s2 != '\0') 
....................    { 
2BD2:  MOVFF  401,03
2BD6:  MOVFF  400,FE9
2BDA:  MOVFF  401,FEA
2BDE:  MOVF   FEF,F
2BE0:  BZ    2C08
....................       *s = *s2; 
2BE2:  MOVFF  400,FE9
2BE6:  MOVFF  401,FEA
2BEA:  MOVFF  FEF,406
2BEE:  MOVFF  403,FEA
2BF2:  MOVFF  402,FE9
2BF6:  MOVFF  406,FEF
....................       ++s; 
2BFA:  INCF   x02,F
2BFC:  BTFSC  FD8.2
2BFE:  INCF   x03,F
....................       ++s2; 
2C00:  INCF   x00,F
2C02:  BTFSC  FD8.2
2C04:  INCF   x01,F
....................    } 
2C06:  BRA    2BD2
....................  
....................    *s = '\0'; 
2C08:  MOVFF  402,FE9
2C0C:  MOVFF  403,FEA
2C10:  CLRF   FEF
....................    return(s1); 
2C12:  MOVLB  3
2C14:  MOVFF  3FE,01
2C18:  MOVFF  3FF,02
.................... } 
2C1C:  MOVLB  0
2C1E:  RETLW  00
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
3BE4:  MOVLB  3
3BE6:  MOVFF  392,FE9
3BEA:  MOVFF  393,FEA
3BEE:  MOVFF  FEF,396
3BF2:  MOVFF  395,03
3BF6:  MOVFF  394,FE9
3BFA:  MOVFF  395,FEA
3BFE:  MOVF   FEF,W
3C00:  SUBWF  x96,W
3C02:  BNZ   3C2E
....................       if (*s1 == '\0') 
3C04:  MOVFF  393,03
3C08:  MOVFF  392,FE9
3C0C:  MOVFF  03,FEA
3C10:  MOVF   FEF,F
3C12:  BNZ   3C1A
....................          return(0); 
3C14:  MOVLW  00
3C16:  MOVWF  01
3C18:  BRA    3C58
3C1A:  MOVFF  393,03
3C1E:  MOVF   x92,W
3C20:  INCF   x92,F
3C22:  BTFSC  FD8.2
3C24:  INCF   x93,F
3C26:  INCF   x94,F
3C28:  BTFSC  FD8.2
3C2A:  INCF   x95,F
3C2C:  BRA    3BE6
....................    return((*s1 < *s2) ? -1: 1); 
3C2E:  MOVFF  393,03
3C32:  MOVFF  392,FE9
3C36:  MOVFF  393,FEA
3C3A:  MOVFF  FEF,396
3C3E:  MOVFF  395,03
3C42:  MOVFF  394,FE9
3C46:  MOVFF  395,FEA
3C4A:  MOVF   FEF,W
3C4C:  SUBWF  x96,W
3C4E:  BC    3C54
3C50:  MOVLW  FF
3C52:  BRA    3C56
3C54:  MOVLW  01
3C56:  MOVWF  01
.................... } 
3C58:  MOVLB  0
3C5A:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3814:  MOVFF  39B,39F
3818:  MOVFF  39A,39E
381C:  MOVFF  39F,03
3820:  MOVLB  3
3822:  MOVFF  39E,FE9
3826:  MOVFF  39F,FEA
382A:  MOVF   FEF,F
382C:  BZ    3882
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
382E:  MOVFF  39D,3A1
3832:  MOVFF  39C,3A0
3836:  MOVFF  3A1,03
383A:  MOVFF  3A0,FE9
383E:  MOVFF  3A1,FEA
3842:  MOVF   FEF,F
3844:  BZ    3876
....................          if (*sc1 == *sc2) 
3846:  MOVFF  39E,FE9
384A:  MOVFF  39F,FEA
384E:  MOVFF  FEF,3A2
3852:  MOVFF  3A1,03
3856:  MOVFF  3A0,FE9
385A:  MOVFF  3A1,FEA
385E:  MOVF   FEF,W
3860:  SUBWF  xA2,W
3862:  BNZ   386E
....................             return(sc1); 
3864:  MOVFF  39E,01
3868:  MOVFF  39F,02
386C:  BRA    3888
386E:  INCF   xA0,F
3870:  BTFSC  FD8.2
3872:  INCF   xA1,F
3874:  BRA    3836
3876:  INCF   x9E,F
3878:  BTFSC  FD8.2
387A:  INCF   x9F,F
387C:  MOVLB  0
387E:  BRA    381C
3880:  MOVLB  3
....................    return(0); 
3882:  MOVLW  00
3884:  MOVWF  01
3886:  MOVWF  02
.................... } 
3888:  MOVLB  0
388A:  GOTO   3906 (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
3784:  MOVFF  39B,39F
3788:  MOVFF  39A,39E
378C:  MOVFF  39F,03
3790:  MOVLB  3
3792:  MOVFF  39E,FE9
3796:  MOVFF  39F,FEA
379A:  MOVF   FEF,F
379C:  BZ    37FE
....................       for (sc2 = s2; ; sc2++) 
379E:  MOVFF  39D,3A1
37A2:  MOVFF  39C,3A0
....................     if (*sc2 == '\0') 
37A6:  MOVFF  3A1,03
37AA:  MOVFF  3A0,FE9
37AE:  MOVFF  3A1,FEA
37B2:  MOVF   FEF,F
37B4:  BNZ   37CA
....................        return(sc1 - s1); 
37B6:  MOVF   x9A,W
37B8:  SUBWF  x9E,W
37BA:  MOVWF  00
37BC:  MOVF   x9B,W
37BE:  SUBWFB x9F,W
37C0:  MOVWF  03
37C2:  MOVFF  00,01
37C6:  BRA    380E
....................          else if (*sc1 == *sc2) 
37C8:  BRA    37EA
37CA:  MOVFF  39E,FE9
37CE:  MOVFF  39F,FEA
37D2:  MOVFF  FEF,3A2
37D6:  MOVFF  3A1,03
37DA:  MOVFF  3A0,FE9
37DE:  MOVFF  3A1,FEA
37E2:  MOVF   FEF,W
37E4:  SUBWF  xA2,W
37E6:  BNZ   37EA
....................             break; 
37E8:  BRA    37F2
37EA:  INCF   xA0,F
37EC:  BTFSC  FD8.2
37EE:  INCF   xA1,F
37F0:  BRA    37A6
37F2:  INCF   x9E,F
37F4:  BTFSC  FD8.2
37F6:  INCF   x9F,F
37F8:  MOVLB  0
37FA:  BRA    378C
37FC:  MOVLB  3
....................    return(sc1 - s1); 
37FE:  MOVF   x9A,W
3800:  SUBWF  x9E,W
3802:  MOVWF  00
3804:  MOVF   x9B,W
3806:  SUBWFB x9F,W
3808:  MOVWF  03
380A:  MOVFF  00,01
.................... } 
380E:  MOVLB  0
3810:  GOTO   38C2 (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
*
061C:  MOVFF  36C,03
0620:  MOVLB  3
0622:  MOVFF  36B,FE9
0626:  MOVFF  36C,FEA
062A:  MOVF   FEF,F
062C:  BZ    06A0
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
062E:  MOVFF  36C,370
0632:  MOVFF  36B,36F
0636:  MOVFF  36E,372
063A:  MOVFF  36D,371
063E:  MOVFF  372,03
0642:  MOVFF  371,FE9
0646:  MOVFF  372,FEA
064A:  MOVF   FEF,F
064C:  BZ    067A
064E:  MOVFF  36F,FE9
0652:  MOVFF  370,FEA
0656:  MOVFF  FEF,373
065A:  MOVFF  372,03
065E:  MOVFF  371,FE9
0662:  MOVFF  372,FEA
0666:  MOVF   FEF,W
0668:  SUBWF  x73,W
066A:  BNZ   067A
066C:  INCF   x6F,F
066E:  BTFSC  FD8.2
0670:  INCF   x70,F
0672:  INCF   x71,F
0674:  BTFSC  FD8.2
0676:  INCF   x72,F
0678:  BRA    063E
....................  
....................       if (*t == '\0') 
067A:  MOVFF  372,03
067E:  MOVFF  371,FE9
0682:  MOVFF  372,FEA
0686:  MOVF   FEF,F
0688:  BNZ   0694
....................          return s1; 
068A:  MOVFF  36B,01
068E:  MOVFF  36C,02
0692:  BRA    06A6
....................       ++s1; 
0694:  INCF   x6B,F
0696:  BTFSC  FD8.2
0698:  INCF   x6C,F
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
069A:  MOVLB  0
069C:  BRA    061C
069E:  MOVLB  3
....................    return 0; 
06A0:  MOVLW  00
06A2:  MOVWF  01
06A4:  MOVWF  02
.................... } 
06A6:  MOVLB  0
06A8:  GOTO   06C0 (RETURN)
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
388E:  MOVLB  3
3890:  MOVF   x92,W
3892:  IORWF  x93,W
3894:  BZ    389E
3896:  MOVFF  393,03
389A:  MOVF   x92,W
389C:  BRA    38A8
389E:  MOVFF  11B,03
38A2:  MOVLB  1
38A4:  MOVF   x1A,W
38A6:  MOVLB  3
38A8:  MOVWF  x96
38AA:  MOVFF  03,397
....................    beg += strspn(beg, s2); 
38AE:  MOVFF  397,39B
38B2:  MOVFF  396,39A
38B6:  MOVFF  395,39D
38BA:  MOVFF  394,39C
38BE:  MOVLB  0
38C0:  BRA    3784
38C2:  MOVF   01,W
38C4:  MOVLB  3
38C6:  ADDWF  x96,F
38C8:  MOVLW  00
38CA:  ADDWFC x97,F
....................    if (*beg == '\0') 
38CC:  MOVFF  397,03
38D0:  MOVFF  396,FE9
38D4:  MOVFF  397,FEA
38D8:  MOVF   FEF,F
38DA:  BNZ   38F2
....................    { 
....................       *save = ' '; 
38DC:  MOVLB  1
38DE:  MOVFF  11A,FE9
38E2:  MOVFF  11B,FEA
38E6:  MOVLW  20
38E8:  MOVWF  FEF
....................       return(0); 
38EA:  MOVLW  00
38EC:  MOVWF  01
38EE:  MOVWF  02
38F0:  BRA    3942
....................    } 
....................    end = strpbrk(beg, s2); 
38F2:  MOVFF  397,39B
38F6:  MOVFF  396,39A
38FA:  MOVFF  395,39D
38FE:  MOVFF  394,39C
3902:  MOVLB  0
3904:  BRA    3814
3906:  MOVFF  02,399
390A:  MOVFF  01,398
....................    if (*end != '\0') 
390E:  MOVFF  399,03
3912:  MOVLB  3
3914:  MOVFF  398,FE9
3918:  MOVFF  399,FEA
391C:  MOVF   FEF,F
391E:  BZ    3930
....................    { 
....................       *end = '\0'; 
3920:  MOVFF  398,FE9
3924:  MOVFF  399,FEA
3928:  CLRF   FEF
....................       end++; 
392A:  INCF   x98,F
392C:  BTFSC  FD8.2
392E:  INCF   x99,F
....................    } 
....................    save = end; 
3930:  MOVFF  399,11B
3934:  MOVFF  398,11A
....................    return(beg); 
3938:  MOVFF  396,01
393C:  MOVFF  397,02
3940:  MOVLB  1
.................... } 
3942:  MOVLB  0
3944:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
2C20:  MOVFF  3FF,401
2C24:  MOVFF  3FE,400
2C28:  MOVFF  401,03
2C2C:  MOVLB  4
2C2E:  MOVFF  400,FE9
2C32:  MOVFF  401,FEA
2C36:  MOVF   FEF,F
2C38:  BZ    2C44
2C3A:  INCF   x00,F
2C3C:  BTFSC  FD8.2
2C3E:  INCF   x01,F
2C40:  MOVLB  0
2C42:  BRA    2C28
....................    return(sc - s); 
2C44:  MOVLB  3
2C46:  MOVF   xFE,W
2C48:  MOVLB  4
2C4A:  SUBWF  x00,W
2C4C:  MOVWF  00
2C4E:  MOVLB  3
2C50:  MOVF   xFF,W
2C52:  MOVLB  4
2C54:  SUBWFB x01,W
2C56:  MOVWF  03
2C58:  MOVFF  00,01
.................... } 
2C5C:  MOVLB  0
2C5E:  GOTO   2C6C (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B40:  MOVLB  4
0B42:  CLRF   x02
....................    sign = 0; 
0B44:  CLRF   x00
....................    base = 10; 
0B46:  MOVLW  0A
0B48:  MOVWF  x01
....................    result = 0; 
0B4A:  MOVLB  3
0B4C:  CLRF   xFF
....................  
....................    if (!s) 
0B4E:  MOVF   xFD,W
0B50:  IORWF  xFE,W
0B52:  BNZ   0B5A
....................       return 0; 
0B54:  MOVLW  00
0B56:  MOVWF  01
0B58:  BRA    0D1E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0B5A:  MOVLB  4
0B5C:  MOVF   x02,W
0B5E:  INCF   x02,F
0B60:  CLRF   03
0B62:  MOVLB  3
0B64:  ADDWF  xFD,W
0B66:  MOVWF  FE9
0B68:  MOVF   xFE,W
0B6A:  ADDWFC 03,W
0B6C:  MOVWF  FEA
0B6E:  MOVFF  FEF,403
0B72:  MOVLB  4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B74:  MOVF   x03,W
0B76:  SUBLW  2D
0B78:  BNZ   0B98
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B7A:  MOVLW  01
0B7C:  MOVWF  x00
....................       c = s[index++]; 
0B7E:  MOVF   x02,W
0B80:  INCF   x02,F
0B82:  CLRF   03
0B84:  MOVLB  3
0B86:  ADDWF  xFD,W
0B88:  MOVWF  FE9
0B8A:  MOVF   xFE,W
0B8C:  ADDWFC 03,W
0B8E:  MOVWF  FEA
0B90:  MOVFF  FEF,403
0B94:  MOVLB  4
....................    } 
....................    else if (c == '+') 
0B96:  BRA    0BB6
0B98:  MOVF   x03,W
0B9A:  SUBLW  2B
0B9C:  BNZ   0BB6
....................    { 
....................       c = s[index++]; 
0B9E:  MOVF   x02,W
0BA0:  INCF   x02,F
0BA2:  CLRF   03
0BA4:  MOVLB  3
0BA6:  ADDWF  xFD,W
0BA8:  MOVWF  FE9
0BAA:  MOVF   xFE,W
0BAC:  ADDWFC 03,W
0BAE:  MOVWF  FEA
0BB0:  MOVFF  FEF,403
0BB4:  MOVLB  4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0BB6:  MOVF   x03,W
0BB8:  SUBLW  2F
0BBA:  BTFSC  FD8.0
0BBC:  BRA    0D0A
0BBE:  MOVF   x03,W
0BC0:  SUBLW  39
0BC2:  BTFSS  FD8.0
0BC4:  BRA    0D0A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0BC6:  MOVF   x03,W
0BC8:  SUBLW  30
0BCA:  BNZ   0C20
0BCC:  CLRF   03
0BCE:  MOVF   x02,W
0BD0:  MOVLB  3
0BD2:  ADDWF  xFD,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   xFE,W
0BD8:  ADDWFC 03,W
0BDA:  MOVWF  FEA
0BDC:  MOVF   FEF,W
0BDE:  SUBLW  78
0BE0:  BZ    0C00
0BE2:  CLRF   03
0BE4:  MOVLB  4
0BE6:  MOVF   x02,W
0BE8:  MOVLB  3
0BEA:  ADDWF  xFD,W
0BEC:  MOVWF  FE9
0BEE:  MOVF   xFE,W
0BF0:  ADDWFC 03,W
0BF2:  MOVWF  FEA
0BF4:  MOVF   FEF,W
0BF6:  SUBLW  58
0BF8:  BTFSC  FD8.2
0BFA:  BRA    0C00
0BFC:  MOVLB  4
0BFE:  BRA    0C20
....................       { 
....................          base = 16; 
0C00:  MOVLW  10
0C02:  MOVLB  4
0C04:  MOVWF  x01
....................          index++; 
0C06:  INCF   x02,F
....................          c = s[index++]; 
0C08:  MOVF   x02,W
0C0A:  INCF   x02,F
0C0C:  CLRF   03
0C0E:  MOVLB  3
0C10:  ADDWF  xFD,W
0C12:  MOVWF  FE9
0C14:  MOVF   xFE,W
0C16:  ADDWFC 03,W
0C18:  MOVWF  FEA
0C1A:  MOVFF  FEF,403
0C1E:  MOVLB  4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C20:  MOVF   x01,W
0C22:  SUBLW  0A
0C24:  BNZ   0C68
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0C26:  MOVF   x03,W
0C28:  SUBLW  2F
0C2A:  BC    0C66
0C2C:  MOVF   x03,W
0C2E:  SUBLW  39
0C30:  BNC   0C66
....................             result = 10*result + (c - '0'); 
0C32:  MOVLW  0A
0C34:  MOVWF  x04
0C36:  MOVFF  3FF,405
0C3A:  MOVLB  0
0C3C:  RCALL  0AF2
0C3E:  MOVLW  30
0C40:  MOVLB  4
0C42:  SUBWF  x03,W
0C44:  ADDWF  01,W
0C46:  MOVLB  3
0C48:  MOVWF  xFF
....................             c = s[index++]; 
0C4A:  MOVLB  4
0C4C:  MOVF   x02,W
0C4E:  INCF   x02,F
0C50:  CLRF   03
0C52:  MOVLB  3
0C54:  ADDWF  xFD,W
0C56:  MOVWF  FE9
0C58:  MOVF   xFE,W
0C5A:  ADDWFC 03,W
0C5C:  MOVWF  FEA
0C5E:  MOVFF  FEF,403
0C62:  MOVLB  4
....................          } 
0C64:  BRA    0C26
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0C66:  BRA    0D0A
0C68:  MOVF   x01,W
0C6A:  SUBLW  10
0C6C:  BNZ   0D0A
....................       { 
....................          c = toupper(c); 
0C6E:  MOVF   x03,W
0C70:  SUBLW  60
0C72:  BC    0C80
0C74:  MOVF   x03,W
0C76:  SUBLW  7A
0C78:  BNC   0C80
0C7A:  MOVF   x03,W
0C7C:  ANDLW  DF
0C7E:  BRA    0C82
0C80:  MOVF   x03,W
0C82:  MOVWF  x03
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
0C84:  MOVF   x03,W
0C86:  SUBLW  2F
0C88:  BC    0C90
0C8A:  MOVF   x03,W
0C8C:  SUBLW  39
0C8E:  BC    0C9C
0C90:  MOVF   x03,W
0C92:  SUBLW  40
0C94:  BC    0D0A
0C96:  MOVF   x03,W
0C98:  SUBLW  46
0C9A:  BNC   0D0A
....................             if (c >= '0' && c <= '9') 
0C9C:  MOVF   x03,W
0C9E:  SUBLW  2F
0CA0:  BC    0CC0
0CA2:  MOVF   x03,W
0CA4:  SUBLW  39
0CA6:  BNC   0CC0
....................                result = (result << 4) + (c - '0'); 
0CA8:  MOVLB  3
0CAA:  SWAPF  xFF,W
0CAC:  MOVLB  4
0CAE:  MOVWF  x04
0CB0:  MOVLW  F0
0CB2:  ANDWF  x04,F
0CB4:  MOVLW  30
0CB6:  SUBWF  x03,W
0CB8:  ADDWF  x04,W
0CBA:  MOVLB  3
0CBC:  MOVWF  xFF
....................             else 
0CBE:  BRA    0CD8
....................                result = (result << 4) + (c - 'A' + 10); 
0CC0:  MOVLB  3
0CC2:  SWAPF  xFF,W
0CC4:  MOVLB  4
0CC6:  MOVWF  x04
0CC8:  MOVLW  F0
0CCA:  ANDWF  x04,F
0CCC:  MOVLW  41
0CCE:  SUBWF  x03,W
0CD0:  ADDLW  0A
0CD2:  ADDWF  x04,W
0CD4:  MOVLB  3
0CD6:  MOVWF  xFF
....................  
....................             c = s[index++]; 
0CD8:  MOVLB  4
0CDA:  MOVF   x02,W
0CDC:  INCF   x02,F
0CDE:  CLRF   03
0CE0:  MOVLB  3
0CE2:  ADDWF  xFD,W
0CE4:  MOVWF  FE9
0CE6:  MOVF   xFE,W
0CE8:  ADDWFC 03,W
0CEA:  MOVWF  FEA
0CEC:  MOVFF  FEF,403
0CF0:  MOVLB  4
....................             c = toupper(c); 
0CF2:  MOVF   x03,W
0CF4:  SUBLW  60
0CF6:  BC    0D04
0CF8:  MOVF   x03,W
0CFA:  SUBLW  7A
0CFC:  BNC   0D04
0CFE:  MOVF   x03,W
0D00:  ANDLW  DF
0D02:  BRA    0D06
0D04:  MOVF   x03,W
0D06:  MOVWF  x03
....................          } 
0D08:  BRA    0C84
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0D0A:  DECFSZ x00,W
0D0C:  BRA    0D18
0D0E:  MOVF   x01,W
0D10:  SUBLW  0A
0D12:  BNZ   0D18
....................        result = -result; 
0D14:  MOVLB  3
0D16:  NEGF   xFF
....................  
....................    return(result); 
0D18:  MOVLB  3
0D1A:  MOVFF  3FF,01
.................... } 
0D1E:  MOVLB  0
0D20:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
3C5C:  MOVLB  3
3C5E:  CLRF   x99
3C60:  CLRF   x98
3C62:  CLRF   x97
3C64:  MOVLW  7F
3C66:  MOVWF  x96
3C68:  CLRF   x9D
3C6A:  CLRF   x9C
3C6C:  CLRF   x9B
3C6E:  CLRF   x9A
3C70:  BSF    x9E.0
3C72:  BCF    x9E.1
3C74:  BCF    x9E.2
3C76:  CLRF   xA0
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
3C78:  MOVF   x92,W
3C7A:  IORWF  x93,W
3C7C:  BNZ   3C88
....................       return 0; 
3C7E:  CLRF   00
3C80:  CLRF   01
3C82:  CLRF   02
3C84:  CLRF   03
3C86:  BRA    3EBC
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
3C88:  MOVF   xA0,W
3C8A:  INCF   xA0,F
3C8C:  CLRF   03
3C8E:  ADDWF  x92,W
3C90:  MOVWF  FE9
3C92:  MOVF   x93,W
3C94:  ADDWFC 03,W
3C96:  MOVWF  FEA
3C98:  MOVFF  FEF,39F
3C9C:  MOVF   x9F,F
3C9E:  BTFSC  FD8.2
3CA0:  BRA    3E3E
....................    { 
....................       if (skip && !isspace(c)) 
3CA2:  BTFSS  x9E.0
3CA4:  BRA    3CC4
3CA6:  MOVF   x9F,W
3CA8:  SUBLW  20
3CAA:  BZ    3CC4
....................       { 
....................          skip = 0; 
3CAC:  BCF    x9E.0
....................          if (c == '+') 
3CAE:  MOVF   x9F,W
3CB0:  SUBLW  2B
3CB2:  BNZ   3CBA
....................          { 
....................             sign = 0; 
3CB4:  BCF    x9E.1
....................             continue; 
3CB6:  BRA    3E24
....................          }             
....................          else if (c == '-') 
3CB8:  BRA    3CC4
3CBA:  MOVF   x9F,W
3CBC:  SUBLW  2D
3CBE:  BNZ   3CC4
....................          { 
....................             sign = 1; 
3CC0:  BSF    x9E.1
....................             continue; 
3CC2:  BRA    3E24
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
3CC4:  BTFSC  x9E.0
3CC6:  BRA    3CD6
3CC8:  MOVF   x9F,W
3CCA:  SUBLW  2E
3CCC:  BNZ   3CD6
3CCE:  BTFSC  x9E.2
3CD0:  BRA    3CD6
....................          point = 1; 
3CD2:  BSF    x9E.2
....................       else if (!skip && isdigit(c)) 
3CD4:  BRA    3E24
3CD6:  BTFSC  x9E.0
3CD8:  BRA    3E1E
3CDA:  MOVF   x9F,W
3CDC:  SUBLW  2F
3CDE:  BTFSC  FD8.0
3CE0:  BRA    3E1E
3CE2:  MOVF   x9F,W
3CE4:  SUBLW  39
3CE6:  BTFSS  FD8.0
3CE8:  BRA    3E1E
....................       { 
....................          c -= '0'; 
3CEA:  MOVLW  30
3CEC:  SUBWF  x9F,F
....................          if (point) 
3CEE:  BTFSS  x9E.2
3CF0:  BRA    3DA2
....................          { 
....................             pow10 = pow10 * 10.0; 
3CF2:  MOVFF  399,410
3CF6:  MOVFF  398,40F
3CFA:  MOVFF  397,40E
3CFE:  MOVFF  396,40D
3D02:  MOVLB  4
3D04:  CLRF   x14
3D06:  CLRF   x13
3D08:  MOVLW  20
3D0A:  MOVWF  x12
3D0C:  MOVLW  82
3D0E:  MOVWF  x11
3D10:  MOVLB  0
3D12:  CALL   16CA
3D16:  MOVFF  03,399
3D1A:  MOVFF  02,398
3D1E:  MOVFF  01,397
3D22:  MOVFF  00,396
....................             result += (float)c / pow10;    
3D26:  MOVLB  3
3D28:  CLRF   xA6
3D2A:  MOVFF  39F,3A5
3D2E:  MOVLB  0
3D30:  CALL   1694
3D34:  MOVFF  00,3A1
3D38:  MOVFF  01,3A2
3D3C:  MOVFF  02,3A3
3D40:  MOVFF  03,3A4
3D44:  MOVFF  03,3A8
3D48:  MOVFF  02,3A7
3D4C:  MOVFF  01,3A6
3D50:  MOVFF  00,3A5
3D54:  MOVFF  399,3AC
3D58:  MOVFF  398,3AB
3D5C:  MOVFF  397,3AA
3D60:  MOVFF  396,3A9
3D64:  CALL   203C
3D68:  BCF    FD8.1
3D6A:  MOVFF  39D,3A8
3D6E:  MOVFF  39C,3A7
3D72:  MOVFF  39B,3A6
3D76:  MOVFF  39A,3A5
3D7A:  MOVFF  03,3AC
3D7E:  MOVFF  02,3AB
3D82:  MOVFF  01,3AA
3D86:  MOVFF  00,3A9
3D8A:  CALL   17C0
3D8E:  MOVFF  03,39D
3D92:  MOVFF  02,39C
3D96:  MOVFF  01,39B
3D9A:  MOVFF  00,39A
....................          } 
....................          else 
3D9E:  BRA    3E1A
3DA0:  MOVLB  3
....................          { 
....................             result = 10.0 * result + (float)c; 
3DA2:  MOVLB  4
3DA4:  CLRF   x10
3DA6:  CLRF   x0F
3DA8:  MOVLW  20
3DAA:  MOVWF  x0E
3DAC:  MOVLW  82
3DAE:  MOVWF  x0D
3DB0:  MOVFF  39D,414
3DB4:  MOVFF  39C,413
3DB8:  MOVFF  39B,412
3DBC:  MOVFF  39A,411
3DC0:  MOVLB  0
3DC2:  CALL   16CA
3DC6:  MOVFF  00,3A1
3DCA:  MOVFF  01,3A2
3DCE:  MOVFF  02,3A3
3DD2:  MOVFF  03,3A4
3DD6:  MOVLB  3
3DD8:  CLRF   xA6
3DDA:  MOVFF  39F,3A5
3DDE:  MOVLB  0
3DE0:  CALL   1694
3DE4:  BCF    FD8.1
3DE6:  MOVFF  3A4,3A8
3DEA:  MOVFF  3A3,3A7
3DEE:  MOVFF  3A2,3A6
3DF2:  MOVFF  3A1,3A5
3DF6:  MOVFF  03,3AC
3DFA:  MOVFF  02,3AB
3DFE:  MOVFF  01,3AA
3E02:  MOVFF  00,3A9
3E06:  CALL   17C0
3E0A:  MOVFF  03,39D
3E0E:  MOVFF  02,39C
3E12:  MOVFF  01,39B
3E16:  MOVFF  00,39A
....................          } 
....................       } 
....................       else if (!skip) 
3E1A:  BRA    3E26
3E1C:  MOVLB  3
3E1E:  BTFSC  x9E.0
3E20:  BRA    3E24
....................          break; 
3E22:  BRA    3E3E
3E24:  MOVLB  0
....................    } 
3E26:  MOVLB  3
3E28:  MOVF   xA0,W
3E2A:  INCF   xA0,F
3E2C:  CLRF   03
3E2E:  ADDWF  x92,W
3E30:  MOVWF  FE9
3E32:  MOVF   x93,W
3E34:  ADDWFC 03,W
3E36:  MOVWF  FEA
3E38:  MOVFF  FEF,39F
3E3C:  BRA    3C9C
....................  
....................    if (sign) 
3E3E:  BTFSS  x9E.1
3E40:  BRA    3E78
....................       result = -1*result; 
3E42:  MOVLB  4
3E44:  CLRF   x10
3E46:  CLRF   x0F
3E48:  MOVLW  80
3E4A:  MOVWF  x0E
3E4C:  MOVLW  7F
3E4E:  MOVWF  x0D
3E50:  MOVFF  39D,414
3E54:  MOVFF  39C,413
3E58:  MOVFF  39B,412
3E5C:  MOVFF  39A,411
3E60:  MOVLB  0
3E62:  CALL   16CA
3E66:  MOVFF  03,39D
3E6A:  MOVFF  02,39C
3E6E:  MOVFF  01,39B
3E72:  MOVFF  00,39A
3E76:  MOVLB  3
....................        
....................    if(endptr) 
3E78:  MOVF   x94,W
3E7A:  IORWF  x95,W
3E7C:  BZ    3EAC
....................    { 
....................       if (ptr) { 
3E7E:  MOVF   xA0,F
3E80:  BZ    3E9A
....................          ptr--; 
3E82:  DECF   xA0,F
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
3E84:  MOVFF  394,FE9
3E88:  MOVFF  395,FEA
3E8C:  MOVF   xA0,W
3E8E:  ADDWF  x92,W
3E90:  MOVWF  FEF
3E92:  MOVLW  00
3E94:  ADDWFC x93,W
3E96:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
3E98:  BRA    3EAC
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
3E9A:  MOVFF  394,FE9
3E9E:  MOVFF  395,FEA
3EA2:  MOVFF  393,FEC
3EA6:  MOVF   FED,F
3EA8:  MOVFF  392,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
3EAC:  MOVFF  39A,00
3EB0:  MOVFF  39B,01
3EB4:  MOVFF  39C,02
3EB8:  MOVFF  39D,03
.................... } 
3EBC:  MOVLB  0
3EBE:  RETLW  00
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1() { 
....................    char digit; 
....................  
....................    digit = getc(); 
....................  
....................    putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... #if !defined(__PCD__) 
.................... signed int8 get_int() { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int16 get_int() { 
....................   char s[5]; 
....................   signed int16 i; 
....................  
....................   get_string(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... signed int16 get_long() { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int32 get_long() { 
....................   char s[7]; 
....................   signed int32 l; 
....................  
....................   get_string(s, 10); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //-------------------------------------------------------------------------- 
.................... //  D E F I N I C I O N     D E  VARIABLES PARA MODULO GSM 
.................... //-------------------------------------------------------------------------- 
....................  
.................... char ok[] = "OK"; 
.................... char rd[] = "RDY"; 
.................... char sms_noleido[] = { "UNREAD" }; 
.................... char caracter[] = { ">" }; // caracter que me indica iniciar mensaje de texto 
....................  
.................... //int suspender; 
.................... int guia; 
.................... int done; 
....................  
.................... //#define telefono1 "+543415460866"   // OJO!! declarar tal cual esta, Numero de Telefono del SMS server 
....................  
.................... //------------------------------------------------------- 
.................... //  Funcion Delay 1 seg 
.................... //------------------------------------------------------- 
....................  
.................... #inline  
.................... void delay_sec (void)  
.................... {  
....................    delay_ms(1000);  
.................... }  
....................  
....................  
.................... /*---------------------------------------------------------------------- 
.................... | Funcion para apagar el modem 
.................... ----------------------------------------------------------------------*/ 
.................... void SimPowerOff(void) 
.................... { 
.................... 	output_bit(SIM300_PWR, 0); 
.................... 	delay_ms(1500); 
.................... 	output_bit(SIM300_PWR, 1); 
.................... } 
....................  
.................... //-------------------------------------------------------- 
.................... // INICIALIZACION DEL MODULO GSM 
.................... //-------------------------------------------------------- 
.................... int modulo_gsm_init(void){ 
.................... 	//Inicio del modem segun DATASHEET SIMCOM  
.................... 	fuente_off;         // Apagamos la fuente del SIM300. 
*
07C0:  BCF    F94.2
07C2:  BCF    F8B.2
.................... 	pk_off;       		// PRWKEY=0; 
07C4:  BCF    F93.3
07C6:  BCF    F8A.3
.................... 	delay_ms(2000);		// Eperamos 2 seg 
07C8:  MOVLW  08
07CA:  MOVLB  3
07CC:  MOVWF  x54
07CE:  MOVLW  FA
07D0:  MOVWF  x74
07D2:  MOVLB  0
07D4:  RCALL  05D4
07D6:  MOVLB  3
07D8:  DECFSZ x54,F
07DA:  BRA    07CE
.................... 	fuente_on;			// Encendemos la fuente del SIM300. 
07DC:  BCF    F94.2
07DE:  BSF    F8B.2
.................... 	delay_ms(1000);      // Esperamos 1 seg 
07E0:  MOVLW  04
07E2:  MOVWF  x54
07E4:  MOVLW  FA
07E6:  MOVWF  x74
07E8:  MOVLB  0
07EA:  RCALL  05D4
07EC:  MOVLB  3
07EE:  DECFSZ x54,F
07F0:  BRA    07E4
.................... 	pk_on; 				// PWRKEY=1; 
07F2:  BCF    F93.3
07F4:  BSF    F8A.3
.................... 	delay_ms(1500);		// Esperamos 1-1/2 seg. 
07F6:  MOVLW  06
07F8:  MOVWF  x54
07FA:  MOVLW  FA
07FC:  MOVWF  x74
07FE:  MOVLB  0
0800:  RCALL  05D4
0802:  MOVLB  3
0804:  DECFSZ x54,F
0806:  BRA    07FA
.................... 	pk_off;				// PRWKEY=0; 
0808:  BCF    F93.3
080A:  BCF    F8A.3
.................... 	delay_ms(3000);		// Esperamos 3 seg. 
080C:  MOVLW  0C
080E:  MOVWF  x54
0810:  MOVLW  FA
0812:  MOVWF  x74
0814:  MOVLB  0
0816:  RCALL  05D4
0818:  MOVLB  3
081A:  DECFSZ x54,F
081C:  BRA    0810
.................... 	restart_wdt(); 
081E:  CLRWDT
.................... 	wait_for_call_ready(); 
0820:  MOVLB  0
0822:  BRA    06FE
.................... 	clear_buffer_gsm();  // se borra buffer del modem 
0824:  RCALL  073A
.................... 	fprintf(SIM300,"AT\r"); 
0826:  MOVLW  41
0828:  BTFSS  F9E.4
082A:  BRA    0828
082C:  MOVWF  FAD
082E:  MOVLW  54
0830:  BTFSS  F9E.4
0832:  BRA    0830
0834:  MOVWF  FAD
0836:  MOVLW  0D
0838:  BTFSS  F9E.4
083A:  BRA    0838
083C:  MOVWF  FAD
.................... 				 
.................... 	while(gprs_response(ok,8000)==0) //  Esperando Respuesta del Modulo GSM 
.................... 	{ 
083E:  MOVLW  01
0840:  MOVLB  3
0842:  MOVWF  x66
0844:  MOVLW  20
0846:  MOVWF  x65
0848:  MOVLW  1F
084A:  MOVWF  x68
084C:  MOVLW  40
084E:  MOVWF  x67
0850:  MOVLB  0
0852:  RCALL  06AC
0854:  MOVFF  02,355
0858:  MOVFF  01,354
085C:  MOVLB  3
085E:  MOVF   x54,F
0860:  BNZ   0882
0862:  MOVF   x55,F
0864:  BNZ   0882
.................... 	 fprintf(SIM300,"AT\r"); 
0866:  MOVLW  41
0868:  BTFSS  F9E.4
086A:  BRA    0868
086C:  MOVWF  FAD
086E:  MOVLW  54
0870:  BTFSS  F9E.4
0872:  BRA    0870
0874:  MOVWF  FAD
0876:  MOVLW  0D
0878:  BTFSS  F9E.4
087A:  BRA    0878
087C:  MOVWF  FAD
.................... 	} 
087E:  MOVLB  0
0880:  BRA    083E
....................  
.................... 	 //** ELIMINAR ECO **//    
.................... 	 clear_buffer_gsm();        // se borra buffer del modem 
0882:  MOVLB  0
0884:  RCALL  073A
.................... 	 fprintf(SIM300,"ATE0\r");     // Elimina ECO 
0886:  MOVLW  F6
0888:  MOVWF  FF6
088A:  MOVLW  01
088C:  MOVWF  FF7
088E:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
0890:  MOVLW  07
0892:  MOVLB  3
0894:  MOVWF  x55
0896:  MOVLW  D0
0898:  MOVWF  x54
089A:  MOVLW  05
089C:  MOVWF  x56
089E:  MOVLB  0
08A0:  RCALL  078A
.................... 	 
.................... 	 //** MODO TEXTO **// 
.................... 	 clear_buffer_gsm();            // se borra buffer del modem 
08A2:  RCALL  073A
.................... 	 fprintf(SIM300,"AT+CMGF=1\r");    // Modo Texto 
08A4:  MOVLW  FC
08A6:  MOVWF  FF6
08A8:  MOVLW  01
08AA:  MOVWF  FF7
08AC:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
08AE:  MOVLW  07
08B0:  MOVLB  3
08B2:  MOVWF  x55
08B4:  MOVLW  D0
08B6:  MOVWF  x54
08B8:  MOVLW  05
08BA:  MOVWF  x56
08BC:  MOVLB  0
08BE:  RCALL  078A
.................... 	 
.................... 	 clear_buffer_gsm();         	 // se borra buffer del modem	 
08C0:  RCALL  073A
.................... 	 fprintf(SIM300,"AT+CMEE=2\r");    // Reporte de Errores en Modo Texto  
08C2:  MOVLW  08
08C4:  MOVWF  FF6
08C6:  MOVLW  02
08C8:  MOVWF  FF7
08CA:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
08CC:  MOVLW  07
08CE:  MOVLB  3
08D0:  MOVWF  x55
08D2:  MOVLW  D0
08D4:  MOVWF  x54
08D6:  MOVLW  05
08D8:  MOVWF  x56
08DA:  MOVLB  0
08DC:  RCALL  078A
.................... 	  
.................... 	 clear_buffer_gsm();            // se borra buffer del modem 
08DE:  RCALL  073A
.................... 	 fprintf(SIM300,"AT+CPMS=\"ME\"\r"); // Selecciono la mememoria SIM para recibir y leer SMS. 
08E0:  MOVLW  14
08E2:  MOVWF  FF6
08E4:  MOVLW  02
08E6:  MOVWF  FF7
08E8:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
08EA:  MOVLW  07
08EC:  MOVLB  3
08EE:  MOVWF  x55
08F0:  MOVLW  D0
08F2:  MOVWF  x54
08F4:  MOVLW  05
08F6:  MOVWF  x56
08F8:  MOVLB  0
08FA:  RCALL  078A
....................  
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
08FC:  RCALL  073A
.................... 	 fprintf(SIM300, "AT+CSCS=\"GSM\"\r");	//SMS text mode parameters 
08FE:  MOVLW  22
0900:  MOVWF  FF6
0902:  MOVLW  02
0904:  MOVWF  FF7
0906:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
0908:  MOVLW  07
090A:  MOVLB  3
090C:  MOVWF  x55
090E:  MOVLW  D0
0910:  MOVWF  x54
0912:  MOVLW  05
0914:  MOVWF  x56
0916:  MOVLB  0
0918:  RCALL  078A
.................... 	  
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
091A:  RCALL  073A
.................... 	 fprintf(SIM300, "AT+CSMP=17,167,0,241\r");	//SMS text mode parameters 
091C:  MOVLW  32
091E:  MOVWF  FF6
0920:  MOVLW  02
0922:  MOVWF  FF7
0924:  RCALL  0768
.................... 	 wait_response_ok(2000,5); 
0926:  MOVLW  07
0928:  MOVLB  3
092A:  MOVWF  x55
092C:  MOVLW  D0
092E:  MOVWF  x54
0930:  MOVLW  05
0932:  MOVWF  x56
0934:  MOVLB  0
0936:  RCALL  078A
.................... 	 
.................... 	 clear_buffer_gsm();            			// se borra buffer del modem 
0938:  RCALL  073A
.................... 	return 1; 
093A:  MOVLW  01
093C:  MOVWF  01
.................... } 
093E:  RETLW  00
....................  
....................  
.................... //------------------------------------------------- 
.................... //  BORRA EL BUFFER GSM 
.................... //------------------------------------------------- 
.................... void clear_buffer_gsm(void)  /*borra el buffer gsm */ 
.................... {  
*
073A:  MOVLB  3
073C:  CLRF   x65
....................   int erase=0; 
....................   disable_interrupts(INT_RDA); 
073E:  BCF    F9D.5
....................    
....................   buf_index = 0;  
0740:  MOVLB  1
0742:  CLRF   x17
....................   buffer[0] = 0;  
0744:  CLRF   17
....................   while(erase!=BUFFER_SIZE) { 
0746:  MOVLB  3
0748:  INCFSZ x65,W
074A:  BRA    074E
074C:  BRA    0762
.................... 	buffer[erase] = '\0'; 
074E:  CLRF   03
0750:  MOVF   x65,W
0752:  ADDLW  17
0754:  MOVWF  FE9
0756:  MOVLW  00
0758:  ADDWFC 03,W
075A:  MOVWF  FEA
075C:  CLRF   FEF
.................... 	erase++; 
075E:  INCF   x65,F
....................   } 
0760:  BRA    0748
....................   enable_interrupts(INT_RDA);  
0762:  BSF    F9D.5
.................... }  
0764:  MOVLB  0
0766:  RETLW  00
....................  
.................... //--------------------------------------------------- 
.................... // ESPERA LA RESPUESTA DEL MODULO 
.................... //--------------------------------------------------- 
.................... void wait_response_ok(int16 timeout, int times){ 
*
078A:  MOVFF  356,357
.................... 	char tmOut = times; 
.................... 	do { 
.................... 		tmOut--; 
078E:  MOVLB  3
0790:  DECF   x57,F
.................... 	}while((gprs_response(ok,timeout) == NULL) && (tmOut != 0)); 
0792:  MOVLW  01
0794:  MOVWF  x66
0796:  MOVLW  20
0798:  MOVWF  x65
079A:  MOVFF  355,368
079E:  MOVFF  354,367
07A2:  MOVLB  0
07A4:  RCALL  06AC
07A6:  MOVFF  02,359
07AA:  MOVFF  01,358
07AE:  MOVLB  3
07B0:  MOVF   x58,F
07B2:  BNZ   07BC
07B4:  MOVF   x59,F
07B6:  BNZ   07BC
07B8:  MOVF   x57,F
07BA:  BNZ   0790
.................... } 
07BC:  MOVLB  0
07BE:  RETLW  00
....................  
.................... //------------------------------------------- 
.................... //FUNCION DE DEMORA A LA ESPERA DE OPERADORA 
.................... //------------------------------------------- 
.................... void wait_for_call_ready(void){ 
.................... 	disable_interrupts(INT_RDA); 
*
06FE:  BCF    F9D.5
....................     char tmOut = 10; 
0700:  MOVLW  0A
0702:  MOVLB  3
0704:  MOVWF  x54
.................... 	do { 
.................... 		tmOut--; 
0706:  DECF   x54,F
.................... 	} while((gprs_response(rd,5000) == NULL) && (tmOut != 0)); 
0708:  MOVLW  01
070A:  MOVWF  x66
070C:  MOVLW  23
070E:  MOVWF  x65
0710:  MOVLW  13
0712:  MOVWF  x68
0714:  MOVLW  88
0716:  MOVWF  x67
0718:  MOVLB  0
071A:  RCALL  06AC
071C:  MOVFF  02,356
0720:  MOVFF  01,355
0724:  MOVLB  3
0726:  MOVF   x55,F
0728:  BNZ   0732
072A:  MOVF   x56,F
072C:  BNZ   0732
072E:  MOVF   x54,F
0730:  BNZ   0706
.................... 	enable_interrupts(INT_RDA); 
0732:  BSF    F9D.5
.................... } 
0734:  MOVLB  0
0736:  GOTO   0824 (RETURN)
....................  
.................... //================================================================== 
.................... // funcion de comparacion de contenido buffer GSM 
.................... /* String que estamos buscando */  
.................... /* Tiempo de espera */  
.................... //================================================================== 
.................... char  *gprs_response(char *s, int16 timeout)  
.................... {  
....................   char  *p;  
....................  
....................   while (TRUE)  
....................   {  
....................     p = strstr(buffer, s);  
*
06AC:  MOVLB  3
06AE:  CLRF   x6C
06B0:  MOVLW  17
06B2:  MOVWF  x6B
06B4:  MOVFF  366,36E
06B8:  MOVFF  365,36D
06BC:  MOVLB  0
06BE:  BRA    061C
06C0:  MOVFF  02,36A
06C4:  MOVFF  01,369
....................     if (p)  
06C8:  MOVLB  3
06CA:  MOVF   x69,W
06CC:  IORWF  x6A,W
06CE:  BZ    06DA
....................     {  
....................        return (p); // salida de la funcion 
06D0:  MOVFF  369,01
06D4:  MOVFF  36A,02
06D8:  BRA    06FA
....................     }       
....................     if (timeout)  
06DA:  MOVF   x67,W
06DC:  IORWF  x68,W
06DE:  BZ    06F8
....................     {     
....................       timeout--;  
06E0:  MOVF   x67,W
06E2:  BTFSC  FD8.2
06E4:  DECF   x68,F
06E6:  DECF   x67,F
.................... 	  restart_wdt(); 
06E8:  CLRWDT
....................       if (!timeout)  
06EA:  MOVF   x67,W
06EC:  IORWF  x68,W
06EE:  BNZ   06F8
....................       {  
....................         return (NULL);    // timeout buffer 
06F0:  MOVLW  00
06F2:  MOVWF  01
06F4:  MOVWF  02
06F6:  BRA    06FA
....................       }  
....................     }  
....................   }  
06F8:  BRA    06AE
.................... }   
06FA:  MOVLB  0
06FC:  RETLW  00
....................  
.................... //================================================================== 
.................... // funcion de comparacion de contenido de parametro sms 
.................... /* String que estamos buscando */  
.................... /* Tiempo de espera */  
.................... //================================================================== 
.................... char  *match_response(char *sms, char *s, int16 timeout)  
.................... {  
....................   char  *p;  
....................   while (TRUE)  
....................   {  
....................     p = strstr(sms, s);  
....................     if (p)  
....................     {  
....................        return (p); // salida de la funcion 
....................     }       
....................     if (timeout)  
....................     {     
....................       timeout--;  
....................       if (!timeout)  
....................       {  
....................        return (NULL);    // timeout buffer 
....................      }  
....................     }  
....................   }  
.................... }   
....................  
.................... //================================================================== 
.................... //  BORRAR SMS DEL MODEM 
.................... //================================================================== 
....................  
.................... int borrar_sms(void){ 
....................    int x; 
....................    if (guia == 10){ 
*
3946:  MOVLB  1
3948:  MOVF   x30,W
394A:  SUBLW  0A
394C:  BNZ   39B6
.................... 		   for (x = 1; x <= 10; x++){ 
394E:  MOVLW  01
3950:  MOVLB  3
3952:  MOVWF  x61
3954:  MOVF   x61,W
3956:  SUBLW  0A
3958:  BNC   39A2
.................... 				fprintf(SIM300,"AT+CMGD=%d\r",x); 
395A:  MOVLW  48
395C:  MOVWF  FF6
395E:  MOVLW  02
3960:  MOVWF  FF7
3962:  MOVLW  08
3964:  MOVWF  x65
3966:  MOVLB  0
3968:  CALL   0940
396C:  MOVFF  361,362
3970:  MOVLW  1F
3972:  MOVLB  3
3974:  MOVWF  x63
3976:  MOVLB  0
3978:  CALL   0996
397C:  MOVLW  0D
397E:  BTFSS  F9E.4
3980:  BRA    397E
3982:  MOVWF  FAD
.................... 				gprs_response(ok,1000); 
3984:  MOVLW  01
3986:  MOVLB  3
3988:  MOVWF  x66
398A:  MOVLW  20
398C:  MOVWF  x65
398E:  MOVLW  03
3990:  MOVWF  x68
3992:  MOVLW  E8
3994:  MOVWF  x67
3996:  MOVLB  0
3998:  CALL   06AC
.................... 		   } 
399C:  MOVLB  3
399E:  INCF   x61,F
39A0:  BRA    3954
.................... 		guia=1; 
39A2:  MOVLW  01
39A4:  MOVLB  1
39A6:  MOVWF  x30
.................... 		clear_buffer_gsm(); 
39A8:  MOVLB  0
39AA:  CALL   073A
.................... 		return 1; 
39AE:  MOVLW  01
39B0:  MOVWF  01
39B2:  BRA    39BA
39B4:  MOVLB  1
.................... 	} 
.................... 	return 0; 
39B6:  MOVLW  00
39B8:  MOVWF  01
39BA:  MOVLB  0
.................... } 
39BC:  GOTO   3BA4 (RETURN)
....................  
.................... //================================================================== 
.................... //  BORRAR TODOS LOS SMS  AL INICIO DEL MODEM 
.................... //================================================================== 
....................  
.................... void borrar_sms_inicio(void){ 
....................     int x; 
.................... 	for (x = 1; x <= 50; x++){ 
*
0A76:  MOVLW  01
0A78:  MOVLB  3
0A7A:  MOVWF  x54
0A7C:  MOVF   x54,W
0A7E:  SUBLW  32
0A80:  BNC   0ACA
.................... 		clear_buffer_gsm(); 
0A82:  MOVLB  0
0A84:  RCALL  073A
.................... 		fprintf(SIM300,"AT+CMGD=%d\r",x); 
0A86:  MOVLW  54
0A88:  MOVWF  FF6
0A8A:  MOVLW  02
0A8C:  MOVWF  FF7
0A8E:  MOVLW  08
0A90:  MOVLB  3
0A92:  MOVWF  x65
0A94:  MOVLB  0
0A96:  RCALL  0940
0A98:  MOVFF  354,362
0A9C:  MOVLW  1F
0A9E:  MOVLB  3
0AA0:  MOVWF  x63
0AA2:  MOVLB  0
0AA4:  RCALL  0996
0AA6:  MOVLW  0D
0AA8:  BTFSS  F9E.4
0AAA:  BRA    0AA8
0AAC:  MOVWF  FAD
.................... 		gprs_response(ok,1000); 
0AAE:  MOVLW  01
0AB0:  MOVLB  3
0AB2:  MOVWF  x66
0AB4:  MOVLW  20
0AB6:  MOVWF  x65
0AB8:  MOVLW  03
0ABA:  MOVWF  x68
0ABC:  MOVLW  E8
0ABE:  MOVWF  x67
0AC0:  MOVLB  0
0AC2:  RCALL  06AC
.................... 	} 
0AC4:  MOVLB  3
0AC6:  INCF   x54,F
0AC8:  BRA    0A7C
.................... } 
0ACA:  MOVLB  0
0ACC:  GOTO   4DDE (RETURN)
....................  
....................  
.................... #include <ds1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_B1 
.................... #define RTC_IO   PIN_B3 
.................... #define RTC_RST  PIN_B2 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
048C:  MOVLB  3
048E:  CLRF   x9C
0490:  MOVF   x9C,W
0492:  SUBLW  07
0494:  BNC   04B0
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
0496:  BCF    FD8.0
0498:  RRCF   x9B,F
049A:  BC    04A0
049C:  BCF    F8B.5
049E:  BRA    04A2
04A0:  BSF    F8B.5
04A2:  BCF    F94.5
....................       output_high(RTC_SCLK); 
04A4:  BCF    F94.4
04A6:  BSF    F8B.4
....................       output_low(RTC_SCLK); 
04A8:  BCF    F94.4
04AA:  BCF    F8B.4
....................    } 
04AC:  INCF   x9C,F
04AE:  BRA    0490
.................... } 
04B0:  MOVLB  0
04B2:  RETLW  00
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
04B4:  BCF    F94.3
04B6:  BSF    F8B.3
....................    write_ds1302_byte(cmd); 
04B8:  MOVFF  399,39B
04BC:  RCALL  048C
....................    write_ds1302_byte(data); 
04BE:  MOVFF  39A,39B
04C2:  RCALL  048C
....................    output_low(RTC_RST); 
04C4:  BCF    F94.3
04C6:  BCF    F8B.3
.................... } 
04C8:  RETLW  00
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
04CA:  BCF    F94.3
04CC:  BSF    F8B.3
....................    write_ds1302_byte(cmd); 
04CE:  MOVFF  37E,39B
04D2:  RCALL  048C
....................     
....................    input(RTC_IO); 
04D4:  BSF    F94.5
....................    delay_us(1); 
04D6:  CLRWDT
04D8:  NOP   
....................           
....................    for(i=0;i<=7;++i) { 
04DA:  MOVLB  3
04DC:  CLRF   x7F
04DE:  MOVF   x7F,W
04E0:  SUBLW  07
04E2:  BNC   050A
....................       shift_right(&data,1,input(RTC_IO)); 
04E4:  BSF    F94.5
04E6:  BTFSC  F82.5
04E8:  BRA    04EE
04EA:  BCF    FD8.0
04EC:  BRA    04F0
04EE:  BSF    FD8.0
04F0:  RRCF   x80,F
....................       output_high(RTC_SCLK); 
04F2:  BCF    F94.4
04F4:  BSF    F8B.4
....................       delay_us(2); 
04F6:  CLRWDT
04F8:  BRA    04FA
04FA:  NOP   
....................       output_low(RTC_SCLK); 
04FC:  BCF    F94.4
04FE:  BCF    F8B.4
....................       delay_us(2); 
0500:  CLRWDT
0502:  BRA    0504
0504:  NOP   
....................    } 
0506:  INCF   x7F,F
0508:  BRA    04DE
....................    output_low(RTC_RST); 
050A:  BCF    F94.3
050C:  BCF    F8B.3
....................  
....................    return(data); 
050E:  MOVFF  380,01
.................... } 
0512:  MOVLB  0
0514:  RETLW  00
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
0516:  BCF    F94.3
0518:  BCF    F8B.3
....................    delay_us(2); 
051A:  CLRWDT
051C:  BRA    051E
051E:  NOP   
....................    output_low(RTC_SCLK); 
0520:  BCF    F94.4
0522:  BCF    F8B.4
....................    write_ds1302(0x8e,0); 
0524:  MOVLW  8E
0526:  MOVLB  3
0528:  MOVWF  x99
052A:  CLRF   x9A
052C:  MOVLB  0
052E:  RCALL  04B4
....................    write_ds1302(0x90,0xa4); 
0530:  MOVLW  90
0532:  MOVLB  3
0534:  MOVWF  x99
0536:  MOVLW  A4
0538:  MOVWF  x9A
053A:  MOVLB  0
053C:  RCALL  04B4
....................    x=read_ds1302(0x81); 
053E:  MOVLW  81
0540:  MOVLB  3
0542:  MOVWF  x7E
0544:  MOVLB  0
0546:  RCALL  04CA
0548:  MOVFF  01,354
....................    if((x & 0x80)!=0) 
054C:  MOVLB  3
054E:  MOVF   x54,W
0550:  ANDLW  80
0552:  BZ    0560
....................      write_ds1302(0x80,0); 
0554:  MOVLW  80
0556:  MOVWF  x99
0558:  CLRF   x9A
055A:  MOVLB  0
055C:  RCALL  04B4
055E:  MOVLB  3
.................... } 
0560:  MOVLB  0
0562:  GOTO   4D7A (RETURN)
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
*
3EC0:  MOVFF  398,406
3EC4:  MOVLW  0A
3EC6:  MOVLB  4
3EC8:  MOVWF  x07
3ECA:  MOVLB  0
3ECC:  CALL   096A
3ED0:  MOVFF  01,399
....................    nibl=data-(nibh*10); 
3ED4:  MOVLB  3
3ED6:  MOVF   x99,W
3ED8:  MULLW  0A
3EDA:  MOVF   FF3,W
3EDC:  SUBWF  x98,W
3EDE:  MOVWF  x9A
....................  
....................    return((nibh<<4)|nibl); 
3EE0:  SWAPF  x99,W
3EE2:  MOVWF  00
3EE4:  MOVLW  F0
3EE6:  ANDWF  00,F
3EE8:  MOVF   00,W
3EEA:  IORWF  x9A,W
3EEC:  MOVWF  01
.................... } 
3EEE:  MOVLB  0
3EF0:  RETLW  00
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
0E7A:  MOVFF  37F,380
....................    data=(i>>4)*10; 
0E7E:  MOVLB  3
0E80:  SWAPF  x80,W
0E82:  MOVWF  00
0E84:  MOVLW  0F
0E86:  ANDWF  00,F
0E88:  MOVF   00,W
0E8A:  MULLW  0A
0E8C:  MOVFF  FF3,37F
....................    data=data+(i<<4>>4); 
0E90:  SWAPF  x80,W
0E92:  MOVWF  00
0E94:  MOVLW  F0
0E96:  ANDWF  00,F
0E98:  MOVF   00,W
0E9A:  SWAPF  00,F
0E9C:  MOVLW  0F
0E9E:  ANDWF  00,F
0EA0:  MOVF   00,W
0EA2:  ADDWF  x7F,F
....................  
....................    return data; 
0EA4:  MOVFF  37F,01
.................... } 
0EA8:  MOVLB  0
0EAA:  RETLW  00
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
3EF2:  MOVFF  392,398
3EF6:  RCALL  3EC0
3EF8:  MOVFF  01,398
3EFC:  MOVLW  86
3EFE:  MOVLB  3
3F00:  MOVWF  x99
3F02:  MOVFF  01,39A
3F06:  MOVLB  0
3F08:  CALL   04B4
....................    write_ds1302(0x88,get_bcd(mth)); 
3F0C:  MOVFF  393,398
3F10:  RCALL  3EC0
3F12:  MOVFF  01,398
3F16:  MOVLW  88
3F18:  MOVLB  3
3F1A:  MOVWF  x99
3F1C:  MOVFF  01,39A
3F20:  MOVLB  0
3F22:  CALL   04B4
....................    write_ds1302(0x8c,get_bcd(year)); 
3F26:  MOVFF  394,398
3F2A:  RCALL  3EC0
3F2C:  MOVFF  01,398
3F30:  MOVLW  8C
3F32:  MOVLB  3
3F34:  MOVWF  x99
3F36:  MOVFF  01,39A
3F3A:  MOVLB  0
3F3C:  CALL   04B4
....................    write_ds1302(0x8a,get_bcd(dow)); 
3F40:  MOVFF  395,398
3F44:  RCALL  3EC0
3F46:  MOVFF  01,398
3F4A:  MOVLW  8A
3F4C:  MOVLB  3
3F4E:  MOVWF  x99
3F50:  MOVFF  01,39A
3F54:  MOVLB  0
3F56:  CALL   04B4
....................    write_ds1302(0x84,get_bcd(hr)); 
3F5A:  MOVFF  396,398
3F5E:  RCALL  3EC0
3F60:  MOVFF  01,398
3F64:  MOVLW  84
3F66:  MOVLB  3
3F68:  MOVWF  x99
3F6A:  MOVFF  01,39A
3F6E:  MOVLB  0
3F70:  CALL   04B4
....................    write_ds1302(0x82,get_bcd(min)); 
3F74:  MOVFF  397,398
3F78:  RCALL  3EC0
3F7A:  MOVFF  01,398
3F7E:  MOVLW  82
3F80:  MOVLB  3
3F82:  MOVWF  x99
3F84:  MOVFF  01,39A
3F88:  MOVLB  0
3F8A:  CALL   04B4
....................    write_ds1302(0x80,get_bcd(0)); 
3F8E:  MOVLB  3
3F90:  CLRF   x98
3F92:  MOVLB  0
3F94:  RCALL  3EC0
3F96:  MOVFF  01,398
3F9A:  MOVLW  80
3F9C:  MOVLB  3
3F9E:  MOVWF  x99
3FA0:  MOVFF  01,39A
3FA4:  MOVLB  0
3FA6:  CALL   04B4
.................... } 
3FAA:  GOTO   47B6 (RETURN)
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
11B4:  MOVLW  87
11B6:  MOVLB  3
11B8:  MOVWF  x7E
11BA:  MOVLB  0
11BC:  CALL   04CA
11C0:  MOVFF  01,37A
11C4:  MOVFF  01,37F
11C8:  RCALL  0E7A
11CA:  MOVFF  01,36F
....................    mth = rm_bcd(read_ds1302(0x89)); 
11CE:  MOVLW  89
11D0:  MOVLB  3
11D2:  MOVWF  x7E
11D4:  MOVLB  0
11D6:  CALL   04CA
11DA:  MOVFF  01,37A
11DE:  MOVFF  01,37F
11E2:  RCALL  0E7A
11E4:  MOVFF  01,370
....................    year = rm_bcd(read_ds1302(0x8d)); 
11E8:  MOVLW  8D
11EA:  MOVLB  3
11EC:  MOVWF  x7E
11EE:  MOVLB  0
11F0:  CALL   04CA
11F4:  MOVFF  01,37A
11F8:  MOVFF  01,37F
11FC:  RCALL  0E7A
11FE:  MOVFF  01,371
....................    dow = rm_bcd(read_ds1302(0x8b)); 
1202:  MOVLW  8B
1204:  MOVLB  3
1206:  MOVWF  x7E
1208:  MOVLB  0
120A:  CALL   04CA
120E:  MOVFF  01,37A
1212:  MOVFF  01,37F
1216:  RCALL  0E7A
1218:  MOVFF  01,36E
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
121C:  MOVLW  85
121E:  MOVLB  3
1220:  MOVWF  x7E
1222:  MOVLB  0
1224:  CALL   04CA
1228:  MOVFF  01,37A
122C:  MOVFF  01,37F
1230:  RCALL  0E7A
1232:  MOVFF  01,36B
....................    min = rm_bcd(read_ds1302(0x83)); 
1236:  MOVLW  83
1238:  MOVLB  3
123A:  MOVWF  x7E
123C:  MOVLB  0
123E:  CALL   04CA
1242:  MOVFF  01,37A
1246:  MOVFF  01,37F
124A:  RCALL  0E7A
124C:  MOVFF  01,36C
....................    sec = rm_bcd(read_ds1302(0x81)); 
1250:  MOVLW  81
1252:  MOVLB  3
1254:  MOVWF  x7E
1256:  MOVLB  0
1258:  CALL   04CA
125C:  MOVFF  01,37A
1260:  MOVFF  01,37F
1264:  RCALL  0E7A
1266:  MOVFF  01,36D
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "sht75.c" 
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... //                                                                           //  
.................... // Driver file for SHT75 Temperature & Humidity Sensor                       //  
.................... //                                                                           //  
.................... // ***** To initialise SHT75 sensor upon power up *****                      //  
.................... //                                                                           //  
.................... // Function : sht_init()                                                     //  
.................... // Return   : none                                                           //  
.................... //                                                                           //  
.................... //                                                                           //  
.................... // ***** To measure and calculate SHT75 temp & real RH *****                 //  
.................... //                                                                           //  
.................... // Function : sht_rd (temp, truehumid)                                       //  
.................... // Return   : temperature & true humidity in float values                    //  
.................... //                                                                           //  
.................... ///////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define sht_data_pin   PIN_C0   //#define sht_data_pin   PIN_D3  
.................... #define sht_clk_pin    PIN_C1   //#define sht_clk_pin    PIN_C4  
....................  
....................  
.................... //***** Function to alert SHT75 *****  
....................  
.................... void comstart (void)  
.................... {  
....................  output_float(sht_data_pin);  //data high  
*
0566:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);  //clk low  
0568:  BCF    F8B.1
056A:  BCF    F94.1
....................  delay_us(1);  
056C:  CLRWDT
056E:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
0570:  BSF    F8B.1
0572:  BCF    F94.1
....................  delay_us(1);  
0574:  CLRWDT
0576:  NOP   
....................  output_bit(sht_data_pin, 0); //data low  
0578:  BCF    F8B.0
057A:  BCF    F94.0
....................  delay_us(1);  
057C:  CLRWDT
057E:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0580:  BCF    F8B.1
0582:  BCF    F94.1
....................  delay_us(2);  
0584:  CLRWDT
0586:  BRA    0588
0588:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
058A:  BSF    F8B.1
058C:  BCF    F94.1
....................  delay_us(1);  
058E:  CLRWDT
0590:  NOP   
....................  output_float(sht_data_pin);  //data high  
0592:  BSF    F94.0
....................  delay_us(1);  
0594:  CLRWDT
0596:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
0598:  BCF    F8B.1
059A:  BCF    F94.1
.................... }  
059C:  RETLW  00
....................  
....................  
.................... //***** Function to write data to SHT75 *****  
....................  
.................... int1 comwrite (int8 iobyte)  
.................... {  
*
14D8:  MOVLW  80
14DA:  MOVLB  3
14DC:  MOVWF  x80
....................  int8 i, mask = 0x80;  
....................  int1 ack;  
....................  
....................  //Shift out command  
....................  delay_us(4);  
14DE:  CLRWDT
14E0:  MOVLW  02
14E2:  MOVWF  00
14E4:  DECFSZ 00,F
14E6:  BRA    14E4
....................  for(i=0; i<8; i++)  
14E8:  CLRF   x7F
14EA:  MOVF   x7F,W
14EC:  SUBLW  07
14EE:  BNC   1516
....................   {  
....................    output_bit(sht_clk_pin, 0);                          //clk low  
14F0:  BCF    F8B.1
14F2:  BCF    F94.1
....................    if((iobyte & mask) > 0) output_float(sht_data_pin);  //data high if MSB high  
14F4:  MOVF   x7E,W
14F6:  ANDWF  x80,W
14F8:  BZ    14FE
14FA:  BSF    F94.0
....................    else output_bit(sht_data_pin, 0);                    //data low if MSB low  
14FC:  BRA    1502
14FE:  BCF    F8B.0
1500:  BCF    F94.0
....................    delay_us(1);  
1502:  CLRWDT
1504:  NOP   
....................    output_bit(sht_clk_pin, 1);                          //clk high  
1506:  BSF    F8B.1
1508:  BCF    F94.1
....................    delay_us(1);  
150A:  CLRWDT
150C:  NOP   
....................    mask = mask >> 1;                                    //shift to next bit  
150E:  BCF    FD8.0
1510:  RRCF   x80,F
....................   }  
1512:  INCF   x7F,F
1514:  BRA    14EA
....................  
....................  //Shift in ack  
....................  output_bit(sht_clk_pin, 0);  //clk low  
1516:  BCF    F8B.1
1518:  BCF    F94.1
....................  delay_us(1);  
151A:  CLRWDT
151C:  NOP   
....................  ack = input(sht_data_pin);   //get ack bit  
151E:  BSF    F94.0
1520:  BCF    x81.0
1522:  BTFSC  F82.0
1524:  BSF    x81.0
....................  output_bit(sht_clk_pin, 1);  //clk high  
1526:  BSF    F8B.1
1528:  BCF    F94.1
....................  delay_us(1);  
152A:  CLRWDT
152C:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
152E:  BCF    F8B.1
1530:  BCF    F94.1
....................  return(ack);  
1532:  MOVLW  00
1534:  BTFSC  x81.0
1536:  MOVLW  01
1538:  MOVWF  01
.................... }  
153A:  MOVLB  0
153C:  RETLW  00
....................  
....................  
.................... //***** Function to read data from SHT75 *****  
....................  
.................... int16 comread (void)  
.................... {  
*
157A:  MOVLB  3
157C:  CLRF   x80
157E:  CLRF   x7F
....................  int8 i;  
....................  int16 iobyte = 0;  
....................  const int16 mask0 = 0x0000;  
....................  const int16 mask1 = 0x0001;  
....................  
....................  //shift in MSB data  
....................  for(i=0; i<8; i++)  
1580:  CLRF   x7E
1582:  MOVF   x7E,W
1584:  SUBLW  07
1586:  BNC   15AC
....................   {  
....................    iobyte = iobyte << 1;  
1588:  BCF    FD8.0
158A:  RLCF   x7F,F
158C:  RLCF   x80,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
158E:  BSF    F8B.1
1590:  BCF    F94.1
....................    delay_us(1);  
1592:  CLRWDT
1594:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
1596:  BSF    F94.0
1598:  BTFSS  F82.0
159A:  BRA    15A0
159C:  BSF    x7F.0
....................    else iobyte |= mask0;  
159E:  BRA    15A0
....................    output_bit(sht_clk_pin, 0);                //clk low  
15A0:  BCF    F8B.1
15A2:  BCF    F94.1
....................    delay_us(1);  
15A4:  CLRWDT
15A6:  NOP   
....................   }  
15A8:  INCF   x7E,F
15AA:  BRA    1582
....................  
....................  //send ack 0 bit  
....................  output_bit(sht_data_pin, 0); //data low  
15AC:  BCF    F8B.0
15AE:  BCF    F94.0
....................  delay_us(1);  
15B0:  CLRWDT
15B2:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
15B4:  BSF    F8B.1
15B6:  BCF    F94.1
....................  delay_us(2);  
15B8:  CLRWDT
15BA:  BRA    15BC
15BC:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
15BE:  BCF    F8B.1
15C0:  BCF    F94.1
....................  delay_us(1);  
15C2:  CLRWDT
15C4:  NOP   
....................  output_float(sht_data_pin);  //data high  
15C6:  BSF    F94.0
....................  
....................  //shift in LSB data  
....................  for(i=0; i<8; i++)  
15C8:  CLRF   x7E
15CA:  MOVF   x7E,W
15CC:  SUBLW  07
15CE:  BNC   15F4
....................   {  
....................    iobyte = iobyte << 1;  
15D0:  BCF    FD8.0
15D2:  RLCF   x7F,F
15D4:  RLCF   x80,F
....................    output_bit(sht_clk_pin, 1);                //clk high  
15D6:  BSF    F8B.1
15D8:  BCF    F94.1
....................    delay_us(1);  
15DA:  CLRWDT
15DC:  NOP   
....................    if (input(sht_data_pin)) iobyte |= mask1;  //shift in data bit  
15DE:  BSF    F94.0
15E0:  BTFSS  F82.0
15E2:  BRA    15E8
15E4:  BSF    x7F.0
....................    else iobyte |= mask0;  
15E6:  BRA    15E8
....................    output_bit(sht_clk_pin, 0);                //clk low  
15E8:  BCF    F8B.1
15EA:  BCF    F94.1
....................    delay_us(1);  
15EC:  CLRWDT
15EE:  NOP   
....................   }  
15F0:  INCF   x7E,F
15F2:  BRA    15CA
....................  
....................  //send ack 1 bit  
....................  output_float(sht_data_pin);  //data high  
15F4:  BSF    F94.0
....................  delay_us(1);  
15F6:  CLRWDT
15F8:  NOP   
....................  output_bit(sht_clk_pin, 1);  //clk high  
15FA:  BSF    F8B.1
15FC:  BCF    F94.1
....................  delay_us(2);  
15FE:  CLRWDT
1600:  BRA    1602
1602:  NOP   
....................  output_bit(sht_clk_pin, 0);  //clk low  
1604:  BCF    F8B.1
1606:  BCF    F94.1
....................  
....................  return(iobyte);  
1608:  MOVFF  37F,01
160C:  MOVFF  380,02
.................... }  
1610:  MOVLB  0
1612:  RETLW  00
....................  
....................  
.................... //***** Function to wait for SHT75 reading *****  
....................  
.................... void comwait (void)  
.................... {  
....................  int16 sht_delay;  
....................  
....................  output_float(sht_data_pin);                     //data high  
*
153E:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);                     //clk low  
1540:  BCF    F8B.1
1542:  BCF    F94.1
....................  delay_us(1);  
1544:  CLRWDT
1546:  NOP   
....................  for(sht_delay=0; sht_delay<30000; sht_delay++)  // wait for max 300ms  
1548:  MOVLB  3
154A:  CLRF   x7F
154C:  CLRF   x7E
154E:  MOVF   x7F,W
1550:  SUBLW  75
1552:  BNC   1576
1554:  BNZ   155C
1556:  MOVF   x7E,W
1558:  SUBLW  2F
155A:  BNC   1576
....................   {  
....................    if (!input(sht_data_pin)) break;              //if sht_data_pin low, SHT75 ready  
155C:  BSF    F94.0
155E:  BTFSC  F82.0
1560:  BRA    1564
1562:  BRA    1576
....................    delay_us(10);  
1564:  CLRWDT
1566:  MOVLW  06
1568:  MOVWF  00
156A:  DECFSZ 00,F
156C:  BRA    156A
....................   }  
156E:  INCF   x7E,F
1570:  BTFSC  FD8.2
1572:  INCF   x7F,F
1574:  BRA    154E
.................... }  
1576:  MOVLB  0
1578:  RETLW  00
....................  
....................  
.................... //***** Function to reset SHT75 communication *****  
....................  
.................... void comreset (void)  
.................... {  
....................  int8 i;  
....................  
....................  output_float(sht_data_pin);    //data high  
*
059E:  BSF    F94.0
....................  output_bit(sht_clk_pin, 0);    //clk low  
05A0:  BCF    F8B.1
05A2:  BCF    F94.1
....................  delay_us(2);  
05A4:  CLRWDT
05A6:  BRA    05A8
05A8:  NOP   
....................  for(i=0; i<9; i++)  
05AA:  MOVLB  3
05AC:  CLRF   x54
05AE:  MOVF   x54,W
05B0:  SUBLW  08
05B2:  BNC   05CC
....................   {  
....................    output_bit(sht_clk_pin, 1);  //toggle clk 9 times  
05B4:  BSF    F8B.1
05B6:  BCF    F94.1
....................    delay_us(2);  
05B8:  CLRWDT
05BA:  BRA    05BC
05BC:  NOP   
....................    output_bit(sht_clk_pin, 0);  
05BE:  BCF    F8B.1
05C0:  BCF    F94.1
....................    delay_us(2);  
05C2:  CLRWDT
05C4:  BRA    05C6
05C6:  NOP   
....................  }  
05C8:  INCF   x54,F
05CA:  BRA    05AE
....................  comstart();  
05CC:  MOVLB  0
05CE:  RCALL  0566
.................... }  
05D0:  GOTO   0606 (RETURN)
....................  
....................  
.................... //***** Function to soft reset SHT75 *****  
....................  
.................... void sht_soft_reset (void)  
.................... {  
....................  comreset();           //SHT75 communication reset  
....................  comwrite(0x1e);       //send SHT75 reset command  
....................  delay_ms(15);         //pause 15 ms  
.................... }  
....................  
....................  
.................... //***** Function to measure SHT75 temperature *****  
....................  
.................... int16 measuretemp (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();             //alert SHT75  
*
1614:  CALL   0566
....................  ack = comwrite(0x03);   //send measure temp command and read ack status  
1618:  MOVLW  03
161A:  MOVLB  3
161C:  MOVWF  x7E
161E:  MOVLB  0
1620:  RCALL  14D8
1622:  MOVLB  3
1624:  BCF    x7B.0
1626:  BTFSC  01.0
1628:  BSF    x7B.0
....................  if(ack == 1) return 0;  // Debe retornar un valor      
162A:  BTFSS  x7B.0
162C:  BRA    1636
162E:  MOVLW  00
1630:  MOVWF  01
1632:  MOVWF  02
1634:  BRA    164E
....................  comwait();              //wait for SHT75 measurement to complete  
1636:  MOVLB  0
1638:  RCALL  153E
....................  iobyte = comread();     //read SHT75 temp data  
163A:  RCALL  157A
163C:  MOVFF  02,37D
1640:  MOVFF  01,37C
....................  return(iobyte);  
1644:  MOVLB  3
1646:  MOVFF  37C,01
164A:  MOVFF  37D,02
.................... }  
164E:  MOVLB  0
1650:  GOTO   235E (RETURN)
....................  
....................  
.................... //***** Function to measure SHT75 RH *****  
....................  
.................... int16 measurehumid (void)  
.................... {  
....................  int1 ack;  
....................  int16 iobyte;  
....................  
....................  comstart();            //alert SHT75  
1654:  CALL   0566
....................  ack = comwrite(0x05);  //send measure RH command and read ack status  
1658:  MOVLW  05
165A:  MOVLB  3
165C:  MOVWF  x7E
165E:  MOVLB  0
1660:  RCALL  14D8
1662:  MOVLB  3
1664:  BCF    x7B.0
1666:  BTFSC  01.0
1668:  BSF    x7B.0
....................  if(ack == 1) return 0;   // Debe retornar algun valor 
166A:  BTFSS  x7B.0
166C:  BRA    1676
166E:  MOVLW  00
1670:  MOVWF  01
1672:  MOVWF  02
1674:  BRA    168E
....................  comwait();             //wait for SHT75 measurement to complete  
1676:  MOVLB  0
1678:  RCALL  153E
....................  iobyte = comread();    //read SHT75 temp data  
167A:  RCALL  157A
167C:  MOVFF  02,37D
1680:  MOVFF  01,37C
....................  return(iobyte);  
1684:  MOVLB  3
1686:  MOVFF  37C,01
168A:  MOVFF  37D,02
.................... }  
168E:  MOVLB  0
1690:  GOTO   236A (RETURN)
....................  
....................  
.................... //***** Function to calculate SHT75 temp & RH *****  
....................  
.................... void calculate_data (int16 temp, int16 humid, float & tc, float & rhlin, float & rhtrue)  
.................... {  
....................  float rh; // float truehumid1, rh;  
....................  
....................  //calculate temperature reading  
....................  tc = ((float) temp * 0.01) - 40.0;  
*
2382:  MOVFF  37C,3A6
2386:  MOVFF  37B,3A5
238A:  CALL   1694
238E:  MOVFF  00,383
2392:  MOVFF  01,384
2396:  MOVFF  02,385
239A:  MOVFF  03,386
239E:  MOVFF  03,410
23A2:  MOVFF  02,40F
23A6:  MOVFF  01,40E
23AA:  MOVFF  00,40D
23AE:  MOVLW  0A
23B0:  MOVLB  4
23B2:  MOVWF  x14
23B4:  MOVLW  D7
23B6:  MOVWF  x13
23B8:  MOVLW  23
23BA:  MOVWF  x12
23BC:  MOVLW  78
23BE:  MOVWF  x11
23C0:  MOVLB  0
23C2:  CALL   16CA
23C6:  MOVFF  00,383
23CA:  MOVFF  01,384
23CE:  MOVFF  02,385
23D2:  MOVFF  03,386
23D6:  BSF    FD8.1
23D8:  MOVFF  03,3A8
23DC:  MOVFF  02,3A7
23E0:  MOVFF  01,3A6
23E4:  MOVFF  00,3A5
23E8:  MOVLB  3
23EA:  CLRF   xAC
23EC:  CLRF   xAB
23EE:  MOVLW  20
23F0:  MOVWF  xAA
23F2:  MOVLW  84
23F4:  MOVWF  xA9
23F6:  MOVLB  0
23F8:  CALL   17C0
23FC:  MOVFF  03,2F5
2400:  MOVFF  02,2F4
2404:  MOVFF  01,2F3
2408:  MOVFF  00,2F2
....................  
....................  //calculate Real RH reading  
....................  rh = (float) humid;  
240C:  MOVFF  37E,3A6
2410:  MOVFF  37D,3A5
2414:  CALL   1694
2418:  MOVFF  03,382
241C:  MOVFF  02,381
2420:  MOVFF  01,380
2424:  MOVFF  00,37F
....................  
....................  rhlin = (rh * 0.0405) - (rh * rh * 0.0000028) - 4.0;  
2428:  MOVFF  382,410
242C:  MOVFF  381,40F
2430:  MOVFF  380,40E
2434:  MOVFF  37F,40D
2438:  MOVLW  54
243A:  MOVLB  4
243C:  MOVWF  x14
243E:  MOVLW  E3
2440:  MOVWF  x13
2442:  MOVLW  25
2444:  MOVWF  x12
2446:  MOVLW  7A
2448:  MOVWF  x11
244A:  MOVLB  0
244C:  CALL   16CA
2450:  MOVFF  00,383
2454:  MOVFF  01,384
2458:  MOVFF  02,385
245C:  MOVFF  03,386
2460:  MOVFF  382,410
2464:  MOVFF  381,40F
2468:  MOVFF  380,40E
246C:  MOVFF  37F,40D
2470:  MOVFF  382,414
2474:  MOVFF  381,413
2478:  MOVFF  380,412
247C:  MOVFF  37F,411
2480:  CALL   16CA
2484:  MOVFF  00,387
2488:  MOVFF  01,388
248C:  MOVFF  02,389
2490:  MOVFF  03,38A
2494:  MOVFF  03,410
2498:  MOVFF  02,40F
249C:  MOVFF  01,40E
24A0:  MOVFF  00,40D
24A4:  MOVLW  A2
24A6:  MOVLB  4
24A8:  MOVWF  x14
24AA:  MOVLW  E7
24AC:  MOVWF  x13
24AE:  MOVLW  3B
24B0:  MOVWF  x12
24B2:  MOVLW  6C
24B4:  MOVWF  x11
24B6:  MOVLB  0
24B8:  CALL   16CA
24BC:  BSF    FD8.1
24BE:  MOVFF  386,3A8
24C2:  MOVFF  385,3A7
24C6:  MOVFF  384,3A6
24CA:  MOVFF  383,3A5
24CE:  MOVFF  03,3AC
24D2:  MOVFF  02,3AB
24D6:  MOVFF  01,3AA
24DA:  MOVFF  00,3A9
24DE:  CALL   17C0
24E2:  MOVFF  00,383
24E6:  MOVFF  01,384
24EA:  MOVFF  02,385
24EE:  MOVFF  03,386
24F2:  BSF    FD8.1
24F4:  MOVFF  03,3A8
24F8:  MOVFF  02,3A7
24FC:  MOVFF  01,3A6
2500:  MOVFF  00,3A5
2504:  MOVLB  3
2506:  CLRF   xAC
2508:  CLRF   xAB
250A:  CLRF   xAA
250C:  MOVLW  81
250E:  MOVWF  xA9
2510:  MOVLB  0
2512:  CALL   17C0
2516:  MOVFF  03,372
251A:  MOVFF  02,371
251E:  MOVFF  01,370
2522:  MOVFF  00,36F
....................  
....................  //calculate True RH reading  
....................  rhtrue = ((tc - 25.0) * (0.01 + (0.00008 * rh))) + rhlin;  
2526:  BSF    FD8.1
2528:  MOVFF  2F5,3A8
252C:  MOVFF  2F4,3A7
2530:  MOVFF  2F3,3A6
2534:  MOVFF  2F2,3A5
2538:  MOVLB  3
253A:  CLRF   xAC
253C:  CLRF   xAB
253E:  MOVLW  48
2540:  MOVWF  xAA
2542:  MOVLW  83
2544:  MOVWF  xA9
2546:  MOVLB  0
2548:  CALL   17C0
254C:  MOVFF  00,383
2550:  MOVFF  01,384
2554:  MOVFF  02,385
2558:  MOVFF  03,386
255C:  MOVLW  AC
255E:  MOVLB  4
2560:  MOVWF  x10
2562:  MOVLW  C5
2564:  MOVWF  x0F
2566:  MOVLW  27
2568:  MOVWF  x0E
256A:  MOVLW  71
256C:  MOVWF  x0D
256E:  MOVFF  382,414
2572:  MOVFF  381,413
2576:  MOVFF  380,412
257A:  MOVFF  37F,411
257E:  MOVLB  0
2580:  CALL   16CA
2584:  BCF    FD8.1
2586:  MOVLW  0A
2588:  MOVLB  3
258A:  MOVWF  xA8
258C:  MOVLW  D7
258E:  MOVWF  xA7
2590:  MOVLW  23
2592:  MOVWF  xA6
2594:  MOVLW  78
2596:  MOVWF  xA5
2598:  MOVFF  03,3AC
259C:  MOVFF  02,3AB
25A0:  MOVFF  01,3AA
25A4:  MOVFF  00,3A9
25A8:  MOVLB  0
25AA:  CALL   17C0
25AE:  MOVFF  386,410
25B2:  MOVFF  385,40F
25B6:  MOVFF  384,40E
25BA:  MOVFF  383,40D
25BE:  MOVFF  03,414
25C2:  MOVFF  02,413
25C6:  MOVFF  01,412
25CA:  MOVFF  00,411
25CE:  CALL   16CA
25D2:  MOVFF  00,383
25D6:  MOVFF  01,384
25DA:  MOVFF  02,385
25DE:  MOVFF  03,386
25E2:  BCF    FD8.1
25E4:  MOVFF  03,3A8
25E8:  MOVFF  02,3A7
25EC:  MOVFF  01,3A6
25F0:  MOVFF  00,3A5
25F4:  MOVFF  372,3AC
25F8:  MOVFF  371,3AB
25FC:  MOVFF  370,3AA
2600:  MOVFF  36F,3A9
2604:  CALL   17C0
2608:  MOVFF  03,2F1
260C:  MOVFF  02,2F0
2610:  MOVFF  01,2EF
2614:  MOVFF  00,2EE
.................... }  
....................  
....................  
.................... //***** Function to measure & calculate SHT75 temp & RH *****  
....................  
.................... void sht_rd (float & temp, float & truehumid)  
.................... {  
....................  int16 restemp, reshumid;  
....................  float realhumid;  
....................  restemp = 0; truehumid = 0;  
*
2348:  MOVLB  3
234A:  CLRF   x6C
234C:  CLRF   x6B
234E:  MOVLB  2
2350:  CLRF   xF1
2352:  CLRF   xF0
2354:  CLRF   xEF
2356:  CLRF   xEE
....................  
....................  restemp = measuretemp();    //measure temp  
2358:  MOVLB  0
235A:  GOTO   1614
235E:  MOVFF  02,36C
2362:  MOVFF  01,36B
....................  reshumid = measurehumid();  //measure RH  
2366:  GOTO   1654
236A:  MOVFF  02,36E
236E:  MOVFF  01,36D
....................  calculate_data (restemp, reshumid, temp, realhumid, truehumid);  //calculate temp & RH  
2372:  MOVFF  36C,37C
2376:  MOVFF  36B,37B
237A:  MOVFF  36E,37E
237E:  MOVFF  36D,37D
*
2618:  NOP   
.................... }  
....................  
....................  
.................... //***** Function to initialise SHT75 on power-up *****  
....................  
.................... void sht_init (void)  
.................... {  
....................  comreset();    //reset SHT75  
*
0604:  BRA    059E
....................  delay_ms(20);  //delay for power-up  
0606:  MOVLW  14
0608:  MOVLB  3
060A:  MOVWF  x74
060C:  MOVLB  0
060E:  RCALL  05D4
.................... } 
0610:  GOTO   4D7E (RETURN)
....................  
.................... #include <24512.C> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B1 
.................... #define EEPROM_SCL  PIN_B0 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
1D1E:  MOVLW  08
1D20:  MOVWF  01
1D22:  BRA    1D24
1D24:  BCF    F89.4
1D26:  BCF    F92.4
1D28:  BRA    1D2A
1D2A:  NOP   
1D2C:  MOVLB  3
1D2E:  RLCF   x98,F
1D30:  BCF    F89.5
1D32:  BTFSC  FD8.0
1D34:  BSF    F92.5
1D36:  BTFSS  FD8.0
1D38:  BCF    F92.5
1D3A:  BSF    F92.4
1D3C:  BTFSS  F80.4
1D3E:  BRA    1D3C
1D40:  DECFSZ 01,F
1D42:  BRA    1D46
1D44:  BRA    1D4A
1D46:  MOVLB  0
1D48:  BRA    1D22
1D4A:  BRA    1D4C
1D4C:  BCF    F89.4
1D4E:  BCF    F92.4
1D50:  NOP   
1D52:  BSF    F92.5
1D54:  BRA    1D56
1D56:  NOP   
1D58:  BRA    1D5A
1D5A:  NOP   
1D5C:  BSF    F92.4
1D5E:  BTFSS  F80.4
1D60:  BRA    1D5E
1D62:  CLRF   01
1D64:  BRA    1D66
1D66:  NOP   
1D68:  BTFSC  F80.5
1D6A:  BSF    01.0
1D6C:  BCF    F89.4
1D6E:  BCF    F92.4
1D70:  BCF    F89.5
1D72:  BCF    F92.5
1D74:  MOVLB  0
1D76:  RETLW  00
1D78:  MOVLW  08
1D7A:  MOVLB  3
1D7C:  MOVWF  x84
1D7E:  MOVFF  00,385
1D82:  BSF    F92.5
1D84:  BRA    1D86
1D86:  NOP   
1D88:  BSF    F92.4
1D8A:  BTFSS  F80.4
1D8C:  BRA    1D8A
1D8E:  BTFSC  F80.5
1D90:  BSF    FD8.0
1D92:  BTFSS  F80.5
1D94:  BCF    FD8.0
1D96:  RLCF   01,F
1D98:  BRA    1D9A
1D9A:  BCF    F92.4
1D9C:  BCF    F89.4
1D9E:  DECFSZ x84,F
1DA0:  BRA    1D82
1DA2:  BSF    F92.5
1DA4:  BRA    1DA6
1DA6:  NOP   
1DA8:  BCF    F89.5
1DAA:  MOVF   x85,W
1DAC:  BTFSS  FD8.2
1DAE:  BCF    F92.5
1DB0:  NOP   
1DB2:  BSF    F92.4
1DB4:  BTFSS  F80.4
1DB6:  BRA    1DB4
1DB8:  BRA    1DBA
1DBA:  BCF    F89.4
1DBC:  BCF    F92.4
1DBE:  BRA    1DC0
1DC0:  NOP   
1DC2:  BCF    F89.5
1DC4:  BCF    F92.5
1DC6:  MOVLB  0
1DC8:  GOTO   1E26 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   65535 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
0614:  BSF    F92.4
....................    output_float(EEPROM_SDA); 
0616:  BSF    F92.5
....................  
.................... } 
0618:  GOTO   4D82 (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
27CE:  BSF    F92.5
27D0:  BRA    27D2
27D2:  BSF    F92.4
27D4:  BRA    27D6
27D6:  NOP   
27D8:  BCF    F89.5
27DA:  BCF    F92.5
27DC:  BRA    27DE
27DE:  BCF    F89.4
27E0:  BCF    F92.4
....................    i2c_write(0xa0); 
27E2:  MOVLW  A0
27E4:  MOVLB  3
27E6:  MOVWF  x98
27E8:  MOVLB  0
27EA:  CALL   1D1E
....................    i2c_write(address>>8); 
27EE:  MOVFF  393,396
27F2:  MOVLB  3
27F4:  CLRF   x97
27F6:  MOVFF  393,398
27FA:  MOVLB  0
27FC:  CALL   1D1E
....................    i2c_write(address); 
2800:  MOVFF  392,398
2804:  CALL   1D1E
....................    i2c_write(data); 
2808:  MOVFF  394,398
280C:  CALL   1D1E
....................    i2c_stop(); 
2810:  BCF    F92.5
2812:  NOP   
2814:  BSF    F92.4
2816:  BTFSS  F80.4
2818:  BRA    2816
281A:  BRA    281C
281C:  BRA    281E
281E:  NOP   
2820:  BSF    F92.5
2822:  BRA    2824
....................    i2c_start(); 
2824:  BSF    F92.5
2826:  BRA    2828
2828:  BSF    F92.4
282A:  BRA    282C
282C:  NOP   
282E:  BCF    F89.5
2830:  BCF    F92.5
2832:  BRA    2834
2834:  BCF    F89.4
2836:  BCF    F92.4
....................    status=i2c_write(0xa0); 
2838:  MOVLW  A0
283A:  MOVLB  3
283C:  MOVWF  x98
283E:  MOVLB  0
2840:  CALL   1D1E
2844:  MOVF   01,W
2846:  MOVLB  3
2848:  BCF    x95.0
284A:  BTFSC  01.0
284C:  BSF    x95.0
....................    while(status==1) 
....................    { 
284E:  BTFSS  x95.0
2850:  BRA    2880
....................       i2c_start(); 
2852:  BSF    F92.5
2854:  BRA    2856
2856:  BSF    F92.4
2858:  BRA    285A
285A:  NOP   
285C:  BTFSS  F80.4
285E:  BRA    285C
2860:  BCF    F89.5
2862:  BCF    F92.5
2864:  BRA    2866
2866:  BCF    F89.4
2868:  BCF    F92.4
....................       status=i2c_write(0xa0); 
286A:  MOVLW  A0
286C:  MOVWF  x98
286E:  MOVLB  0
2870:  CALL   1D1E
2874:  MOVF   01,W
2876:  MOVLB  3
2878:  BCF    x95.0
287A:  BTFSC  01.0
287C:  BSF    x95.0
....................    } 
287E:  BRA    284E
....................    i2c_stop(); 
2880:  BCF    F92.5
2882:  NOP   
2884:  BSF    F92.4
2886:  BTFSS  F80.4
2888:  BRA    2886
288A:  BRA    288C
288C:  BRA    288E
288E:  NOP   
2890:  BSF    F92.5
2892:  BRA    2894
.................... } 
2894:  MOVLB  0
2896:  RETLW  00
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
1DCC:  BSF    F92.5
1DCE:  BRA    1DD0
1DD0:  BSF    F92.4
1DD2:  BRA    1DD4
1DD4:  NOP   
1DD6:  BCF    F89.5
1DD8:  BCF    F92.5
1DDA:  BRA    1DDC
1DDC:  BCF    F89.4
1DDE:  BCF    F92.4
....................    i2c_write(0xa0); 
1DE0:  MOVLW  A0
1DE2:  MOVLB  3
1DE4:  MOVWF  x98
1DE6:  MOVLB  0
1DE8:  RCALL  1D1E
....................    i2c_write(address>>8); 
1DEA:  MOVFF  381,383
1DEE:  MOVLB  3
1DF0:  CLRF   x84
1DF2:  MOVFF  381,398
1DF6:  MOVLB  0
1DF8:  RCALL  1D1E
....................    i2c_write(address); 
1DFA:  MOVFF  380,398
1DFE:  RCALL  1D1E
....................    i2c_start(); 
1E00:  BSF    F92.5
1E02:  BRA    1E04
1E04:  BSF    F92.4
1E06:  BRA    1E08
1E08:  NOP   
1E0A:  BTFSS  F80.4
1E0C:  BRA    1E0A
1E0E:  BCF    F89.5
1E10:  BCF    F92.5
1E12:  BRA    1E14
1E14:  BCF    F89.4
1E16:  BCF    F92.4
....................    i2c_write(0xa1); 
1E18:  MOVLW  A1
1E1A:  MOVLB  3
1E1C:  MOVWF  x98
1E1E:  MOVLB  0
1E20:  RCALL  1D1E
....................    data=i2c_read(0); 
1E22:  CLRF   00
1E24:  BRA    1D78
1E26:  MOVFF  01,382
....................    i2c_stop(); 
1E2A:  BCF    F92.5
1E2C:  NOP   
1E2E:  BSF    F92.4
1E30:  BTFSS  F80.4
1E32:  BRA    1E30
1E34:  BRA    1E36
1E36:  BRA    1E38
1E38:  NOP   
1E3A:  BSF    F92.5
1E3C:  BRA    1E3E
....................    return(data); 
1E3E:  MOVLB  3
1E40:  MOVFF  382,01
.................... } 
1E44:  MOVLB  0
1E46:  RETLW  00
....................  
.................... #include "timeFunc.c" 
.................... typedef struct dateSt {         // estructura para la conversión de fecha 
....................    char  hour; 
....................    char  min; 
....................    char  sec; 
....................    char  day; 
....................    char  mon; 
....................    char  dow; 
....................    long  year; 
.................... } TDateSt; 
....................  
.................... const long  mes[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
.................... const char S2Ddays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................  
.................... char	dtFecha[10], dtHora[10]; 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | Date2Sec(TDateSt time) Convierte la fecha pasada en la estructura en segundos 
.................... | Parametro: 'time' : estructura tipo TDateSt 
.................... | RETURN VALUE: unsigned long (segundos) 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... int32  Date2Sec(TDateSt *time) 
.................... { 
....................    int32  t, xt; 
....................     
....................    xt = 365L * (int32)(time->year - 1970) + (int32)(mes[time->mon-1] + time->day - 1); 
*
0F08:  MOVLW  06
0F0A:  MOVLB  3
0F0C:  ADDWF  x7A,W
0F0E:  MOVWF  FE9
0F10:  MOVLW  00
0F12:  ADDWFC x7B,W
0F14:  MOVWF  FEA
0F16:  MOVFF  FEC,385
0F1A:  MOVF   FED,F
0F1C:  MOVFF  FEF,384
0F20:  MOVLW  B2
0F22:  SUBWF  x84,W
0F24:  MOVWF  00
0F26:  MOVLW  07
0F28:  SUBWFB x85,W
0F2A:  MOVWF  03
0F2C:  MOVF   00,W
0F2E:  MOVFF  03,01
0F32:  CLRF   02
0F34:  CLRF   03
0F36:  MOVFF  03,387
0F3A:  MOVFF  02,386
0F3E:  MOVFF  01,385
0F42:  MOVFF  00,384
0F46:  MOVFF  FEA,389
0F4A:  MOVFF  FE9,388
0F4E:  CLRF   x96
0F50:  CLRF   x95
0F52:  MOVLW  01
0F54:  MOVWF  x94
0F56:  MOVLW  6D
0F58:  MOVWF  x93
0F5A:  MOVFF  03,39A
0F5E:  MOVFF  02,399
0F62:  MOVFF  01,398
0F66:  MOVFF  00,397
0F6A:  MOVLB  0
0F6C:  RCALL  0EAC
0F6E:  MOVFF  389,FEA
0F72:  MOVFF  388,FE9
0F76:  MOVFF  03,387
0F7A:  MOVFF  02,386
0F7E:  MOVFF  01,385
0F82:  MOVFF  00,384
0F86:  MOVLW  04
0F88:  MOVLB  3
0F8A:  ADDWF  x7A,W
0F8C:  MOVWF  FE9
0F8E:  MOVLW  00
0F90:  ADDWFC x7B,W
0F92:  MOVWF  FEA
0F94:  MOVLW  01
0F96:  SUBWF  FEF,W
0F98:  MOVWF  00
0F9A:  BCF    FD8.0
0F9C:  RLCF   00,F
0F9E:  MOVF   00,W
0FA0:  CLRF   03
0FA2:  MOVFF  FF2,38A
0FA6:  BCF    FF2.7
0FA8:  MOVLB  0
0FAA:  CALL   00AE
0FAE:  TBLRD*+
0FB0:  MOVFF  FF5,03
0FB4:  MOVLB  3
0FB6:  BTFSC  x8A.7
0FB8:  BSF    FF2.7
0FBA:  MOVWF  x8A
0FBC:  MOVFF  03,38B
0FC0:  MOVLW  03
0FC2:  ADDWF  x7A,W
0FC4:  MOVWF  FE9
0FC6:  MOVLW  00
0FC8:  ADDWFC x7B,W
0FCA:  MOVWF  FEA
0FCC:  MOVF   FEF,W
0FCE:  ADDWF  x8A,F
0FD0:  MOVLW  00
0FD2:  ADDWFC x8B,F
0FD4:  MOVLW  01
0FD6:  SUBWF  x8A,W
0FD8:  MOVWF  00
0FDA:  MOVLW  00
0FDC:  SUBWFB x8B,W
0FDE:  MOVWF  03
0FE0:  MOVF   00,W
0FE2:  MOVFF  03,01
0FE6:  CLRF   02
0FE8:  CLRF   03
0FEA:  MOVF   00,W
0FEC:  ADDWF  x84,W
0FEE:  MOVWF  x80
0FF0:  MOVF   01,W
0FF2:  ADDWFC x85,W
0FF4:  MOVWF  x81
0FF6:  MOVF   02,W
0FF8:  ADDWFC x86,W
0FFA:  MOVWF  x82
0FFC:  MOVF   03,W
0FFE:  ADDWFC x87,W
1000:  MOVWF  x83
....................    xt += (int32)((time->year - 1969) >> 2); 
1002:  MOVLW  06
1004:  ADDWF  x7A,W
1006:  MOVWF  FE9
1008:  MOVLW  00
100A:  ADDWFC x7B,W
100C:  MOVWF  FEA
100E:  MOVFF  FEC,385
1012:  MOVF   FED,F
1014:  MOVFF  FEF,384
1018:  MOVLW  B1
101A:  SUBWF  x84,F
101C:  MOVLW  07
101E:  SUBWFB x85,F
1020:  RRCF   x85,W
1022:  MOVWF  03
1024:  RRCF   x84,W
1026:  MOVWF  02
1028:  RRCF   03,F
102A:  RRCF   02,F
102C:  MOVLW  3F
102E:  ANDWF  03,F
1030:  MOVFF  02,00
1034:  MOVFF  03,01
1038:  CLRF   02
103A:  CLRF   03
103C:  MOVF   00,W
103E:  ADDWF  x80,F
1040:  MOVF   01,W
1042:  ADDWFC x81,F
1044:  MOVF   02,W
1046:  ADDWFC x82,F
1048:  MOVF   03,W
104A:  ADDWFC x83,F
....................    if ((time->mon > 2) && ((time->year & 3) == 0)) xt++; 
104C:  MOVLW  04
104E:  ADDWF  x7A,W
1050:  MOVWF  FE9
1052:  MOVLW  00
1054:  ADDWFC x7B,W
1056:  MOVWF  FEA
1058:  MOVF   FEF,W
105A:  SUBLW  02
105C:  BC    1092
105E:  MOVLW  06
1060:  ADDWF  x7A,W
1062:  MOVWF  FE9
1064:  MOVLW  00
1066:  ADDWFC x7B,W
1068:  MOVWF  FEA
106A:  MOVFF  FEC,385
106E:  MOVF   FED,F
1070:  MOVFF  FEF,384
1074:  MOVLW  03
1076:  ANDWF  x84,F
1078:  CLRF   x85
107A:  MOVF   x84,F
107C:  BNZ   1092
107E:  MOVF   x85,F
1080:  BNZ   1092
1082:  MOVLW  01
1084:  ADDWF  x80,F
1086:  BTFSC  FD8.0
1088:  INCF   x81,F
108A:  BTFSC  FD8.2
108C:  INCF   x82,F
108E:  BTFSC  FD8.2
1090:  INCF   x83,F
....................    t = (int32)(time->sec) + 60L * ((int32)(time->min) + 60L * (int32)(time->hour + 24 * xt)); 
1092:  MOVLW  02
1094:  ADDWF  x7A,W
1096:  MOVWF  FE9
1098:  MOVLW  00
109A:  ADDWFC x7B,W
109C:  MOVWF  FEA
109E:  MOVF   FEF,W
10A0:  CLRF   x87
10A2:  CLRF   x86
10A4:  CLRF   x85
10A6:  MOVWF  x84
10A8:  MOVLW  01
10AA:  ADDWF  x7A,W
10AC:  MOVWF  FE9
10AE:  MOVLW  00
10B0:  ADDWFC x7B,W
10B2:  MOVWF  FEA
10B4:  MOVF   FEF,W
10B6:  CLRF   x8B
10B8:  CLRF   x8A
10BA:  CLRF   x89
10BC:  MOVWF  x88
10BE:  MOVFF  37A,FE9
10C2:  MOVFF  37B,FEA
10C6:  MOVFF  FEF,38C
10CA:  MOVFF  FEA,38E
10CE:  MOVFF  FE9,38D
10D2:  CLRF   x96
10D4:  CLRF   x95
10D6:  CLRF   x94
10D8:  MOVLW  18
10DA:  MOVWF  x93
10DC:  MOVFF  383,39A
10E0:  MOVFF  382,399
10E4:  MOVFF  381,398
10E8:  MOVFF  380,397
10EC:  MOVLB  0
10EE:  RCALL  0EAC
10F0:  MOVFF  38E,FEA
10F4:  MOVFF  38D,FE9
10F8:  MOVLB  3
10FA:  MOVF   x8C,W
10FC:  ADDWF  00,F
10FE:  MOVLW  00
1100:  ADDWFC 01,F
1102:  ADDWFC 02,F
1104:  ADDWFC 03,F
1106:  MOVFF  FEA,390
110A:  MOVFF  FE9,38F
110E:  CLRF   x96
1110:  CLRF   x95
1112:  CLRF   x94
1114:  MOVLW  3C
1116:  MOVWF  x93
1118:  MOVFF  03,39A
111C:  MOVFF  02,399
1120:  MOVFF  01,398
1124:  MOVFF  00,397
1128:  MOVLB  0
112A:  RCALL  0EAC
112C:  MOVFF  390,FEA
1130:  MOVFF  38F,FE9
1134:  MOVLB  3
1136:  MOVF   x88,W
1138:  ADDWF  00,F
113A:  MOVF   x89,W
113C:  ADDWFC 01,F
113E:  MOVF   x8A,W
1140:  ADDWFC 02,F
1142:  MOVF   x8B,W
1144:  ADDWFC 03,F
1146:  MOVFF  03,38B
114A:  MOVFF  02,38A
114E:  MOVFF  01,389
1152:  MOVFF  00,388
1156:  MOVFF  FEA,392
115A:  MOVFF  FE9,391
115E:  CLRF   x96
1160:  CLRF   x95
1162:  CLRF   x94
1164:  MOVLW  3C
1166:  MOVWF  x93
1168:  MOVFF  03,39A
116C:  MOVFF  02,399
1170:  MOVFF  01,398
1174:  MOVFF  00,397
1178:  MOVLB  0
117A:  RCALL  0EAC
117C:  MOVFF  392,FEA
1180:  MOVFF  391,FE9
1184:  MOVF   00,W
1186:  MOVLB  3
1188:  ADDWF  x84,W
118A:  MOVWF  x7C
118C:  MOVF   01,W
118E:  ADDWFC x85,W
1190:  MOVWF  x7D
1192:  MOVF   02,W
1194:  ADDWFC x86,W
1196:  MOVWF  x7E
1198:  MOVF   03,W
119A:  ADDWFC x87,W
119C:  MOVWF  x7F
....................    return t;    
119E:  MOVFF  37C,00
11A2:  MOVFF  37D,01
11A6:  MOVFF  37E,02
11AA:  MOVFF  37F,03
.................... } 
11AE:  MOVLB  0
11B0:  GOTO   1302 (RETURN)
.................... //----------------------------------------------------------------------------------------------------- 
....................  
.................... /*------------------------------------------------------------------------------------------------------ 
.................... |  Sec2Date(unsigned long x, TDateSt *pD) 
.................... |  Convierte la fecha expresada en segundos a día, mes, año, día de la semana, horas, minutos y segundos. 
.................... |  Parametro: 'x'   : fecha en segundos 
.................... |   		  'pD'  : puntero a una estructura tipo TDateSt donde se devuelve el resultado 
.................... |  RETURN VALUE:  ninguno 
.................... ------------------------------------------------------------------------------------------------------*/ 
.................... void Sec2Date(int32 x, TDateSt *pD) 
.................... { 
....................    int32 iMin, iHor, iDay; 
....................    long   hpery; 
....................    int32 i, cumdays; 
....................  
....................    iMin = x / 60; 
....................    pD->sec = (char)(x - (60 * iMin)); 
....................    iHor = iMin / 60; 
....................    pD->min = (char)(iMin - 60 * iHor); 
....................    iDay = iHor / 24; 
....................    pD->hour = (char)(iHor - 24 * iDay); 
....................    i = (int32)(iHor / (1461L * 24L)); 
....................    cumdays = 1461L * i; 
....................    pD->year = (long)(i << 2); 
....................    pD->year += (long)1970; 
....................    iHor %= 1461L * 24L; 
....................    for (;;) { 
....................      hpery = 365 * 24; 
....................      if ((pD->year & 3) == 0) hpery += 24; 
....................      if (iHor < (int32)hpery) break; 
....................      cumdays += hpery / 24; 
....................      pD->year++; 
....................      iHor -= hpery; 
....................    } 
....................    iHor /= 24; 
....................    cumdays += (long)iHor + 4; 
....................    pD->dow = (char)((cumdays % 7)+1); 
....................    pD->day = (char)iHor; 
....................    iHor++; 
....................    if ((pD->year & 3) == 0) { 
....................      if (iHor > 60) 
....................         iHor--; 
....................      else 
....................         if (iHor == 60) { 
....................            pD->mon = 2; 
....................            pD->day = 29; 
....................            return; 
....................         } 
....................    } 
....................    for (pD->mon = 0; S2Ddays[pD->mon] < (int)iHor; pD->mon++)  iHor -= S2Ddays[pD->mon]; 
....................    pD->day = (char)iHor; 
....................    pD->mon += (char)1; 
....................    return; 
.................... } 
.................... //---------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | GetDateTime(char *dt) | Obtiene la fecha y hora del rtc y lo retorna en un string 
.................... | Parametro: puntero a char destino de cadena 
.................... | RETURN VALUE: ninguno 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... void GetDateTime(char *dt){ 
.................... 	BYTE  		hora, min, sec, dow, dia, mes, year; 
....................  
.................... 	rtc_get_date(dia, mes, year, dow); 
.................... 	rtc_get_time(hora, min, sec); 
.................... 	sprintf(dt, "%02d%02d%02d%02d%02d", year, mes, dia, hora, min);	 
.................... } 
....................  
.................... /*---------------------------------------------------------------------------------------------- 
.................... | CurrDateTime(void) | Obtiene la fecha y hora del rtc y lo convierte retorna en segundos 
.................... | Parametro: puntero a char destino de cadena 
.................... | RETURN VALUE: unsigned long (segundos) 
.................... -----------------------------------------------------------------------------------------------*/ 
.................... int32 CurrDateTime(void){ 
.................... 	BYTE  		hora, min, sec, dow, dia, mes, year; 
.................... 	TDateSt 	dt; 
....................  
.................... 	rtc_get_date(dia, mes, year, dow); 
.................... 	rtc_get_time(hora, min, sec); 
.................... 	// 
.................... 	sprintf(dtFecha, "%02d%02d%02d", year, mes, dia); 
*
126A:  MOVLW  01
126C:  MOVLB  1
126E:  MOVWF  x47
1270:  MOVLW  32
1272:  MOVWF  x46
1274:  MOVFF  371,3FD
1278:  MOVLW  01
127A:  MOVLB  3
127C:  MOVWF  xFE
127E:  MOVLB  0
1280:  RCALL  0D44
1282:  MOVFF  370,3FD
1286:  MOVLW  01
1288:  MOVLB  3
128A:  MOVWF  xFE
128C:  MOVLB  0
128E:  RCALL  0D44
1290:  MOVFF  36F,3FD
1294:  MOVLW  01
1296:  MOVLB  3
1298:  MOVWF  xFE
129A:  MOVLB  0
129C:  RCALL  0D44
.................... 	sprintf(dtHora, "%02d:%02d", hora, min); 
129E:  MOVLW  01
12A0:  MOVLB  1
12A2:  MOVWF  x47
12A4:  MOVLW  3C
12A6:  MOVWF  x46
12A8:  MOVFF  36B,3FD
12AC:  MOVLW  01
12AE:  MOVLB  3
12B0:  MOVWF  xFE
12B2:  MOVLB  0
12B4:  RCALL  0D44
12B6:  MOVLW  3A
12B8:  MOVLB  4
12BA:  MOVWF  x0D
12BC:  MOVLB  0
12BE:  RCALL  0D22
12C0:  MOVFF  36C,3FD
12C4:  MOVLW  01
12C6:  MOVLB  3
12C8:  MOVWF  xFE
12CA:  MOVLB  0
12CC:  RCALL  0D44
.................... 	// 
.................... 	dt.hour = hora; 
12CE:  MOVFF  36B,372
.................... 	dt.min = min; 
12D2:  MOVFF  36C,373
.................... 	dt.sec = sec; 
12D6:  MOVFF  36D,374
.................... 	dt.day = dia; 
12DA:  MOVFF  36F,375
.................... 	dt.mon = mes; 
12DE:  MOVFF  370,376
.................... 	dt.dow = dow; 
12E2:  MOVFF  36E,377
.................... 	dt.year = year + 2000; 
12E6:  MOVLW  D0
12E8:  MOVLB  3
12EA:  ADDWF  x71,W
12EC:  MOVWF  x78
12EE:  MOVLW  07
12F0:  MOVWF  x79
12F2:  BTFSC  FD8.0
12F4:  INCF   x79,F
.................... 	return Date2Sec(&dt); 
12F6:  MOVLW  03
12F8:  MOVWF  x7B
12FA:  MOVLW  72
12FC:  MOVWF  x7A
12FE:  MOVLB  0
1300:  BRA    0F08
.................... } 
1302:  RETLW  00
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... long LeerSmsCmd(char *sms) ; 
.................... void Leer_sensores(char prog); 
.................... void GenerateToken(void); 
.................... void clear_var(char* var); 
.................... void verifica_eeprom(void); 
.................... long EnviarSms(char *sms, char *tel); 
.................... float obtenerPresion(void); 
.................... char obtenerIntensidad(int32 seconds, float countPrec); 
.................... void calcularTempHum(float & temp, float & truehumid);  
.................... void inicializa_eeprom(void); 
.................... float obtenerTempInt(void); 
.................... void reinicioOK(void); 
.................... void construirTextoSms(char* sms, char prog); 
.................... void concatVariableSeparator(char* sms); 
....................  
.................... // ------------------ Comienzo código ----------------------------------- 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... char telnum[] = "+5493416527105"; 
.................... char sepVar[] = "*"; 
.................... //char telnum[] = "+5493415460866"; 
.................... //------------------- Variables usadas como Banderas ------------------- 
.................... short		flagInt2Edge; 
.................... long  		adc_val, countPrec, timeMed, timeMedTmp, currSmsId, timeChkTmp, timeChk, timeRestart;			//16bits 
.................... float 		ctePluv;		 
.................... int   		runOk, resProc, idLastSmsOut, memoryFull, smsMemSnd, startMeasure, startCheck, startRestart,llueveAhora; 
.................... int32  	    secUltMed;	 
.................... BYTE		sensorHab;	// Tiene el estado de los sensores habilitados 
.................... char  		tokenSrv[3], tokenEma[3], smsText[SZ_SMSTXT], smsOut[SZ_SMSTXT], telaux[SZ_TELEFONO], charFloat1[10]; 
.................... long  		address, contData; 
.................... BYTE		data, temp; 
....................  
.................... struct medSrt{ 
.................... 	int32	dateTime;			// 4 Bytes Fecha y hora en binario 
.................... 	float	humedad;			// 4 Bytes 
.................... 	float	tempExt;			// 4 bytes 
.................... 	float	precip;				// 4 Bytes 
.................... 	char	intensidad;			// 1 Bytes 
.................... 	float	preasure;			// 4 bytes 
.................... 	long	reservado;			// 1 byte (reservado) 
.................... };								// 22 Bytes 
....................  
.................... struct medSrt dataMed; 
.................... struct medSrt readMed; 
....................  
.................... #define SZ_DATALOG	sizeof(dataMed)		// Tamaño de los registro de log (20) 
....................  
.................... struct alarmaSt { 
.................... 	char	activa;				// Indica alarma activa 
.................... 	char	variable;			// Variable a ser monitoreada 
.................... 	float	max_value;			// Valor maximo que dispara alarma 
.................... 	float	min_value;			// Valor minimo que dispara alarma 
.................... 	int8	cnValid;			// Contador para validar alarma 
.................... };								// 1 + 1 + 4 + 4 + 1 = 11 bytes 
....................  
.................... struct alarmaSt alarm[5];			// Matriz de deficion de alarmas 55 bytes 
....................  
.................... #define SZ_ALRMSTR	55			// Tamaño registro de alarma 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... |  void ReadAlarmStruct(void)	Lee alarmas guardadas en eeprom interna 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void ReadAlarmStruct(void) 
.................... { 
.................... 	long	addtmp; 
.................... 	char	*p; 
.................... 	int		i; 
.................... 	 
.................... 	p = &alarm[0]; 
*
043A:  MOVLW  03
043C:  MOVLB  3
043E:  MOVWF  x57
0440:  MOVLW  18
0442:  MOVWF  x56
.................... 	addtmp = ADDR_ALARM; 
0444:  CLRF   x55
0446:  MOVLW  32
0448:  MOVWF  x54
.................... 	for (i = 0; i < SZ_ALRMSTR; i++){ 
044A:  CLRF   x58
044C:  MOVF   x58,W
044E:  SUBLW  36
0450:  BNC   0486
.................... 		*p = read_eeprom(addtmp); 
0452:  MOVFF  357,03
0456:  MOVF   x56,W
0458:  MOVWF  FE9
045A:  MOVFF  03,FEA
045E:  MOVFF  FF2,35B
0462:  BCF    FF2.7
0464:  MOVFF  354,FA9
0468:  BCF    FA6.6
046A:  BCF    FA6.7
046C:  BSF    FA6.0
046E:  MOVF   FA8,W
0470:  BTFSC  x5B.7
0472:  BSF    FF2.7
0474:  MOVWF  FEF
.................... 		p++; 
0476:  INCF   x56,F
0478:  BTFSC  FD8.2
047A:  INCF   x57,F
.................... 		addtmp++; 
047C:  INCF   x54,F
047E:  BTFSC  FD8.2
0480:  INCF   x55,F
.................... 	} 
0482:  INCF   x58,F
0484:  BRA    044C
.................... } 
0486:  MOVLB  0
0488:  GOTO   4D52 (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... |  void WriteAlarmStruct(void)	Escribe alarmas en eeprom interna 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void WriteAlarmStruct(void) 
.................... { 
.................... 	long	addtmp; 
.................... 	char	*p; 
.................... 	int		i; 
.................... 	 
.................... 	p = &alarm[0]; 
*
4A90:  MOVLW  03
4A92:  MOVLB  3
4A94:  MOVWF  x57
4A96:  MOVLW  18
4A98:  MOVWF  x56
.................... 	addtmp = ADDR_ALARM; 
4A9A:  CLRF   x55
4A9C:  MOVLW  32
4A9E:  MOVWF  x54
.................... 	for (i = 0; i < SZ_ALRMSTR; i++){ 
4AA0:  CLRF   x58
4AA2:  MOVF   x58,W
4AA4:  SUBLW  36
4AA6:  BNC   4AF4
.................... 		write_eeprom (addtmp, *p); 
4AA8:  MOVFF  357,03
4AAC:  MOVF   x56,W
4AAE:  MOVWF  FE9
4AB0:  MOVFF  03,FEA
4AB4:  MOVFF  FEF,359
4AB8:  MOVFF  354,FA9
4ABC:  MOVFF  359,FA8
4AC0:  BCF    FA6.6
4AC2:  BCF    FA6.7
4AC4:  BSF    FA6.2
4AC6:  MOVF   FF2,W
4AC8:  MOVWF  00
4ACA:  BCF    FF2.7
4ACC:  MOVLB  F
4ACE:  MOVLW  55
4AD0:  MOVWF  FA7
4AD2:  MOVLW  AA
4AD4:  MOVWF  FA7
4AD6:  BSF    FA6.1
4AD8:  BTFSC  FA6.1
4ADA:  BRA    4AD8
4ADC:  BCF    FA6.2
4ADE:  MOVF   00,W
4AE0:  IORWF  FF2,F
.................... 		p++; 
4AE2:  MOVLB  3
4AE4:  INCF   x56,F
4AE6:  BTFSC  FD8.2
4AE8:  INCF   x57,F
.................... 		addtmp++; 
4AEA:  INCF   x54,F
4AEC:  BTFSC  FD8.2
4AEE:  INCF   x55,F
.................... 	} 
4AF0:  INCF   x58,F
4AF2:  BRA    4AA2
.................... } 
4AF4:  MOVLB  0
4AF6:  GOTO   5122 (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | int CheckAlarmValues(void)   
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... int CheckAlarmValues(void) 
.................... { 
.................... 	int i, res; 
.................... 	char auxSms[10]; 
.................... 	Leer_sensores(1);						// Lee sensores 
*
309E:  MOVLW  01
30A0:  MOVLB  3
30A2:  MOVWF  x60
30A4:  MOVLB  0
30A6:  CALL   232E
.................... 	res = 0; 
30AA:  MOVLB  3
30AC:  CLRF   x55
.................... 	for (i = 0; i < 5; i++){ 
30AE:  CLRF   x54
30B0:  MOVF   x54,W
30B2:  SUBLW  04
30B4:  BTFSS  FD8.0
30B6:  BRA    377A
.................... 		if (alarm[i].activa){ 
30B8:  MOVF   x54,W
30BA:  MULLW  0B
30BC:  MOVF   FF3,W
30BE:  CLRF   x61
30C0:  MOVWF  x60
30C2:  MOVLW  18
30C4:  ADDWF  x60,W
30C6:  MOVWF  FE9
30C8:  MOVLW  03
30CA:  ADDWFC x61,W
30CC:  MOVWF  FEA
30CE:  MOVF   FEF,F
30D0:  BTFSC  FD8.2
30D2:  BRA    3772
.................... 			switch(alarm[i].variable){ 
30D4:  MOVF   x54,W
30D6:  MULLW  0B
30D8:  MOVF   FF3,W
30DA:  CLRF   x61
30DC:  MOVWF  x60
30DE:  MOVLW  01
30E0:  ADDWF  x60,W
30E2:  MOVWF  01
30E4:  MOVLW  00
30E6:  ADDWFC x61,W
30E8:  MOVWF  03
30EA:  MOVF   01,W
30EC:  ADDLW  18
30EE:  MOVWF  FE9
30F0:  MOVLW  03
30F2:  ADDWFC 03,W
30F4:  MOVWF  FEA
30F6:  MOVF   FEF,W
30F8:  XORLW  54
30FA:  MOVLB  0
30FC:  BZ    3112
30FE:  XORLW  1C
3100:  BTFSC  FD8.2
3102:  BRA    343E
3104:  XORLW  04
3106:  BTFSC  FD8.2
3108:  BRA    376A
310A:  XORLW  1C
310C:  BTFSC  FD8.2
310E:  BRA    376A
3110:  BRA    376A
.................... 				case 'T':					// Temperatura 
.................... 					if (dataMed.tempExt > alarm[i].max_value){		// Verifica condicion de maximo 
3112:  MOVLB  3
3114:  MOVF   x54,W
3116:  MULLW  0B
3118:  MOVF   FF3,W
311A:  CLRF   x61
311C:  MOVWF  x60
311E:  MOVLW  02
3120:  ADDWF  x60,W
3122:  MOVWF  01
3124:  MOVLW  00
3126:  ADDWFC x61,W
3128:  MOVWF  03
312A:  MOVF   01,W
312C:  ADDLW  18
312E:  MOVWF  FE9
3130:  MOVLW  03
3132:  ADDWFC 03,W
3134:  MOVWF  FEA
3136:  MOVFF  FEF,00
313A:  MOVFF  FEC,01
313E:  MOVFF  FEC,02
3142:  MOVFF  FEC,03
3146:  MOVFF  03,37A
314A:  MOVFF  02,379
314E:  MOVFF  01,378
3152:  MOVFF  00,377
3156:  MOVFF  2F5,37E
315A:  MOVFF  2F4,37D
315E:  MOVFF  2F3,37C
3162:  MOVFF  2F2,37B
3166:  MOVLB  0
3168:  CALL   1A38
316C:  BTFSS  FD8.0
316E:  BRA    3288
.................... 						alarm[i].cnValid++; 
3170:  MOVLB  3
3172:  MOVF   x54,W
3174:  MULLW  0B
3176:  MOVF   FF3,W
3178:  CLRF   x61
317A:  MOVWF  x60
317C:  MOVLW  0A
317E:  ADDWF  x60,W
3180:  MOVWF  01
3182:  MOVLW  00
3184:  ADDWFC x61,W
3186:  MOVWF  03
3188:  MOVF   01,W
318A:  ADDLW  18
318C:  MOVWF  FE9
318E:  MOVLW  03
3190:  ADDWFC 03,W
3192:  MOVWF  FEA
3194:  INCF   FEF,F
.................... 						if (alarm[i].cnValid > MAX_CNALARM){  
3196:  MOVF   x54,W
3198:  MULLW  0B
319A:  MOVF   FF3,W
319C:  CLRF   x61
319E:  MOVWF  x60
31A0:  MOVLW  0A
31A2:  ADDWF  x60,W
31A4:  MOVWF  01
31A6:  MOVLW  00
31A8:  ADDWFC x61,W
31AA:  MOVWF  03
31AC:  MOVF   01,W
31AE:  ADDLW  18
31B0:  MOVWF  FE9
31B2:  MOVLW  03
31B4:  ADDWFC 03,W
31B6:  MOVWF  FEA
31B8:  MOVF   FEF,W
31BA:  SUBLW  03
31BC:  BC    3284
.................... 							res = 0x01;							// Activa condicion de alarma por maximo 
31BE:  MOVLW  01
31C0:  MOVWF  x55
.................... 							alarm[i].cnValid = 0;					// Pone contador de condicion de alarma en 0 
31C2:  MOVF   x54,W
31C4:  MULLW  0B
31C6:  MOVF   FF3,W
31C8:  CLRF   x61
31CA:  MOVWF  x60
31CC:  MOVLW  0A
31CE:  ADDWF  x60,W
31D0:  MOVWF  01
31D2:  MOVLW  00
31D4:  ADDWFC x61,W
31D6:  MOVWF  03
31D8:  MOVF   01,W
31DA:  ADDLW  18
31DC:  MOVWF  FE9
31DE:  MOVLW  03
31E0:  ADDWFC 03,W
31E2:  MOVWF  FEA
31E4:  CLRF   FEF
.................... 							GenerateToken(); 
31E6:  MOVLB  0
31E8:  CALL   0E3E
.................... 							sprintf(auxSms, "%4f", dataMed.tempExt); 
31EC:  MOVLW  03
31EE:  MOVLB  1
31F0:  MOVWF  x47
31F2:  MOVLW  56
31F4:  MOVWF  x46
31F6:  MOVLW  89
31F8:  MOVWF  FE9
31FA:  MOVFF  2F5,3FF
31FE:  MOVFF  2F4,3FE
3202:  MOVFF  2F3,3FD
3206:  MOVFF  2F2,3FC
320A:  MOVLW  06
320C:  MOVLB  4
320E:  MOVWF  x00
3210:  MOVLB  0
3212:  CALL   29EE
.................... 							auxSms[4] = 0; 
3216:  MOVLB  3
3218:  CLRF   x5A
.................... 							sprintf(smsOut, "A|T|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
321A:  MOVLW  02
321C:  MOVLB  1
321E:  MOVWF  x47
3220:  MOVLW  27
3222:  MOVWF  x46
3224:  MOVLW  60
3226:  MOVWF  FF6
3228:  MOVLW  02
322A:  MOVWF  FF7
322C:  MOVLW  04
322E:  MOVLB  3
3230:  MOVWF  x60
3232:  MOVLB  0
3234:  CALL   1304
3238:  MOVLW  03
323A:  MOVWF  FEA
323C:  MOVLW  56
323E:  MOVWF  FE9
3240:  CALL   132C
3244:  MOVLW  7C
3246:  MOVLB  4
3248:  MOVWF  x0D
324A:  MOVLB  0
324C:  CALL   0D22
3250:  MOVFF  17F,40D
3254:  CALL   0D22
3258:  MOVFF  180,40D
325C:  CALL   0D22
.................... 							idLastSmsOut = EnviarSms(smsOut, telnum);	 
3260:  MOVLW  02
3262:  MOVLB  3
3264:  MOVWF  x61
3266:  MOVLW  27
3268:  MOVWF  x60
326A:  MOVLW  01
326C:  MOVWF  x63
326E:  MOVLW  48
3270:  MOVWF  x62
3272:  MOVLB  0
3274:  CALL   1380
3278:  MOVFF  01,170
.................... 							return res; 
327C:  MOVLB  3
327E:  MOVFF  355,01
3282:  BRA    377E
.................... 						} 
.................... 					} 
.................... 					else{  
3284:  BRA    343A
3286:  MOVLB  0
.................... 						if (dataMed.tempExt < alarm[i].min_value){	// Verifica condicion de minimo 
3288:  MOVLB  3
328A:  MOVF   x54,W
328C:  MULLW  0B
328E:  MOVF   FF3,W
3290:  CLRF   x61
3292:  MOVWF  x60
3294:  MOVLW  06
3296:  ADDWF  x60,W
3298:  MOVWF  01
329A:  MOVLW  00
329C:  ADDWFC x61,W
329E:  MOVWF  03
32A0:  MOVF   01,W
32A2:  ADDLW  18
32A4:  MOVWF  FE9
32A6:  MOVLW  03
32A8:  ADDWFC 03,W
32AA:  MOVWF  FEA
32AC:  MOVFF  FEF,00
32B0:  MOVFF  FEC,01
32B4:  MOVFF  FEC,02
32B8:  MOVFF  FEC,03
32BC:  MOVFF  2F5,37A
32C0:  MOVFF  2F4,379
32C4:  MOVFF  2F3,378
32C8:  MOVFF  2F2,377
32CC:  MOVFF  03,37E
32D0:  MOVFF  02,37D
32D4:  MOVFF  01,37C
32D8:  MOVFF  00,37B
32DC:  MOVLB  0
32DE:  CALL   1A38
32E2:  BTFSS  FD8.0
32E4:  BRA    3414
.................... 							alarm[i].cnValid--; 
32E6:  MOVLB  3
32E8:  MOVF   x54,W
32EA:  MULLW  0B
32EC:  MOVF   FF3,W
32EE:  CLRF   x61
32F0:  MOVWF  x60
32F2:  MOVLW  0A
32F4:  ADDWF  x60,W
32F6:  MOVWF  01
32F8:  MOVLW  00
32FA:  ADDWFC x61,W
32FC:  MOVWF  03
32FE:  MOVF   01,W
3300:  ADDLW  18
3302:  MOVWF  FE9
3304:  MOVLW  03
3306:  ADDWFC 03,W
3308:  MOVWF  FEA
330A:  DECF   FEF,F
.................... 							if ((alarm[i].cnValid * (-1)) > MAX_CNALARM){  
330C:  MOVF   x54,W
330E:  MULLW  0B
3310:  MOVF   FF3,W
3312:  CLRF   x61
3314:  MOVWF  x60
3316:  MOVLW  0A
3318:  ADDWF  x60,W
331A:  MOVWF  01
331C:  MOVLW  00
331E:  ADDWFC x61,W
3320:  MOVWF  03
3322:  MOVF   01,W
3324:  ADDLW  18
3326:  MOVWF  FE9
3328:  MOVLW  03
332A:  ADDWFC 03,W
332C:  MOVWF  FEA
332E:  MOVFF  FEF,404
3332:  MOVLW  FF
3334:  MOVLB  4
3336:  MOVWF  x05
3338:  MOVLB  0
333A:  CALL   0AF2
333E:  BTFSC  01.7
3340:  BRA    3412
3342:  MOVF   01,W
3344:  SUBLW  03
3346:  BC    3412
.................... 								res = 0x02;						// Activa condicion de alarma por mínimo 
3348:  MOVLW  02
334A:  MOVLB  3
334C:  MOVWF  x55
.................... 								alarm[i].cnValid = 0;				// Pone contador de condicion de alarma en 0 
334E:  MOVF   x54,W
3350:  MULLW  0B
3352:  MOVF   FF3,W
3354:  CLRF   x61
3356:  MOVWF  x60
3358:  MOVLW  0A
335A:  ADDWF  x60,W
335C:  MOVWF  01
335E:  MOVLW  00
3360:  ADDWFC x61,W
3362:  MOVWF  03
3364:  MOVF   01,W
3366:  ADDLW  18
3368:  MOVWF  FE9
336A:  MOVLW  03
336C:  ADDWFC 03,W
336E:  MOVWF  FEA
3370:  CLRF   FEF
.................... 								GenerateToken(); 
3372:  MOVLB  0
3374:  CALL   0E3E
.................... 								sprintf(auxSms, "%4f", dataMed.tempExt); 
3378:  MOVLW  03
337A:  MOVLB  1
337C:  MOVWF  x47
337E:  MOVLW  56
3380:  MOVWF  x46
3382:  MOVLW  89
3384:  MOVWF  FE9
3386:  MOVFF  2F5,3FF
338A:  MOVFF  2F4,3FE
338E:  MOVFF  2F3,3FD
3392:  MOVFF  2F2,3FC
3396:  MOVLW  06
3398:  MOVLB  4
339A:  MOVWF  x00
339C:  MOVLB  0
339E:  CALL   29EE
.................... 								auxSms[4] = 0; 
33A2:  MOVLB  3
33A4:  CLRF   x5A
.................... 								sprintf(smsOut, "A|T|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
33A6:  MOVLW  02
33A8:  MOVLB  1
33AA:  MOVWF  x47
33AC:  MOVLW  27
33AE:  MOVWF  x46
33B0:  MOVLW  6C
33B2:  MOVWF  FF6
33B4:  MOVLW  02
33B6:  MOVWF  FF7
33B8:  MOVLW  04
33BA:  MOVLB  3
33BC:  MOVWF  x60
33BE:  MOVLB  0
33C0:  CALL   1304
33C4:  MOVLW  03
33C6:  MOVWF  FEA
33C8:  MOVLW  56
33CA:  MOVWF  FE9
33CC:  CALL   132C
33D0:  MOVLW  7C
33D2:  MOVLB  4
33D4:  MOVWF  x0D
33D6:  MOVLB  0
33D8:  CALL   0D22
33DC:  MOVFF  17F,40D
33E0:  CALL   0D22
33E4:  MOVFF  180,40D
33E8:  CALL   0D22
.................... 								idLastSmsOut = EnviarSms(smsOut, telnum);	 
33EC:  MOVLW  02
33EE:  MOVLB  3
33F0:  MOVWF  x61
33F2:  MOVLW  27
33F4:  MOVWF  x60
33F6:  MOVLW  01
33F8:  MOVWF  x63
33FA:  MOVLW  48
33FC:  MOVWF  x62
33FE:  MOVLB  0
3400:  CALL   1380
3404:  MOVFF  01,170
.................... 								return res; 
3408:  MOVLB  3
340A:  MOVFF  355,01
340E:  BRA    377E
3410:  MOVLB  0
.................... 							} 
.................... 						} 
.................... 						else{ 
3412:  BRA    343C
.................... 							alarm[i].cnValid = 0;					// En estado normal pone contador de alarma en 0 
3414:  MOVLB  3
3416:  MOVF   x54,W
3418:  MULLW  0B
341A:  MOVF   FF3,W
341C:  CLRF   x61
341E:  MOVWF  x60
3420:  MOVLW  0A
3422:  ADDWF  x60,W
3424:  MOVWF  01
3426:  MOVLW  00
3428:  ADDWFC x61,W
342A:  MOVWF  03
342C:  MOVF   01,W
342E:  ADDLW  18
3430:  MOVWF  FE9
3432:  MOVLW  03
3434:  ADDWFC 03,W
3436:  MOVWF  FEA
3438:  CLRF   FEF
343A:  MOVLB  0
.................... 						} 
.................... 					} 
.................... 					break; 
343C:  BRA    3774
.................... 				case 'H':					// Humedad 
.................... 					if (dataMed.humedad > alarm[i].max_value){		// Verifica condicion de maximo 
343E:  MOVLB  3
3440:  MOVF   x54,W
3442:  MULLW  0B
3444:  MOVF   FF3,W
3446:  CLRF   x61
3448:  MOVWF  x60
344A:  MOVLW  02
344C:  ADDWF  x60,W
344E:  MOVWF  01
3450:  MOVLW  00
3452:  ADDWFC x61,W
3454:  MOVWF  03
3456:  MOVF   01,W
3458:  ADDLW  18
345A:  MOVWF  FE9
345C:  MOVLW  03
345E:  ADDWFC 03,W
3460:  MOVWF  FEA
3462:  MOVFF  FEF,00
3466:  MOVFF  FEC,01
346A:  MOVFF  FEC,02
346E:  MOVFF  FEC,03
3472:  MOVFF  03,37A
3476:  MOVFF  02,379
347A:  MOVFF  01,378
347E:  MOVFF  00,377
3482:  MOVFF  2F1,37E
3486:  MOVFF  2F0,37D
348A:  MOVFF  2EF,37C
348E:  MOVFF  2EE,37B
3492:  MOVLB  0
3494:  CALL   1A38
3498:  BTFSS  FD8.0
349A:  BRA    35B4
.................... 						alarm[i].cnValid++; 
349C:  MOVLB  3
349E:  MOVF   x54,W
34A0:  MULLW  0B
34A2:  MOVF   FF3,W
34A4:  CLRF   x61
34A6:  MOVWF  x60
34A8:  MOVLW  0A
34AA:  ADDWF  x60,W
34AC:  MOVWF  01
34AE:  MOVLW  00
34B0:  ADDWFC x61,W
34B2:  MOVWF  03
34B4:  MOVF   01,W
34B6:  ADDLW  18
34B8:  MOVWF  FE9
34BA:  MOVLW  03
34BC:  ADDWFC 03,W
34BE:  MOVWF  FEA
34C0:  INCF   FEF,F
.................... 						if (alarm[i].cnValid > MAX_CNALARM){  
34C2:  MOVF   x54,W
34C4:  MULLW  0B
34C6:  MOVF   FF3,W
34C8:  CLRF   x61
34CA:  MOVWF  x60
34CC:  MOVLW  0A
34CE:  ADDWF  x60,W
34D0:  MOVWF  01
34D2:  MOVLW  00
34D4:  ADDWFC x61,W
34D6:  MOVWF  03
34D8:  MOVF   01,W
34DA:  ADDLW  18
34DC:  MOVWF  FE9
34DE:  MOVLW  03
34E0:  ADDWFC 03,W
34E2:  MOVWF  FEA
34E4:  MOVF   FEF,W
34E6:  SUBLW  03
34E8:  BC    35B0
.................... 							res = 0x04;							// Activa condicion de alarma por maximo 
34EA:  MOVLW  04
34EC:  MOVWF  x55
.................... 							alarm[i].cnValid = 0; 
34EE:  MOVF   x54,W
34F0:  MULLW  0B
34F2:  MOVF   FF3,W
34F4:  CLRF   x61
34F6:  MOVWF  x60
34F8:  MOVLW  0A
34FA:  ADDWF  x60,W
34FC:  MOVWF  01
34FE:  MOVLW  00
3500:  ADDWFC x61,W
3502:  MOVWF  03
3504:  MOVF   01,W
3506:  ADDLW  18
3508:  MOVWF  FE9
350A:  MOVLW  03
350C:  ADDWFC 03,W
350E:  MOVWF  FEA
3510:  CLRF   FEF
.................... 							GenerateToken(); 
3512:  MOVLB  0
3514:  CALL   0E3E
.................... 							sprintf(auxSms, "%4f", dataMed.humedad); 
3518:  MOVLW  03
351A:  MOVLB  1
351C:  MOVWF  x47
351E:  MOVLW  56
3520:  MOVWF  x46
3522:  MOVLW  89
3524:  MOVWF  FE9
3526:  MOVFF  2F1,3FF
352A:  MOVFF  2F0,3FE
352E:  MOVFF  2EF,3FD
3532:  MOVFF  2EE,3FC
3536:  MOVLW  06
3538:  MOVLB  4
353A:  MOVWF  x00
353C:  MOVLB  0
353E:  CALL   29EE
.................... 							auxSms[4] = 0; 
3542:  MOVLB  3
3544:  CLRF   x5A
.................... 							sprintf(smsOut, "A|H|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
3546:  MOVLW  02
3548:  MOVLB  1
354A:  MOVWF  x47
354C:  MOVLW  27
354E:  MOVWF  x46
3550:  MOVLW  78
3552:  MOVWF  FF6
3554:  MOVLW  02
3556:  MOVWF  FF7
3558:  MOVLW  04
355A:  MOVLB  3
355C:  MOVWF  x60
355E:  MOVLB  0
3560:  CALL   1304
3564:  MOVLW  03
3566:  MOVWF  FEA
3568:  MOVLW  56
356A:  MOVWF  FE9
356C:  CALL   132C
3570:  MOVLW  7C
3572:  MOVLB  4
3574:  MOVWF  x0D
3576:  MOVLB  0
3578:  CALL   0D22
357C:  MOVFF  17F,40D
3580:  CALL   0D22
3584:  MOVFF  180,40D
3588:  CALL   0D22
.................... 							idLastSmsOut = EnviarSms(smsOut, telnum);	 
358C:  MOVLW  02
358E:  MOVLB  3
3590:  MOVWF  x61
3592:  MOVLW  27
3594:  MOVWF  x60
3596:  MOVLW  01
3598:  MOVWF  x63
359A:  MOVLW  48
359C:  MOVWF  x62
359E:  MOVLB  0
35A0:  CALL   1380
35A4:  MOVFF  01,170
.................... 							return res; 
35A8:  MOVLB  3
35AA:  MOVFF  355,01
35AE:  BRA    377E
.................... 						} 
.................... 					} 
.................... 					else{  
35B0:  BRA    3766
35B2:  MOVLB  0
.................... 						if (dataMed.humedad < alarm[i].min_value){	// Verifica condicion de minimo 
35B4:  MOVLB  3
35B6:  MOVF   x54,W
35B8:  MULLW  0B
35BA:  MOVF   FF3,W
35BC:  CLRF   x61
35BE:  MOVWF  x60
35C0:  MOVLW  06
35C2:  ADDWF  x60,W
35C4:  MOVWF  01
35C6:  MOVLW  00
35C8:  ADDWFC x61,W
35CA:  MOVWF  03
35CC:  MOVF   01,W
35CE:  ADDLW  18
35D0:  MOVWF  FE9
35D2:  MOVLW  03
35D4:  ADDWFC 03,W
35D6:  MOVWF  FEA
35D8:  MOVFF  FEF,00
35DC:  MOVFF  FEC,01
35E0:  MOVFF  FEC,02
35E4:  MOVFF  FEC,03
35E8:  MOVFF  2F1,37A
35EC:  MOVFF  2F0,379
35F0:  MOVFF  2EF,378
35F4:  MOVFF  2EE,377
35F8:  MOVFF  03,37E
35FC:  MOVFF  02,37D
3600:  MOVFF  01,37C
3604:  MOVFF  00,37B
3608:  MOVLB  0
360A:  CALL   1A38
360E:  BTFSS  FD8.0
3610:  BRA    3740
.................... 							alarm[i].cnValid--; 
3612:  MOVLB  3
3614:  MOVF   x54,W
3616:  MULLW  0B
3618:  MOVF   FF3,W
361A:  CLRF   x61
361C:  MOVWF  x60
361E:  MOVLW  0A
3620:  ADDWF  x60,W
3622:  MOVWF  01
3624:  MOVLW  00
3626:  ADDWFC x61,W
3628:  MOVWF  03
362A:  MOVF   01,W
362C:  ADDLW  18
362E:  MOVWF  FE9
3630:  MOVLW  03
3632:  ADDWFC 03,W
3634:  MOVWF  FEA
3636:  DECF   FEF,F
.................... 							if ((alarm[i].cnValid * (-1)) > MAX_CNALARM){  
3638:  MOVF   x54,W
363A:  MULLW  0B
363C:  MOVF   FF3,W
363E:  CLRF   x61
3640:  MOVWF  x60
3642:  MOVLW  0A
3644:  ADDWF  x60,W
3646:  MOVWF  01
3648:  MOVLW  00
364A:  ADDWFC x61,W
364C:  MOVWF  03
364E:  MOVF   01,W
3650:  ADDLW  18
3652:  MOVWF  FE9
3654:  MOVLW  03
3656:  ADDWFC 03,W
3658:  MOVWF  FEA
365A:  MOVFF  FEF,404
365E:  MOVLW  FF
3660:  MOVLB  4
3662:  MOVWF  x05
3664:  MOVLB  0
3666:  CALL   0AF2
366A:  BTFSC  01.7
366C:  BRA    373E
366E:  MOVF   01,W
3670:  SUBLW  03
3672:  BC    373E
.................... 								res = 0x10;						// Activa condicion de alarma por mínimo 
3674:  MOVLW  10
3676:  MOVLB  3
3678:  MOVWF  x55
.................... 								alarm[i].cnValid = 0; 
367A:  MOVF   x54,W
367C:  MULLW  0B
367E:  MOVF   FF3,W
3680:  CLRF   x61
3682:  MOVWF  x60
3684:  MOVLW  0A
3686:  ADDWF  x60,W
3688:  MOVWF  01
368A:  MOVLW  00
368C:  ADDWFC x61,W
368E:  MOVWF  03
3690:  MOVF   01,W
3692:  ADDLW  18
3694:  MOVWF  FE9
3696:  MOVLW  03
3698:  ADDWFC 03,W
369A:  MOVWF  FEA
369C:  CLRF   FEF
.................... 								GenerateToken(); 
369E:  MOVLB  0
36A0:  CALL   0E3E
.................... 								sprintf(auxSms, "%4f", dataMed.humedad); 
36A4:  MOVLW  03
36A6:  MOVLB  1
36A8:  MOVWF  x47
36AA:  MOVLW  56
36AC:  MOVWF  x46
36AE:  MOVLW  89
36B0:  MOVWF  FE9
36B2:  MOVFF  2F1,3FF
36B6:  MOVFF  2F0,3FE
36BA:  MOVFF  2EF,3FD
36BE:  MOVFF  2EE,3FC
36C2:  MOVLW  06
36C4:  MOVLB  4
36C6:  MOVWF  x00
36C8:  MOVLB  0
36CA:  CALL   29EE
.................... 								auxSms[4] = 0; 
36CE:  MOVLB  3
36D0:  CLRF   x5A
.................... 								sprintf(smsOut, "A|H|%s|%c%c", auxSms, tokenEma[0], tokenEma[1]); 
36D2:  MOVLW  02
36D4:  MOVLB  1
36D6:  MOVWF  x47
36D8:  MOVLW  27
36DA:  MOVWF  x46
36DC:  MOVLW  84
36DE:  MOVWF  FF6
36E0:  MOVLW  02
36E2:  MOVWF  FF7
36E4:  MOVLW  04
36E6:  MOVLB  3
36E8:  MOVWF  x60
36EA:  MOVLB  0
36EC:  CALL   1304
36F0:  MOVLW  03
36F2:  MOVWF  FEA
36F4:  MOVLW  56
36F6:  MOVWF  FE9
36F8:  CALL   132C
36FC:  MOVLW  7C
36FE:  MOVLB  4
3700:  MOVWF  x0D
3702:  MOVLB  0
3704:  CALL   0D22
3708:  MOVFF  17F,40D
370C:  CALL   0D22
3710:  MOVFF  180,40D
3714:  CALL   0D22
.................... 								idLastSmsOut = EnviarSms(smsOut, telnum);	 
3718:  MOVLW  02
371A:  MOVLB  3
371C:  MOVWF  x61
371E:  MOVLW  27
3720:  MOVWF  x60
3722:  MOVLW  01
3724:  MOVWF  x63
3726:  MOVLW  48
3728:  MOVWF  x62
372A:  MOVLB  0
372C:  CALL   1380
3730:  MOVFF  01,170
.................... 								return res; 
3734:  MOVLB  3
3736:  MOVFF  355,01
373A:  BRA    377E
373C:  MOVLB  0
.................... 							} 
.................... 						} 
.................... 						else{ 
373E:  BRA    3768
.................... 							alarm[i].cnValid = 0;					// En estado normal pone contador de alarma en 0 
3740:  MOVLB  3
3742:  MOVF   x54,W
3744:  MULLW  0B
3746:  MOVF   FF3,W
3748:  CLRF   x61
374A:  MOVWF  x60
374C:  MOVLW  0A
374E:  ADDWF  x60,W
3750:  MOVWF  01
3752:  MOVLW  00
3754:  ADDWFC x61,W
3756:  MOVWF  03
3758:  MOVF   01,W
375A:  ADDLW  18
375C:  MOVWF  FE9
375E:  MOVLW  03
3760:  ADDWFC 03,W
3762:  MOVWF  FEA
3764:  CLRF   FEF
3766:  MOVLB  0
.................... 						} 
.................... 					} 
.................... 					break; 
3768:  BRA    3774
.................... 				case 'L':					// Precipitacion 
.................... 				case 'P':					// Presion 
.................... 				default: 
.................... 					return 0; 
376A:  MOVLW  00
376C:  MOVWF  01
376E:  MOVLB  3
3770:  BRA    377E
3772:  MOVLB  0
.................... 			} 
.................... 		} 
.................... 	} 
3774:  MOVLB  3
3776:  INCF   x54,F
3778:  BRA    30B0
.................... 	return 0; 
377A:  MOVLW  00
377C:  MOVWF  01
.................... } 
377E:  MOVLB  0
3780:  GOTO   4F20 (RETURN)
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | char reinicioOK(void); 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void reinicioOK(void){ 
*
141A:  MOVF   FD0,W
141C:  ANDLW  0F
141E:  BTFSS  FD0.4
1420:  MOVLW  00
1422:  BSF    FD0.0
1424:  BSF    FD0.1
1426:  BSF    FD0.4
1428:  BSF    FD8.3
142A:  BSF    FD8.4
142C:  MOVLB  3
142E:  MOVWF  x54
.................... 	int cause = restart_cause(); 
.................... 	delay_ms(16000); 
1430:  MOVLW  40
1432:  MOVWF  x55
1434:  MOVLW  FA
1436:  MOVWF  x74
1438:  MOVLB  0
143A:  CALL   05D4
143E:  MOVLB  3
1440:  DECFSZ x55,F
1442:  BRA    1434
.................... 	output_bit(LED1, 0); 
1444:  BCF    F89.3
.................... 	output_bit(LED2, 1); 
1446:  BSF    F89.2
.................... 	GenerateToken(); 
1448:  MOVLB  0
144A:  RCALL  0E3E
.................... 	CurrDateTime(); 
144C:  RCALL  11B4
.................... 	sprintf(smsOut, "EST|%s|%s|ON|%i|%c%c",dtFecha, dtHora, cause, tokenEma[0], tokenEma[1]); 
144E:  MOVLW  02
1450:  MOVLB  1
1452:  MOVWF  x47
1454:  MOVLW  27
1456:  MOVWF  x46
1458:  MOVLW  90
145A:  MOVWF  FF6
145C:  MOVLW  02
145E:  MOVWF  FF7
1460:  MOVLW  04
1462:  MOVLB  3
1464:  MOVWF  x60
1466:  MOVLB  0
1468:  RCALL  1304
146A:  MOVLW  01
146C:  MOVWF  FEA
146E:  MOVLW  32
1470:  MOVWF  FE9
1472:  RCALL  132C
1474:  MOVLW  7C
1476:  MOVLB  4
1478:  MOVWF  x0D
147A:  MOVLB  0
147C:  RCALL  0D22
147E:  MOVLW  01
1480:  MOVWF  FEA
1482:  MOVLW  3C
1484:  MOVWF  FE9
1486:  RCALL  132C
1488:  MOVLW  99
148A:  MOVWF  FF6
148C:  MOVLW  02
148E:  MOVWF  FF7
1490:  MOVLW  04
1492:  MOVLB  3
1494:  MOVWF  x60
1496:  MOVLB  0
1498:  RCALL  1304
149A:  MOVFF  354,3FD
149E:  MOVLW  1F
14A0:  MOVLB  3
14A2:  MOVWF  xFE
14A4:  MOVLB  0
14A6:  RCALL  0D44
14A8:  MOVLW  7C
14AA:  MOVLB  4
14AC:  MOVWF  x0D
14AE:  MOVLB  0
14B0:  RCALL  0D22
14B2:  MOVFF  17F,40D
14B6:  RCALL  0D22
14B8:  MOVFF  180,40D
14BC:  RCALL  0D22
.................... 	EnviarSms(smsOut, telnum); 
14BE:  MOVLW  02
14C0:  MOVLB  3
14C2:  MOVWF  x61
14C4:  MOVLW  27
14C6:  MOVWF  x60
14C8:  MOVLW  01
14CA:  MOVWF  x63
14CC:  MOVLW  48
14CE:  MOVWF  x62
14D0:  MOVLB  0
14D2:  RCALL  1380
.................... } 
14D4:  GOTO   4DF2 (RETURN)
....................  
....................  
.................... //-------------------------------------------------------------------------------------------------------------- 
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void concatVariableSeparator(char* sms) 
.................... | Concatena el separador de variables * , si el texto no esta vacio 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void concatVariableSeparator(char* sms) 
.................... { 
.................... 	if(strlen(sms) != 0) { 
*
2C62:  MOVFF  3FD,3FF
2C66:  MOVFF  3FC,3FE
2C6A:  BRA    2C20
2C6C:  MOVF   01,F
2C6E:  BZ    2C86
.................... 	    strcat(sms,sepVar); 
2C70:  MOVFF  3FD,3FF
2C74:  MOVFF  3FC,3FE
2C78:  MOVLW  01
2C7A:  MOVLB  4
2C7C:  MOVWF  x01
2C7E:  MOVLW  57
2C80:  MOVWF  x00
2C82:  MOVLB  0
2C84:  RCALL  2BAC
.................... 	} 
.................... } 
2C86:  RETLW  00
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void construirTextoSms(char* sms, char prog) 
.................... | Construye el SMS a enviar dependiendo los sensores que estan habilitados o no 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void construirTextoSms(char* sms, char prog) 
.................... { 
.................... 	char auxVar[SZ_SMSTXT]; 
.................... 	clear_var(auxVar); 
2C88:  MOVLW  03
2C8A:  MOVLB  3
2C8C:  MOVWF  xFD
2C8E:  MOVLW  57
2C90:  MOVWF  xFC
2C92:  MOVLB  0
2C94:  CALL   0AD0
....................  
.................... 	if (sensorHab & TEMP_HUM_S){		// Sensor de temperatura y humedad habilitado ? 
2C98:  MOVLB  1
2C9A:  BTFSS  x7B.1
2C9C:  BRA    2D60
.................... 		//Temp 
.................... 		sprintf(charFloat1, "T:%2.1f",dataMed.tempExt); 
2C9E:  MOVLW  02
2CA0:  MOVWF  x47
2CA2:  MOVLW  DA
2CA4:  MOVWF  x46
2CA6:  MOVLW  54
2CA8:  MOVLB  4
2CAA:  MOVWF  x0D
2CAC:  MOVLB  0
2CAE:  CALL   0D22
2CB2:  MOVLW  3A
2CB4:  MOVLB  4
2CB6:  MOVWF  x0D
2CB8:  MOVLB  0
2CBA:  CALL   0D22
2CBE:  MOVLW  01
2CC0:  MOVWF  FE9
2CC2:  MOVFF  2F5,3FF
2CC6:  MOVFF  2F4,3FE
2CCA:  MOVFF  2F3,3FD
2CCE:  MOVFF  2F2,3FC
2CD2:  MOVLB  4
2CD4:  MOVWF  x00
2CD6:  MOVLB  0
2CD8:  RCALL  29EE
.................... 		charFloat1[6] = 0; 
2CDA:  MOVLB  2
2CDC:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2CDE:  MOVLW  03
2CE0:  MOVLB  3
2CE2:  MOVWF  xFF
2CE4:  MOVLW  57
2CE6:  MOVWF  xFE
2CE8:  MOVLW  02
2CEA:  MOVLB  4
2CEC:  MOVWF  x01
2CEE:  MOVLW  DA
2CF0:  MOVWF  x00
2CF2:  MOVLB  0
2CF4:  RCALL  2BAC
.................... 		//Humedad 
.................... 		concatVariableSeparator(auxVar); 
2CF6:  MOVLW  03
2CF8:  MOVLB  3
2CFA:  MOVWF  xFD
2CFC:  MOVLW  57
2CFE:  MOVWF  xFC
2D00:  MOVLB  0
2D02:  RCALL  2C62
.................... 	 	sprintf(charFloat1, "H:%2.1f",dataMed.humedad); 
2D04:  MOVLW  02
2D06:  MOVLB  1
2D08:  MOVWF  x47
2D0A:  MOVLW  DA
2D0C:  MOVWF  x46
2D0E:  MOVLW  48
2D10:  MOVLB  4
2D12:  MOVWF  x0D
2D14:  MOVLB  0
2D16:  CALL   0D22
2D1A:  MOVLW  3A
2D1C:  MOVLB  4
2D1E:  MOVWF  x0D
2D20:  MOVLB  0
2D22:  CALL   0D22
2D26:  MOVLW  01
2D28:  MOVWF  FE9
2D2A:  MOVFF  2F1,3FF
2D2E:  MOVFF  2F0,3FE
2D32:  MOVFF  2EF,3FD
2D36:  MOVFF  2EE,3FC
2D3A:  MOVLB  4
2D3C:  MOVWF  x00
2D3E:  MOVLB  0
2D40:  RCALL  29EE
.................... 		charFloat1[6] = 0; 
2D42:  MOVLB  2
2D44:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2D46:  MOVLW  03
2D48:  MOVLB  3
2D4A:  MOVWF  xFF
2D4C:  MOVLW  57
2D4E:  MOVWF  xFE
2D50:  MOVLW  02
2D52:  MOVLB  4
2D54:  MOVWF  x01
2D56:  MOVLW  DA
2D58:  MOVWF  x00
2D5A:  MOVLB  0
2D5C:  RCALL  2BAC
2D5E:  MOVLB  1
.................... 	} 
.................... 	if (sensorHab & RAINFALL_S){		// Sensor de precipitacion habilitado ? 
2D60:  BTFSS  x7B.2
2D62:  BRA    2E28
.................... 		//Precipitacion 
.................... 		concatVariableSeparator(auxVar); 
2D64:  MOVLW  03
2D66:  MOVLB  3
2D68:  MOVWF  xFD
2D6A:  MOVLW  57
2D6C:  MOVWF  xFC
2D6E:  MOVLB  0
2D70:  RCALL  2C62
.................... 		sprintf(charFloat1, "L:%2.1f", dataMed.precip); 
2D72:  MOVLW  02
2D74:  MOVLB  1
2D76:  MOVWF  x47
2D78:  MOVLW  DA
2D7A:  MOVWF  x46
2D7C:  MOVLW  4C
2D7E:  MOVLB  4
2D80:  MOVWF  x0D
2D82:  MOVLB  0
2D84:  CALL   0D22
2D88:  MOVLW  3A
2D8A:  MOVLB  4
2D8C:  MOVWF  x0D
2D8E:  MOVLB  0
2D90:  CALL   0D22
2D94:  MOVLW  01
2D96:  MOVWF  FE9
2D98:  MOVFF  2F9,3FF
2D9C:  MOVFF  2F8,3FE
2DA0:  MOVFF  2F7,3FD
2DA4:  MOVFF  2F6,3FC
2DA8:  MOVLB  4
2DAA:  MOVWF  x00
2DAC:  MOVLB  0
2DAE:  RCALL  29EE
.................... 		charFloat1[6] = 0; 
2DB0:  MOVLB  2
2DB2:  CLRF   xE0
.................... 		strcat(auxVar,charFloat1); 
2DB4:  MOVLW  03
2DB6:  MOVLB  3
2DB8:  MOVWF  xFF
2DBA:  MOVLW  57
2DBC:  MOVWF  xFE
2DBE:  MOVLW  02
2DC0:  MOVLB  4
2DC2:  MOVWF  x01
2DC4:  MOVLW  DA
2DC6:  MOVWF  x00
2DC8:  MOVLB  0
2DCA:  RCALL  2BAC
.................... 		if (llueveAhora) {	      //Si llueveAhora = 1, mandar intensidad	 
2DCC:  MOVLB  1
2DCE:  MOVF   x76,F
2DD0:  BZ    2E28
.................... 			//Intensidad 
.................... 			concatVariableSeparator(auxVar); 
2DD2:  MOVLW  03
2DD4:  MOVLB  3
2DD6:  MOVWF  xFD
2DD8:  MOVLW  57
2DDA:  MOVWF  xFC
2DDC:  MOVLB  0
2DDE:  RCALL  2C62
.................... 			sprintf(charFloat1, "I:%c", dataMed.intensidad); 
2DE0:  MOVLW  02
2DE2:  MOVLB  1
2DE4:  MOVWF  x47
2DE6:  MOVLW  DA
2DE8:  MOVWF  x46
2DEA:  MOVLW  49
2DEC:  MOVLB  4
2DEE:  MOVWF  x0D
2DF0:  MOVLB  0
2DF2:  CALL   0D22
2DF6:  MOVLW  3A
2DF8:  MOVLB  4
2DFA:  MOVWF  x0D
2DFC:  MOVLB  0
2DFE:  CALL   0D22
2E02:  MOVFF  2FA,40D
2E06:  CALL   0D22
.................... 			charFloat1[3] = 0; 
2E0A:  MOVLB  2
2E0C:  CLRF   xDD
.................... 			strcat(auxVar,charFloat1); 
2E0E:  MOVLW  03
2E10:  MOVLB  3
2E12:  MOVWF  xFF
2E14:  MOVLW  57
2E16:  MOVWF  xFE
2E18:  MOVLW  02
2E1A:  MOVLB  4
2E1C:  MOVWF  x01
2E1E:  MOVLW  DA
2E20:  MOVWF  x00
2E22:  MOVLB  0
2E24:  RCALL  2BAC
2E26:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & PREASURE_S){		// Sensor de presion habilitado ? 
2E28:  BTFSS  x7B.3
2E2A:  BRA    2E96
.................... 		//Presion 
.................... 		concatVariableSeparator(auxVar); 
2E2C:  MOVLW  03
2E2E:  MOVLB  3
2E30:  MOVWF  xFD
2E32:  MOVLW  57
2E34:  MOVWF  xFC
2E36:  MOVLB  0
2E38:  RCALL  2C62
.................... 		sprintf(charFloat1, "P:%4.1f", dataMed.preasure); 
2E3A:  MOVLW  02
2E3C:  MOVLB  1
2E3E:  MOVWF  x47
2E40:  MOVLW  DA
2E42:  MOVWF  x46
2E44:  MOVLW  50
2E46:  MOVLB  4
2E48:  MOVWF  x0D
2E4A:  MOVLB  0
2E4C:  CALL   0D22
2E50:  MOVLW  3A
2E52:  MOVLB  4
2E54:  MOVWF  x0D
2E56:  MOVLB  0
2E58:  CALL   0D22
2E5C:  MOVLW  03
2E5E:  MOVWF  FE9
2E60:  MOVFF  2FE,3FF
2E64:  MOVFF  2FD,3FE
2E68:  MOVFF  2FC,3FD
2E6C:  MOVFF  2FB,3FC
2E70:  MOVLW  01
2E72:  MOVLB  4
2E74:  MOVWF  x00
2E76:  MOVLB  0
2E78:  RCALL  29EE
.................... 		charFloat1[8] = 0; 
2E7A:  MOVLB  2
2E7C:  CLRF   xE2
.................... 		strcat(auxVar,charFloat1); 
2E7E:  MOVLW  03
2E80:  MOVLB  3
2E82:  MOVWF  xFF
2E84:  MOVLW  57
2E86:  MOVWF  xFE
2E88:  MOVLW  02
2E8A:  MOVLB  4
2E8C:  MOVWF  x01
2E8E:  MOVLW  DA
2E90:  MOVWF  x00
2E92:  MOVLB  0
2E94:  RCALL  2BAC
.................... 	} 
.................... 	 
.................... 	clear_var(sms); 
2E96:  MOVFF  355,3FD
2E9A:  MOVFF  354,3FC
2E9E:  MOVLB  0
2EA0:  CALL   0AD0
.................... 	if (prog){						// Si es programada es <> 0  
2EA4:  MOVLB  3
2EA6:  MOVF   x56,F
2EA8:  BZ    2F2C
.................... 		GenerateToken(); 
2EAA:  MOVLB  0
2EAC:  CALL   0E3E
.................... 		sprintf(sms, "D|%s|%s|%s|%c%c",dtFecha, dtHora, auxVar, tokenEma[0], tokenEma[1]);	 
2EB0:  MOVFF  355,147
2EB4:  MOVFF  354,146
2EB8:  MOVLW  44
2EBA:  MOVLB  4
2EBC:  MOVWF  x0D
2EBE:  MOVLB  0
2EC0:  CALL   0D22
2EC4:  MOVLW  7C
2EC6:  MOVLB  4
2EC8:  MOVWF  x0D
2ECA:  MOVLB  0
2ECC:  CALL   0D22
2ED0:  MOVLW  01
2ED2:  MOVWF  FEA
2ED4:  MOVLW  32
2ED6:  MOVWF  FE9
2ED8:  CALL   132C
2EDC:  MOVLW  7C
2EDE:  MOVLB  4
2EE0:  MOVWF  x0D
2EE2:  MOVLB  0
2EE4:  CALL   0D22
2EE8:  MOVLW  01
2EEA:  MOVWF  FEA
2EEC:  MOVLW  3C
2EEE:  MOVWF  FE9
2EF0:  CALL   132C
2EF4:  MOVLW  7C
2EF6:  MOVLB  4
2EF8:  MOVWF  x0D
2EFA:  MOVLB  0
2EFC:  CALL   0D22
2F00:  MOVLW  03
2F02:  MOVWF  FEA
2F04:  MOVLW  57
2F06:  MOVWF  FE9
2F08:  CALL   132C
2F0C:  MOVLW  7C
2F0E:  MOVLB  4
2F10:  MOVWF  x0D
2F12:  MOVLB  0
2F14:  CALL   0D22
2F18:  MOVFF  17F,40D
2F1C:  CALL   0D22
2F20:  MOVFF  180,40D
2F24:  CALL   0D22
.................... 	}else{ 
2F28:  BRA    2FA4
2F2A:  MOVLB  3
.................... 		sprintf(sms, "R|%s|%s|%s|%c%c",dtFecha, dtHora, auxVar, tokenSrv[0], tokenSrv[1]); 
2F2C:  MOVFF  355,147
2F30:  MOVFF  354,146
2F34:  MOVLW  52
2F36:  MOVLB  4
2F38:  MOVWF  x0D
2F3A:  MOVLB  0
2F3C:  CALL   0D22
2F40:  MOVLW  7C
2F42:  MOVLB  4
2F44:  MOVWF  x0D
2F46:  MOVLB  0
2F48:  CALL   0D22
2F4C:  MOVLW  01
2F4E:  MOVWF  FEA
2F50:  MOVLW  32
2F52:  MOVWF  FE9
2F54:  CALL   132C
2F58:  MOVLW  7C
2F5A:  MOVLB  4
2F5C:  MOVWF  x0D
2F5E:  MOVLB  0
2F60:  CALL   0D22
2F64:  MOVLW  01
2F66:  MOVWF  FEA
2F68:  MOVLW  3C
2F6A:  MOVWF  FE9
2F6C:  CALL   132C
2F70:  MOVLW  7C
2F72:  MOVLB  4
2F74:  MOVWF  x0D
2F76:  MOVLB  0
2F78:  CALL   0D22
2F7C:  MOVLW  03
2F7E:  MOVWF  FEA
2F80:  MOVLW  57
2F82:  MOVWF  FE9
2F84:  CALL   132C
2F88:  MOVLW  7C
2F8A:  MOVLB  4
2F8C:  MOVWF  x0D
2F8E:  MOVLB  0
2F90:  CALL   0D22
2F94:  MOVFF  17C,40D
2F98:  CALL   0D22
2F9C:  MOVFF  17D,40D
2FA0:  CALL   0D22
.................... 	} 
.................... } 
2FA4:  RETLW  00
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | void calcularTempHum(float & temp, float & truehumid);  
.................... | Calcula la temperatura y humedad haciendo promedios KTESHT_QTY 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... void calcularTempHum(float & temp, float & truehumid) 
.................... { 
.................... 	float acumTemp = 0; 
.................... 	float acumHum = 0; 
.................... 	char i; 
.................... 	for (i = 0; i < KTESHT_QTY; i++){ 
.................... 		float auxTemp; 
.................... 		float auxHum; 
.................... 		sht_rd(auxTemp, auxHum); 
.................... 		acumTemp = acumTemp + auxTemp; 
.................... 		acumHum = acumHum + auxHum; 
.................... 	} 
.................... 	temp = acumTemp/KTESHT_QTY; 
.................... 	truehumid = acumHum/KTESHT_QTY; 
.................... } 
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | float obtenerPresion(void) 
.................... | 
.................... | 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... float obtenerPresion(void) 
.................... { 
*
219A:  MOVLB  3
219C:  CLRF   x6E
219E:  CLRF   x6D
21A0:  CLRF   x6C
21A2:  CLRF   x6B
.................... 	float acum = 0; 
.................... 	float pre; 
.................... 	set_adc_channel(0); 
21A4:  MOVLW  00
21A6:  MOVWF  01
21A8:  MOVF   FC2,W
21AA:  ANDLW  C7
21AC:  IORWF  01,W
21AE:  MOVWF  FC2
.................... 	delay_ms(20); 
21B0:  MOVLW  14
21B2:  MOVWF  x74
21B4:  MOVLB  0
21B6:  CALL   05D4
.................... 	char i; 
.................... 	for (i = 0; i < KTEMPX_QTY; i++){ 
21BA:  MOVLB  3
21BC:  CLRF   x73
21BE:  MOVF   x73,W
21C0:  SUBLW  0E
21C2:  BNC   22B8
.................... 		adc_val = read_adc(); 
21C4:  BSF    FC2.2
21C6:  BTFSC  FC2.2
21C8:  BRA    21C6
21CA:  MOVFF  FC4,15B
21CE:  MOVLB  1
21D0:  MOVFF  FC3,15A
.................... 		while(!adc_done()); 
21D4:  BTFSC  FC2.2
21D6:  BRA    21D4
.................... 		acum = acum + (float) ((adc_val * KTEMPX) + 10.56)*10;		//*10 kPa a Hpa	// Lee presion del MPX 
21D8:  MOVFF  15B,3A6
21DC:  MOVFF  15A,3A5
21E0:  MOVLB  0
21E2:  CALL   1694
21E6:  MOVFF  03,410
21EA:  MOVFF  02,40F
21EE:  MOVFF  01,40E
21F2:  MOVFF  00,40D
21F6:  MOVLW  D2
21F8:  MOVLB  4
21FA:  MOVWF  x14
21FC:  MOVLW  6F
21FE:  MOVWF  x13
2200:  MOVLW  5F
2202:  MOVWF  x12
2204:  MOVLW  7B
2206:  MOVWF  x11
2208:  MOVLB  0
220A:  CALL   16CA
220E:  MOVFF  00,374
2212:  MOVFF  01,375
2216:  MOVFF  02,376
221A:  MOVFF  03,377
221E:  BCF    FD8.1
2220:  MOVFF  03,3A8
2224:  MOVFF  02,3A7
2228:  MOVFF  01,3A6
222C:  MOVFF  00,3A5
2230:  MOVLW  C3
2232:  MOVLB  3
2234:  MOVWF  xAC
2236:  MOVLW  F5
2238:  MOVWF  xAB
223A:  MOVLW  28
223C:  MOVWF  xAA
223E:  MOVLW  82
2240:  MOVWF  xA9
2242:  MOVLB  0
2244:  CALL   17C0
2248:  MOVFF  00,374
224C:  MOVFF  01,375
2250:  MOVFF  02,376
2254:  MOVFF  03,377
2258:  MOVFF  03,410
225C:  MOVFF  02,40F
2260:  MOVFF  01,40E
2264:  MOVFF  00,40D
2268:  MOVLB  4
226A:  CLRF   x14
226C:  CLRF   x13
226E:  MOVLW  20
2270:  MOVWF  x12
2272:  MOVLW  82
2274:  MOVWF  x11
2276:  MOVLB  0
2278:  CALL   16CA
227C:  BCF    FD8.1
227E:  MOVFF  36E,3A8
2282:  MOVFF  36D,3A7
2286:  MOVFF  36C,3A6
228A:  MOVFF  36B,3A5
228E:  MOVFF  03,3AC
2292:  MOVFF  02,3AB
2296:  MOVFF  01,3AA
229A:  MOVFF  00,3A9
229E:  CALL   17C0
22A2:  MOVFF  03,36E
22A6:  MOVFF  02,36D
22AA:  MOVFF  01,36C
22AE:  MOVFF  00,36B
.................... 	} 
22B2:  MOVLB  3
22B4:  INCF   x73,F
22B6:  BRA    21BE
.................... 	pre = ((acum/KTEMPX_QTY) + KTEMPX_CORR); 
22B8:  MOVFF  36E,3A8
22BC:  MOVFF  36D,3A7
22C0:  MOVFF  36C,3A6
22C4:  MOVFF  36B,3A5
22C8:  CLRF   xAC
22CA:  CLRF   xAB
22CC:  MOVLW  70
22CE:  MOVWF  xAA
22D0:  MOVLW  82
22D2:  MOVWF  xA9
22D4:  MOVLB  0
22D6:  RCALL  203C
22D8:  MOVFF  00,374
22DC:  MOVFF  01,375
22E0:  MOVFF  02,376
22E4:  MOVFF  03,377
22E8:  BCF    FD8.1
22EA:  MOVFF  03,3A8
22EE:  MOVFF  02,3A7
22F2:  MOVFF  01,3A6
22F6:  MOVFF  00,3A5
22FA:  MOVLB  3
22FC:  CLRF   xAC
22FE:  CLRF   xAB
2300:  CLRF   xAA
2302:  CLRF   xA9
2304:  MOVLB  0
2306:  CALL   17C0
230A:  MOVFF  03,372
230E:  MOVFF  02,371
2312:  MOVFF  01,370
2316:  MOVFF  00,36F
.................... 	return pre; 
231A:  MOVFF  36F,00
231E:  MOVFF  370,01
2322:  MOVFF  371,02
2326:  MOVFF  372,03
.................... } 
232A:  GOTO   27A8 (RETURN)
....................  
.................... /*-------------------------------------------------------------------------------------------------------------- 
.................... | char obtenerIntensidad(int32 seconds, float countPrec) 
.................... | Obtiene la intensidad de la lluvia teniendo en cuenta los umbrales definidos de debil, moderado, fuerte,  
.................... | muy fuerte y torrencial 
.................... --------------------------------------------------------------------------------------------------------------*/ 
.................... char obtenerIntensidad(int32 seconds, float countPrec) 
.................... { 
.................... 	if ( countPrec == 0 ) { 
*
1B6C:  MOVFF  372,37A
1B70:  MOVFF  371,379
1B74:  MOVFF  370,378
1B78:  MOVFF  36F,377
1B7C:  MOVLB  3
1B7E:  CLRF   x7E
1B80:  CLRF   x7D
1B82:  CLRF   x7C
1B84:  CLRF   x7B
1B86:  MOVLB  0
1B88:  RCALL  1A38
1B8A:  BNZ   1B94
.................... 		return 'X';	 
1B8C:  MOVLW  58
1B8E:  MOVWF  01
1B90:  BRA    1D1C
.................... 	} else {	 
1B92:  BRA    1D1C
.................... 		float ratio = seconds/K_TIME_MED; 
1B94:  MOVFF  36E,410
1B98:  MOVFF  36D,40F
1B9C:  MOVFF  36C,40E
1BA0:  MOVFF  36B,40D
1BA4:  MOVLB  4
1BA6:  CLRF   x14
1BA8:  CLRF   x13
1BAA:  MOVLW  06
1BAC:  MOVWF  x12
1BAE:  MOVLW  CC
1BB0:  MOVWF  x11
1BB2:  MOVLB  0
1BB4:  RCALL  1AB2
1BB6:  MOVFF  03,37A
1BBA:  MOVFF  02,379
1BBE:  MOVFF  01,378
1BC2:  MOVFF  00,377
1BC6:  BRA    1B32
1BC8:  MOVFF  03,376
1BCC:  MOVFF  02,375
1BD0:  MOVFF  01,374
1BD4:  MOVFF  00,373
.................... 		if ( countPrec <= (U_DEBIL*ratio) ) { 
1BD8:  MOVLB  4
1BDA:  CLRF   x10
1BDC:  CLRF   x0F
1BDE:  CLRF   x0E
1BE0:  MOVLW  7F
1BE2:  MOVWF  x0D
1BE4:  MOVFF  376,414
1BE8:  MOVFF  375,413
1BEC:  MOVFF  374,412
1BF0:  MOVFF  373,411
1BF4:  MOVLB  0
1BF6:  RCALL  16CA
1BF8:  MOVFF  372,37A
1BFC:  MOVFF  371,379
1C00:  MOVFF  370,378
1C04:  MOVFF  36F,377
1C08:  MOVFF  03,37E
1C0C:  MOVFF  02,37D
1C10:  MOVFF  01,37C
1C14:  MOVFF  00,37B
1C18:  RCALL  1A38
1C1A:  BC    1C1E
1C1C:  BNZ   1C26
.................... 			return '0'; 
1C1E:  MOVLW  30
1C20:  MOVWF  01
1C22:  BRA    1D1C
.................... 		} else  { 
1C24:  BRA    1D1C
.................... 	        	if ( countPrec <= (U_MOD*ratio) ) { 
1C26:  MOVLB  4
1C28:  CLRF   x10
1C2A:  CLRF   x0F
1C2C:  MOVLW  70
1C2E:  MOVWF  x0E
1C30:  MOVLW  81
1C32:  MOVWF  x0D
1C34:  MOVFF  376,414
1C38:  MOVFF  375,413
1C3C:  MOVFF  374,412
1C40:  MOVFF  373,411
1C44:  MOVLB  0
1C46:  RCALL  16CA
1C48:  MOVFF  372,37A
1C4C:  MOVFF  371,379
1C50:  MOVFF  370,378
1C54:  MOVFF  36F,377
1C58:  MOVFF  03,37E
1C5C:  MOVFF  02,37D
1C60:  MOVFF  01,37C
1C64:  MOVFF  00,37B
1C68:  RCALL  1A38
1C6A:  BC    1C6E
1C6C:  BNZ   1C76
.................... 				return '1'; 
1C6E:  MOVLW  31
1C70:  MOVWF  01
1C72:  BRA    1D1C
.................... 			} else { 
1C74:  BRA    1D1C
.................... 				if ( countPrec <= (U_FUERTE*ratio) ) { 
1C76:  MOVLB  4
1C78:  CLRF   x10
1C7A:  CLRF   x0F
1C7C:  MOVLW  70
1C7E:  MOVWF  x0E
1C80:  MOVLW  82
1C82:  MOVWF  x0D
1C84:  MOVFF  376,414
1C88:  MOVFF  375,413
1C8C:  MOVFF  374,412
1C90:  MOVFF  373,411
1C94:  MOVLB  0
1C96:  RCALL  16CA
1C98:  MOVFF  372,37A
1C9C:  MOVFF  371,379
1CA0:  MOVFF  370,378
1CA4:  MOVFF  36F,377
1CA8:  MOVFF  03,37E
1CAC:  MOVFF  02,37D
1CB0:  MOVFF  01,37C
1CB4:  MOVFF  00,37B
1CB8:  RCALL  1A38
1CBA:  BC    1CBE
1CBC:  BNZ   1CC6
.................... 					return '2'; 
1CBE:  MOVLW  32
1CC0:  MOVWF  01
1CC2:  BRA    1D1C
.................... 				} else { 
1CC4:  BRA    1D1C
.................... 					if ( countPrec <= (U_MUYFUERTE*ratio) ) { 
1CC6:  MOVLB  4
1CC8:  CLRF   x10
1CCA:  CLRF   x0F
1CCC:  MOVLW  70
1CCE:  MOVWF  x0E
1CD0:  MOVLW  83
1CD2:  MOVWF  x0D
1CD4:  MOVFF  376,414
1CD8:  MOVFF  375,413
1CDC:  MOVFF  374,412
1CE0:  MOVFF  373,411
1CE4:  MOVLB  0
1CE6:  RCALL  16CA
1CE8:  MOVFF  372,37A
1CEC:  MOVFF  371,379
1CF0:  MOVFF  370,378
1CF4:  MOVFF  36F,377
1CF8:  MOVFF  03,37E
1CFC:  MOVFF  02,37D
1D00:  MOVFF  01,37C
1D04:  MOVFF  00,37B
1D08:  RCALL  1A38
1D0A:  BC    1D0E
1D0C:  BNZ   1D16
.................... 						return '3'; 
1D0E:  MOVLW  33
1D10:  MOVWF  01
1D12:  BRA    1D1C
.................... 					} else { 
1D14:  BRA    1D1C
.................... 						return '4'; 
1D16:  MOVLW  34
1D18:  MOVWF  01
1D1A:  BRA    1D1C
.................... 					} 
.................... 				} 
.................... 			} 
....................     		} 
.................... 	} 
.................... } 
1D1C:  RETLW  00
....................  
.................... //-------------------------------------------------------------------------------------------------------------- 
.................... //--------------------------------------- Rutinas que atienden las interrupciones ------------------------------ 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
.................... 	timeMedTmp--; 
*
02A6:  MOVLB  1
02A8:  MOVF   x60,W
02AA:  BTFSC  FD8.2
02AC:  DECF   x61,F
02AE:  DECF   x60,F
.................... 	if (timeMedTmp == 0){ 
02B0:  MOVF   x60,F
02B2:  BNZ   02C4
02B4:  MOVF   x61,F
02B6:  BNZ   02C4
.................... 		timeMedTmp = timeMed; 
02B8:  MOVFF  15F,161
02BC:  MOVFF  15E,160
.................... 		startMeasure = 1;			// Indica iniciar lectura de sensores 
02C0:  MOVLW  01
02C2:  MOVWF  x73
.................... 	} 	 
.................... 	timeChkTmp--; 
02C4:  MOVF   x64,W
02C6:  BTFSC  FD8.2
02C8:  DECF   x65,F
02CA:  DECF   x64,F
.................... 	if (timeChkTmp == 0){ 
02CC:  MOVF   x64,F
02CE:  BNZ   02E0
02D0:  MOVF   x65,F
02D2:  BNZ   02E0
.................... 		timeChkTmp = timeChk; 
02D4:  MOVFF  167,165
02D8:  MOVFF  166,164
.................... 		startCheck = 1;				// Indica iniciar lectura de variables de estado 
02DC:  MOVLW  01
02DE:  MOVWF  x74
.................... 	} 
.................... 	timeRestart--; 
02E0:  MOVF   x68,W
02E2:  BTFSC  FD8.2
02E4:  DECF   x69,F
02E6:  DECF   x68,F
.................... 	if (timeRestart == 0){ 
02E8:  MOVF   x68,F
02EA:  BNZ   02FC
02EC:  MOVF   x69,F
02EE:  BNZ   02FC
.................... 		timeRestart = K_TIME_RESTART; 
02F0:  MOVLW  17
02F2:  MOVWF  x69
02F4:  MOVLW  70
02F6:  MOVWF  x68
.................... 		startRestart = 1;				// Indica iniciar lectura de variables de estado 
02F8:  MOVLW  01
02FA:  MOVWF  x75
.................... 	} 
.................... } 
....................  
02FC:  BCF    FF2.2
02FE:  MOVLB  0
0300:  GOTO   006C
.................... #int_EXT2 
.................... void  EXT2_isr(void){				// Rutina de atencion a la interrupcion del pluviometro 
.................... 	if (flagInt2Edge == 0){   		// Flanco de Subida 
0304:  MOVLB  1
0306:  BTFSC  x59.0
0308:  BRA    0318
....................   		ext_int_edge(2, H_TO_L);  	// Configuro flanco de Bajada 
030A:  BCF    FF1.4
....................   		flagInt2Edge = 1;    		// Indico que el siguiente flanco será de Bajada 
030C:  BSF    x59.0
.................... 		countPrec++; 
030E:  INCF   x5C,F
0310:  BTFSC  FD8.2
0312:  INCF   x5D,F
.................... 	    output_bit(LED1, 1); 
0314:  BSF    F89.3
....................  	}  
.................... 	else {           				// Flanco de Bajada 
0316:  BRA    031E
....................    		ext_int_edge(2, L_TO_H);  	// Configuro flanco de subida 
0318:  BSF    FF1.4
....................   		flagInt2Edge = 0;    		// Indico que el siguiente flanco será de Subida 
031A:  BCF    x59.0
.................... 	    output_bit(LED1, 0); 
031C:  BCF    F89.3
....................  	} 
.................... } 
.................... //--------------------------------------------------------------------------------------------- 
....................  
.................... //Recepción de datos de modem gsm 
031E:  BCF    FF0.1
0320:  MOVLB  0
0322:  GOTO   006C
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
.................... 	  if(kbhit(SIM300)){ 
*
033E:  BTFSS  F9E.5
0340:  BRA    0386
.................... 	    if (buf_index < BUFFER_SIZE){  
0342:  MOVLB  1
0344:  INCFSZ x17,W
0346:  BRA    034A
0348:  BRA    0384
.................... 		    buffer[buf_index]=fgetc(SIM300); 
034A:  CLRF   03
034C:  MOVF   x17,W
034E:  ADDLW  17
0350:  MOVWF  FE9
0352:  MOVLW  00
0354:  ADDWFC 03,W
0356:  MOVWF  FEA
0358:  MOVFF  FEA,422
035C:  MOVFF  FE9,421
0360:  MOVLB  0
0362:  BRA    0326
0364:  MOVFF  422,FEA
0368:  MOVFF  421,FE9
036C:  MOVFF  01,FEF
.................... 		    buf_index++;  
0370:  MOVLB  1
0372:  INCF   x17,F
.................... 		    buffer[buf_index] = 0;  
0374:  CLRF   03
0376:  MOVF   x17,W
0378:  ADDLW  17
037A:  MOVWF  FE9
037C:  MOVLW  00
037E:  ADDWFC 03,W
0380:  MOVWF  FEA
0382:  CLRF   FEF
0384:  MOVLB  0
.................... 	    }  
.................... 	} 
.................... } 
.................... //--------------------------------------- Rutinas que atienden las interrupciones ------------------------------ 
....................  
.................... /************************************************************************************************ 
.................... | void GetEEPROMMed(long inx) Obtiene medicion almacenada y llena la estructura destino 
.................... | Retorna: llena variable readMed con los valores de medicion 
.................... | 
.................... ************************************************************************************************/ 
0386:  BCF    F9E.5
0388:  GOTO   006C
.................... void GetEEPROMMed(long inx) 
.................... { 
.................... 	char	*ptData, i; 
.................... 	address = INI_LOG_MEM + (inx * SZ_DATALOG); 
*
1E48:  MOVFF  37A,37F
1E4C:  MOVFF  379,37E
1E50:  MOVLB  3
1E52:  CLRF   x81
1E54:  MOVLW  17
1E56:  MOVWF  x80
1E58:  MOVLB  0
1E5A:  CALL   0418
1E5E:  MOVF   01,W
1E60:  ADDLW  02
1E62:  MOVLB  2
1E64:  MOVWF  xE4
1E66:  MOVLW  00
1E68:  ADDWFC 02,W
1E6A:  MOVWF  xE5
.................... 	ptData = (char*)(&readMed); 
1E6C:  MOVLW  03
1E6E:  MOVLB  3
1E70:  MOVWF  x7F
1E72:  MOVLW  01
1E74:  MOVFF  37F,37C
1E78:  MOVWF  x7B
.................... 	for (i = 0; i < SZ_DATALOG; i++){ 
1E7A:  CLRF   x7D
1E7C:  MOVF   x7D,W
1E7E:  SUBLW  16
1E80:  BNC   1EBC
.................... 		*ptData = read_ext_eeprom(address); 
1E82:  MOVFF  37C,03
1E86:  MOVFF  37B,37E
1E8A:  MOVFF  37C,37F
1E8E:  MOVFF  2E5,381
1E92:  MOVFF  2E4,380
1E96:  MOVLB  0
1E98:  RCALL  1DCC
1E9A:  MOVFF  37F,FEA
1E9E:  MOVFF  37E,FE9
1EA2:  MOVFF  01,FEF
.................... 		ptData++; 
1EA6:  MOVLB  3
1EA8:  INCF   x7B,F
1EAA:  BTFSC  FD8.2
1EAC:  INCF   x7C,F
.................... 		address++; 
1EAE:  MOVLB  2
1EB0:  INCF   xE4,F
1EB2:  BTFSC  FD8.2
1EB4:  INCF   xE5,F
.................... 	} 
1EB6:  MOVLB  3
1EB8:  INCF   x7D,F
1EBA:  BRA    1E7C
.................... }    
1EBC:  MOVLB  0
1EBE:  RETLW  00
.................... //-------------------------------------------------------------     
....................  
....................  
.................... /*-------------------------------------------------------------------------------------------------- 
.................... GetLastRainMed() | Toma las mediciones de las ultimas XX horas de precipitaciones  
.................... 					y las retorna para su envio 
.................... ---------------------------------------------------------------------------------------------------*/ 
.................... long GetLastRainMed(void) 
.................... { 
.................... 	long cnRain; 
.................... 	signed long int i; 
.................... 	int32  	dtLast, dtNew;	 
.................... 	//Si no hay medidas previas retornar 0 
.................... 	if (contData == 0 ) { 
*
1EFC:  MOVLB  2
1EFE:  MOVF   xE6,F
1F00:  BNZ   1F0E
1F02:  MOVF   xE7,F
1F04:  BNZ   1F0E
.................... 	  return 0; 
1F06:  MOVLW  00
1F08:  MOVWF  01
1F0A:  MOVWF  02
1F0C:  BRA    2036
.................... 	} 
.................... 	GetEEPROMMed(contData-1);		//Ultima medicion  
1F0E:  MOVLW  01
1F10:  SUBWF  xE6,W
1F12:  MOVLB  3
1F14:  MOVWF  x77
1F16:  MOVLW  00
1F18:  MOVLB  2
1F1A:  SUBWFB xE7,W
1F1C:  MOVLB  3
1F1E:  MOVWF  x78
1F20:  MOVWF  x7A
1F22:  MOVFF  377,379
1F26:  MOVLB  0
1F28:  RCALL  1E48
.................... 	dtLast = readMed.dateTime; 
1F2A:  MOVFF  304,372
1F2E:  MOVFF  303,371
1F32:  MOVFF  302,370
1F36:  MOVFF  301,36F
.................... 	cnRain = readMed.precip; 
1F3A:  MOVFF  310,37A
1F3E:  MOVFF  30F,379
1F42:  MOVFF  30E,378
1F46:  MOVFF  30D,377
1F4A:  RCALL  1EC0
1F4C:  MOVFF  02,36C
1F50:  MOVFF  01,36B
.................... 	dtNew = dtLast - (int32)(K_LLUVIA_H * 3600); 
1F54:  MOVLW  80
1F56:  MOVLB  3
1F58:  SUBWF  x6F,W
1F5A:  MOVWF  x73
1F5C:  MOVLW  51
1F5E:  SUBWFB x70,W
1F60:  MOVWF  x74
1F62:  MOVLW  01
1F64:  SUBWFB x71,W
1F66:  MOVWF  x75
1F68:  MOVLW  00
1F6A:  SUBWFB x72,W
1F6C:  MOVWF  x76
.................... 	if (contData == 1){ 
1F6E:  MOVLB  2
1F70:  DECFSZ xE6,W
1F72:  BRA    1F84
1F74:  MOVF   xE7,F
1F76:  BNZ   1F84
.................... 		return cnRain; 
1F78:  MOVFF  36B,01
1F7C:  MOVFF  36C,02
1F80:  MOVLB  2
1F82:  BRA    2036
.................... 	} 
.................... 	for (i = (contData-2); i >= 0; i--){ 
1F84:  MOVLW  02
1F86:  SUBWF  xE6,W
1F88:  MOVWF  00
1F8A:  MOVLW  00
1F8C:  SUBWFB xE7,W
1F8E:  MOVWF  03
1F90:  MOVFF  00,36D
1F94:  MOVLB  3
1F96:  MOVWF  x6E
1F98:  BTFSC  x6E.7
1F9A:  BRA    202C
1F9C:  BRA    1F9E
.................... 		GetEEPROMMed(i); 
1F9E:  MOVFF  36E,37A
1FA2:  MOVFF  36D,379
1FA6:  MOVLB  0
1FA8:  RCALL  1E48
.................... 		if (readMed.dateTime > dtNew){ 
1FAA:  MOVLB  3
1FAC:  MOVF   x76,W
1FAE:  SUBWF  x04,W
1FB0:  BNC   201C
1FB2:  BNZ   1FCA
1FB4:  MOVF   x75,W
1FB6:  SUBWF  x03,W
1FB8:  BNC   201C
1FBA:  BNZ   1FCA
1FBC:  MOVF   x74,W
1FBE:  SUBWF  x02,W
1FC0:  BNC   201C
1FC2:  BNZ   1FCA
1FC4:  MOVF   x01,W
1FC6:  SUBWF  x73,W
1FC8:  BC    201C
.................... 			cnRain += readMed.precip; 
1FCA:  MOVFF  36C,3A6
1FCE:  MOVFF  36B,3A5
1FD2:  MOVLB  0
1FD4:  CALL   1694
1FD8:  BCF    FD8.1
1FDA:  MOVFF  03,3A8
1FDE:  MOVFF  02,3A7
1FE2:  MOVFF  01,3A6
1FE6:  MOVFF  00,3A5
1FEA:  MOVFF  310,3AC
1FEE:  MOVFF  30F,3AB
1FF2:  MOVFF  30E,3AA
1FF6:  MOVFF  30D,3A9
1FFA:  CALL   17C0
1FFE:  MOVFF  03,37A
2002:  MOVFF  02,379
2006:  MOVFF  01,378
200A:  MOVFF  00,377
200E:  RCALL  1EC0
2010:  MOVFF  02,36C
2014:  MOVFF  01,36B
.................... 		} 
.................... 		else break;					// Acumula hasta K_LLUVIA_H horas 
2018:  BRA    2020
201A:  MOVLB  3
201C:  BRA    202C
201E:  MOVLB  0
.................... 	} 
2020:  MOVLB  3
2022:  MOVF   x6D,W
2024:  BTFSC  FD8.2
2026:  DECF   x6E,F
2028:  DECF   x6D,F
202A:  BRA    1F98
.................... 	return cnRain; 
202C:  MOVFF  36B,01
2030:  MOVFF  36C,02
2034:  MOVLB  2
.................... } 
2036:  MOVLB  0
2038:  GOTO   2748 (RETURN)
....................  
.................... /*------------------------------------------------------------------------------------------------ 
.................... | Leer_sensores(char prog) 
.................... | Lee sensores y los almacena en una estructura generica 
.................... | Parametro de entrada: prog <> 0 medida programada, 0 a pedido del usuario 
.................... ------------------------------------------------------------------------------------------------*/ 
.................... void Leer_sensores(char prog) 
.................... { 
.................... 	dataMed.dateTime = CurrDateTime();	// Obtiene la fecha y hora actual y la convierte en segundos 
*
232E:  CALL   11B4
2332:  MOVFF  03,2ED
2336:  MOVFF  02,2EC
233A:  MOVFF  01,2EB
233E:  MOVFF  00,2EA
.................... 	if (sensorHab & TEMP_HUM_S){		// Sensor de temperatura y humedad habilitado ? 
2342:  MOVLB  1
2344:  BTFSS  x7B.1
2346:  BRA    264A
.................... 		sht_rd(dataMed.tempExt, dataMed.humedad); 
.................... 		//Chequeo posible error de medida 
.................... 		if (dataMed.humedad < 0 ){ 
*
261A:  MOVFF  2F1,37A
261E:  MOVFF  2F0,379
2622:  MOVFF  2EF,378
2626:  MOVFF  2EE,377
262A:  MOVLB  3
262C:  CLRF   x7E
262E:  CLRF   x7D
2630:  CLRF   x7C
2632:  CLRF   x7B
2634:  MOVLB  0
2636:  CALL   1A38
263A:  BNC   2648
.................... 			dataMed.humedad = 0;		 
263C:  MOVLB  2
263E:  CLRF   xF1
2640:  CLRF   xF0
2642:  CLRF   xEF
2644:  CLRF   xEE
2646:  MOVLB  0
2648:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & RAINFALL_S){		// Sensor de precipitacion habilitado ? 
264A:  BTFSS  x7B.2
264C:  BRA    27A0
.................... 		llueveAhora = 0;		 
264E:  CLRF   x76
.................... 		if (countPrec != 0) { 
2650:  MOVF   x5C,F
2652:  BNZ   2658
2654:  MOVF   x5D,F
2656:  BZ    265C
.................... 			llueveAhora = 1;		 
2658:  MOVLW  01
265A:  MOVWF  x76
.................... 		} 
.................... 		int32 seconds = (dataMed.dateTime - secUltMed); 
.................... 		float actual = ((float)(countPrec * ctePluv)); 
265C:  MOVF   x77,W
265E:  MOVLB  2
2660:  SUBWF  xEA,W
2662:  MOVLB  3
2664:  MOVWF  x61
2666:  MOVLB  1
2668:  MOVF   x78,W
266A:  MOVLB  2
266C:  SUBWFB xEB,W
266E:  MOVLB  3
2670:  MOVWF  x62
2672:  MOVLB  1
2674:  MOVF   x79,W
2676:  MOVLB  2
2678:  SUBWFB xEC,W
267A:  MOVLB  3
267C:  MOVWF  x63
267E:  MOVLB  1
2680:  MOVF   x7A,W
2682:  MOVLB  2
2684:  SUBWFB xED,W
2686:  MOVLB  3
2688:  MOVWF  x64
268A:  MOVFF  15D,3A6
268E:  MOVFF  15C,3A5
2692:  MOVLB  0
2694:  CALL   1694
2698:  MOVFF  03,410
269C:  MOVFF  02,40F
26A0:  MOVFF  01,40E
26A4:  MOVFF  00,40D
26A8:  MOVFF  16D,414
26AC:  MOVFF  16C,413
26B0:  MOVFF  16B,412
26B4:  MOVFF  16A,411
26B8:  CALL   16CA
26BC:  MOVFF  03,368
26C0:  MOVFF  02,367
26C4:  MOVFF  01,366
26C8:  MOVFF  00,365
.................... 		if (prog){						// Si es programada es <> 0  
26CC:  MOVLB  3
26CE:  MOVF   x60,F
26D0:  BZ    2716
.................... 			dataMed.precip = actual ; 
26D2:  MOVFF  368,2F9
26D6:  MOVFF  367,2F8
26DA:  MOVFF  366,2F7
26DE:  MOVFF  365,2F6
.................... 			dataMed.intensidad = obtenerIntensidad(seconds, dataMed.precip); 
26E2:  MOVFF  364,36E
26E6:  MOVFF  363,36D
26EA:  MOVFF  362,36C
26EE:  MOVFF  361,36B
26F2:  MOVFF  2F9,372
26F6:  MOVFF  2F8,371
26FA:  MOVFF  2F7,370
26FE:  MOVFF  2F6,36F
2702:  MOVLB  0
2704:  CALL   1B6C
2708:  MOVFF  01,2FA
.................... 			countPrec = 0; 
270C:  MOVLB  1
270E:  CLRF   x5D
2710:  CLRF   x5C
.................... 		} 
.................... 		else{ 
2712:  BRA    27A0
2714:  MOVLB  3
.................... 		    long acumulado = 0; 
2716:  CLRF   x6A
2718:  CLRF   x69
.................... 			//Quiero mostrarle al usuario, lo acumulado + los precipitado en el lapso de tiempo de la ultima   
.................... 			//medida programada y ahora 
.................... 			dataMed.intensidad = obtenerIntensidad(seconds, actual); 
271A:  MOVFF  364,36E
271E:  MOVFF  363,36D
2722:  MOVFF  362,36C
2726:  MOVFF  361,36B
272A:  MOVFF  368,372
272E:  MOVFF  367,371
2732:  MOVFF  366,370
2736:  MOVFF  365,36F
273A:  MOVLB  0
273C:  CALL   1B6C
2740:  MOVFF  01,2FA
.................... 			acumulado = GetLastRainMed()  + countPrec; 
2744:  GOTO   1EFC
2748:  MOVLB  1
274A:  MOVF   x5C,W
274C:  MOVLB  3
274E:  ADDWF  01,W
2750:  MOVWF  x69
2752:  MOVLB  1
2754:  MOVF   x5D,W
2756:  MOVLB  3
2758:  ADDWFC 02,W
275A:  MOVWF  x6A
.................... 			dataMed.precip =  ((float)(acumulado * ctePluv)); 
275C:  MOVFF  36A,3A6
2760:  MOVFF  369,3A5
2764:  MOVLB  0
2766:  CALL   1694
276A:  MOVFF  03,410
276E:  MOVFF  02,40F
2772:  MOVFF  01,40E
2776:  MOVFF  00,40D
277A:  MOVFF  16D,414
277E:  MOVFF  16C,413
2782:  MOVFF  16B,412
2786:  MOVFF  16A,411
278A:  CALL   16CA
278E:  MOVFF  03,2F9
2792:  MOVFF  02,2F8
2796:  MOVFF  01,2F7
279A:  MOVFF  00,2F6
279E:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	if (sensorHab & PREASURE_S){		// Sensor de presion habilitado ? 
27A0:  BTFSS  x7B.3
27A2:  BRA    27BA
.................... 		dataMed.preasure = obtenerPresion(); 
27A4:  MOVLB  0
27A6:  BRA    219A
27A8:  MOVFF  03,2FE
27AC:  MOVFF  02,2FD
27B0:  MOVFF  01,2FC
27B4:  MOVFF  00,2FB
27B8:  MOVLB  1
.................... 	} 
.................... 	secUltMed = dataMed.dateTime; 
27BA:  MOVFF  2ED,17A
27BE:  MOVFF  2EC,179
27C2:  MOVFF  2EB,178
27C6:  MOVFF  2EA,177
.................... } 
27CA:  MOVLB  0
27CC:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | StoreMed2EEPROM(void) Almacena medicion en memoria 
.................... | CN_MEMDATA_L 
.................... | CN_MEMDATA_H 
.................... | INI_LOG_MEM	 
.................... | 
.................... ************************************************************************************************/ 
.................... void StoreMed2EEPROM(void) 
.................... { 
.................... 	BYTE	*ptData, i; 
....................  
.................... 	address = CN_MEMDATA_L; 
*
2898:  MOVLB  2
289A:  CLRF   xE5
289C:  CLRF   xE4
.................... 	contData = read_ext_eeprom(address); 
289E:  MOVFF  2E5,381
28A2:  MOVFF  2E4,380
28A6:  MOVLB  0
28A8:  CALL   1DCC
28AC:  MOVLB  2
28AE:  CLRF   xE7
28B0:  MOVFF  01,2E6
.................... 	address = CN_MEMDATA_H; 
28B4:  CLRF   xE5
28B6:  MOVLW  01
28B8:  MOVWF  xE4
.................... 	contData += (read_ext_eeprom(address) * 256); 
28BA:  MOVFF  2E5,381
28BE:  MOVFF  2E4,380
28C2:  MOVLB  0
28C4:  CALL   1DCC
28C8:  MOVLB  3
28CA:  CLRF   x7F
28CC:  MOVFF  01,37E
28D0:  MOVLW  01
28D2:  MOVWF  x81
28D4:  CLRF   x80
28D6:  MOVLB  0
28D8:  CALL   0418
28DC:  MOVF   01,W
28DE:  MOVLB  2
28E0:  ADDWF  xE6,F
28E2:  MOVF   02,W
28E4:  ADDWFC xE7,F
.................... 	address = INI_LOG_MEM + (contData * SZ_DATALOG); 
28E6:  MOVFF  2E7,37F
28EA:  MOVFF  2E6,37E
28EE:  MOVLB  3
28F0:  CLRF   x81
28F2:  MOVLW  17
28F4:  MOVWF  x80
28F6:  MOVLB  0
28F8:  CALL   0418
28FC:  MOVF   01,W
28FE:  ADDLW  02
2900:  MOVLB  2
2902:  MOVWF  xE4
2904:  MOVLW  00
2906:  ADDWFC 02,W
2908:  MOVWF  xE5
.................... 	ptData = &dataMed; 
290A:  MOVLW  02
290C:  MOVLB  3
290E:  MOVWF  x55
2910:  MOVLW  EA
2912:  MOVWF  x54
.................... 	for (i = 0; i < SZ_DATALOG; i++){ 
2914:  CLRF   x56
2916:  MOVF   x56,W
2918:  SUBLW  16
291A:  BNC   294E
.................... 		data = *ptData; 
291C:  MOVFF  354,FE9
2920:  MOVFF  355,FEA
2924:  MOVFF  FEF,2E8
2928:  MOVLB  2
.................... 		write_ext_eeprom(address, data); 
292A:  MOVFF  2E5,393
292E:  MOVFF  2E4,392
2932:  MOVFF  2E8,394
2936:  MOVLB  0
2938:  RCALL  27CE
.................... 		address++; 
293A:  MOVLB  2
293C:  INCF   xE4,F
293E:  BTFSC  FD8.2
2940:  INCF   xE5,F
.................... 		ptData++; 
2942:  MOVLB  3
2944:  INCF   x54,F
2946:  BTFSC  FD8.2
2948:  INCF   x55,F
.................... 	} 
294A:  INCF   x56,F
294C:  BRA    2916
.................... 	contData++; 
294E:  MOVLB  2
2950:  INCF   xE6,F
2952:  BTFSC  FD8.2
2954:  INCF   xE7,F
.................... 	address = CN_MEMDATA_L; 
2956:  CLRF   xE5
2958:  CLRF   xE4
.................... 	data = contData & 0x00FF; 
295A:  MOVFF  2E6,2E8
.................... 	write_ext_eeprom(address, data); 
295E:  MOVFF  2E5,393
2962:  MOVFF  2E4,392
2966:  MOVFF  2E8,394
296A:  MOVLB  0
296C:  RCALL  27CE
.................... 	address = CN_MEMDATA_H; 
296E:  MOVLB  2
2970:  CLRF   xE5
2972:  MOVLW  01
2974:  MOVWF  xE4
.................... 	data = contData >> 8; 
2976:  MOVFF  2E7,2E8
.................... 	write_ext_eeprom(address, data); 
297A:  MOVFF  2E5,393
297E:  MOVFF  2E4,392
2982:  MOVFF  2E8,394
2986:  MOVLB  0
2988:  RCALL  27CE
.................... 	 
.................... 	if (contData > MAX_LOG_CNT){ 
298A:  MOVLB  2
298C:  MOVF   xE7,W
298E:  SUBLW  02
2990:  BC    29A4
2992:  XORLW  FF
2994:  BNZ   299C
2996:  MOVF   xE6,W
2998:  SUBLW  E8
299A:  BC    29A4
.................... 		memoryFull = 1;  
299C:  MOVLW  01
299E:  MOVLB  1
29A0:  MOVWF  x71
29A2:  MOVLB  2
.................... 	} 
.................... } 
29A4:  MOVLB  0
29A6:  GOTO   4E10 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Funcion para lectura de los sms 
.................... | Parametro de entrada: variable para almacenar el contenido del sms 
.................... ************************************************************************************************/ 
.................... long LeerSmsCmd(char *sms)  
.................... { 
*
39C0:  MOVLB  3
39C2:  CLRF   x56
.................... 	int  rta = 0; 
.................... 	char *pt, sepCh[2];	 
.................... 	char *ptr; 
.................... 	char *ptr2; 
.................... 	int	 i; 
.................... 	//Chequeo en las otras posiciones en caso que se hay encolado algun SMS 
.................... 	clear_buffer_gsm(); 
39C4:  MOVLB  0
39C6:  CALL   073A
.................... 	fprintf(SIM300,"AT+CMGR=%d,0\r",guia); 
39CA:  MOVLW  8C
39CC:  MOVWF  FF6
39CE:  MOVLW  03
39D0:  MOVWF  FF7
39D2:  MOVLW  08
39D4:  MOVLB  3
39D6:  MOVWF  x65
39D8:  MOVLB  0
39DA:  CALL   0940
39DE:  MOVFF  130,362
39E2:  MOVLW  1F
39E4:  MOVLB  3
39E6:  MOVWF  x63
39E8:  MOVLB  0
39EA:  CALL   0996
39EE:  MOVLW  2C
39F0:  BTFSS  F9E.4
39F2:  BRA    39F0
39F4:  MOVWF  FAD
39F6:  MOVLW  30
39F8:  BTFSS  F9E.4
39FA:  BRA    39F8
39FC:  MOVWF  FAD
39FE:  MOVLW  0D
3A00:  BTFSS  F9E.4
3A02:  BRA    3A00
3A04:  MOVWF  FAD
.................... 	delay_ms(2000); 
3A06:  MOVLW  08
3A08:  MOVLB  3
3A0A:  MOVWF  x61
3A0C:  MOVLW  FA
3A0E:  MOVWF  x74
3A10:  MOVLB  0
3A12:  CALL   05D4
3A16:  MOVLB  3
3A18:  DECFSZ x61,F
3A1A:  BRA    3A0C
.................... 	if(gprs_response(sms_noleido,1000)!=0){   // Verifica si hay un Mensaje no leido 
3A1C:  MOVLW  01
3A1E:  MOVWF  x66
3A20:  MOVLW  27
3A22:  MOVWF  x65
3A24:  MOVLW  03
3A26:  MOVWF  x68
3A28:  MOVLW  E8
3A2A:  MOVWF  x67
3A2C:  MOVLB  0
3A2E:  CALL   06AC
3A32:  MOVFF  02,362
3A36:  MOVFF  01,361
3A3A:  MOVLB  3
3A3C:  MOVF   x61,F
3A3E:  BNZ   3A46
3A40:  MOVF   x62,F
3A42:  BTFSC  FD8.2
3A44:  BRA    3BB4
.................... 		pt = gprs_response(telnum,1000); 
3A46:  MOVLW  01
3A48:  MOVWF  x66
3A4A:  MOVLW  48
3A4C:  MOVWF  x65
3A4E:  MOVLW  03
3A50:  MOVWF  x68
3A52:  MOVLW  E8
3A54:  MOVWF  x67
3A56:  MOVLB  0
3A58:  CALL   06AC
3A5C:  MOVFF  02,358
3A60:  MOVFF  01,357
.................... 		if(pt!=0){ 
3A64:  MOVLB  3
3A66:  MOVF   x57,F
3A68:  BNZ   3A70
3A6A:  MOVF   x58,F
3A6C:  BTFSC  FD8.2
3A6E:  BRA    3BA0
.................... 			clear_var(smsText); 
3A70:  MOVLW  01
3A72:  MOVWF  xFD
3A74:  MOVLW  82
3A76:  MOVWF  xFC
3A78:  MOVLB  0
3A7A:  CALL   0AD0
.................... 			strcpy(sepCh, "\""); 
3A7E:  MOVLW  03
3A80:  MOVWF  FEA
3A82:  MOVLW  59
3A84:  MOVWF  FE9
3A86:  MOVFF  FF2,361
3A8A:  BCF    FF2.7
3A8C:  MOVLW  00
3A8E:  CALL   00E0
3A92:  TBLRD*-
3A94:  TBLRD*+
3A96:  MOVF   FF5,W
3A98:  MOVWF  FEE
3A9A:  IORLW  00
3A9C:  BNZ   3A94
3A9E:  MOVLB  3
3AA0:  BTFSC  x61.7
3AA2:  BSF    FF2.7
.................... 			ptr = strtok(pt, sepCh); 
3AA4:  MOVFF  358,393
3AA8:  MOVFF  357,392
3AAC:  MOVLW  03
3AAE:  MOVWF  x95
3AB0:  MOVLW  59
3AB2:  MOVWF  x94
3AB4:  MOVLB  0
3AB6:  RCALL  388E
3AB8:  MOVFF  02,35C
3ABC:  MOVFF  01,35B
.................... 			do { 
.................... 				ptr2 = ptr; 
3AC0:  MOVFF  35C,35E
3AC4:  MOVFF  35B,35D
.................... 			} while((ptr = strtok( NULL, sepCh)) != NULL ); 
3AC8:  MOVLB  3
3ACA:  CLRF   x93
3ACC:  CLRF   x92
3ACE:  MOVLW  03
3AD0:  MOVWF  x95
3AD2:  MOVLW  59
3AD4:  MOVWF  x94
3AD6:  MOVLB  0
3AD8:  RCALL  388E
3ADA:  MOVFF  02,35C
3ADE:  MOVFF  01,35B
3AE2:  MOVLB  3
3AE4:  MOVF   x5B,F
3AE6:  BTFSC  FD8.2
3AE8:  BRA    3AEE
3AEA:  MOVLB  0
3AEC:  BRA    3AC0
3AEE:  MOVF   x5C,F
3AF0:  BTFSC  FD8.2
3AF2:  BRA    3AF8
3AF4:  MOVLB  0
3AF6:  BRA    3AC0
.................... 			strcpy(sepCh, "\r"); 
3AF8:  MOVLW  03
3AFA:  MOVWF  FEA
3AFC:  MOVLW  59
3AFE:  MOVWF  FE9
3B00:  MOVFF  FF2,361
3B04:  BCF    FF2.7
3B06:  MOVLW  00
3B08:  MOVLB  0
3B0A:  CALL   00FC
3B0E:  TBLRD*-
3B10:  TBLRD*+
3B12:  MOVF   FF5,W
3B14:  MOVWF  FEE
3B16:  IORLW  00
3B18:  BNZ   3B10
3B1A:  MOVLB  3
3B1C:  BTFSC  x61.7
3B1E:  BSF    FF2.7
.................... 			strtok(NULL, sepCh); 
3B20:  CLRF   x93
3B22:  CLRF   x92
3B24:  MOVLW  03
3B26:  MOVWF  x95
3B28:  MOVLW  59
3B2A:  MOVWF  x94
3B2C:  MOVLB  0
3B2E:  RCALL  388E
.................... 			ptr2++; 
3B30:  MOVLB  3
3B32:  INCF   x5D,F
3B34:  BTFSC  FD8.2
3B36:  INCF   x5E,F
.................... 			ptr2++; 
3B38:  INCF   x5D,F
3B3A:  BTFSC  FD8.2
3B3C:  INCF   x5E,F
.................... 			for (i = 0; i < SZ_SMSTXT; i++){ 
3B3E:  CLRF   x5F
3B40:  MOVF   x5F,W
3B42:  SUBLW  A4
3B44:  BNC   3B84
.................... 				if ((ptr2[i] == '\r') || (ptr2[i] == '\n')){ 
3B46:  CLRF   03
3B48:  MOVF   x5F,W
3B4A:  ADDWF  x5D,W
3B4C:  MOVWF  FE9
3B4E:  MOVF   x5E,W
3B50:  ADDWFC 03,W
3B52:  MOVWF  FEA
3B54:  MOVF   FEF,W
3B56:  SUBLW  0D
3B58:  BZ    3B6E
3B5A:  CLRF   03
3B5C:  MOVF   x5F,W
3B5E:  ADDWF  x5D,W
3B60:  MOVWF  FE9
3B62:  MOVF   x5E,W
3B64:  ADDWFC 03,W
3B66:  MOVWF  FEA
3B68:  MOVF   FEF,W
3B6A:  SUBLW  0A
3B6C:  BNZ   3B80
.................... 					ptr2[i] = 0; 
3B6E:  CLRF   03
3B70:  MOVF   x5F,W
3B72:  ADDWF  x5D,W
3B74:  MOVWF  FE9
3B76:  MOVF   x5E,W
3B78:  ADDWFC 03,W
3B7A:  MOVWF  FEA
3B7C:  CLRF   FEF
.................... 					break; 
3B7E:  BRA    3B84
.................... 				} 
.................... 			} 
3B80:  INCF   x5F,F
3B82:  BRA    3B40
.................... 			strcpy(sms,ptr2); 
3B84:  MOVFF  355,FEA
3B88:  MOVFF  354,FE9
3B8C:  MOVFF  35E,FE2
3B90:  MOVFF  35D,FE1
3B94:  MOVF   FE7,F
3B96:  MOVFF  FE6,FEE
3B9A:  BNZ   3B94
.................... 			rta = guia; 
3B9C:  MOVFF  130,356
.................... 		} 
.................... 		int resp = borrar_sms(); 
3BA0:  MOVLB  0
3BA2:  BRA    3946
3BA4:  MOVFF  01,360
.................... 		if (!resp){ 
3BA8:  MOVLB  3
3BAA:  MOVF   x60,F
3BAC:  BNZ   3BB4
.................... 			guia++; 
3BAE:  MOVLB  1
3BB0:  INCF   x30,F
3BB2:  MOVLB  3
.................... 		} 
.................... 	}  
....................     return rta; 
3BB4:  CLRF   03
3BB6:  MOVFF  356,01
3BBA:  MOVFF  03,02
.................... } 
3BBE:  MOVLB  0
3BC0:  GOTO   5044 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Funcion para enviar los sms 
.................... | Parametro de entrada: variable para almacenar el contenido del sms, numero donde enviar el sms 
.................... ************************************************************************************************/ 
.................... long EnviarSms(char *sms, char *tel) 
.................... {	 
.................... 	char	tmOut; 
.................... 	clear_buffer_gsm(); 
*
1380:  CALL   073A
.................... 	fprintf(SIM300,"AT+CMGS=\"%s\"\r",tel); // Teléfono al cúal le enviaremos el mensaje. 
1384:  MOVLW  9A
1386:  MOVWF  FF6
1388:  MOVLW  03
138A:  MOVWF  FF7
138C:  MOVLW  09
138E:  MOVLB  3
1390:  MOVWF  x65
1392:  MOVLB  0
1394:  CALL   0940
1398:  MOVFF  363,FEA
139C:  MOVFF  362,FE9
13A0:  RCALL  1350
13A2:  MOVLW  22
13A4:  BTFSS  F9E.4
13A6:  BRA    13A4
13A8:  MOVWF  FAD
13AA:  MOVLW  0D
13AC:  BTFSS  F9E.4
13AE:  BRA    13AC
13B0:  MOVWF  FAD
.................... 	tmOut = 150; 
13B2:  MOVLW  96
13B4:  MOVLB  3
13B6:  MOVWF  x64
.................... 	do { 
.................... 		tmOut--; 
13B8:  DECF   x64,F
.................... 	}while((gprs_response(caracter,2000) == NULL) && (tmOut != 0)); 
13BA:  MOVLW  01
13BC:  MOVWF  x66
13BE:  MOVLW  2E
13C0:  MOVWF  x65
13C2:  MOVLW  07
13C4:  MOVWF  x68
13C6:  MOVLW  D0
13C8:  MOVWF  x67
13CA:  MOVLB  0
13CC:  CALL   06AC
13D0:  MOVFF  02,366
13D4:  MOVFF  01,365
13D8:  MOVLB  3
13DA:  MOVF   x65,F
13DC:  BNZ   13E6
13DE:  MOVF   x66,F
13E0:  BNZ   13E6
13E2:  MOVF   x64,F
13E4:  BNZ   13B8
.................... 	 
.................... 	fprintf(SIM300,"%s",sms);             // Imprimimos mensaje a enviar.  
13E6:  MOVFF  361,FEA
13EA:  MOVFF  360,FE9
13EE:  MOVLB  0
13F0:  RCALL  1350
.................... 	delay_ms(2000);   
13F2:  MOVLW  08
13F4:  MOVLB  3
13F6:  MOVWF  x65
13F8:  MOVLW  FA
13FA:  MOVWF  x74
13FC:  MOVLB  0
13FE:  CALL   05D4
1402:  MOVLB  3
1404:  DECFSZ x65,F
1406:  BRA    13F8
.................... 	fputc(0x1A,SIM300);                   // Comando para enviar el mensaje. Equivale al CRTL+Z. 
1408:  MOVLW  1A
140A:  MOVLB  0
140C:  BRA    1376
.................... 	clear_buffer_gsm(); 
140E:  CALL   073A
....................   return 0; 
1412:  MOVLW  00
1414:  MOVWF  01
1416:  MOVWF  02
.................... } 
1418:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | Limpia el buffer usado para guardar comunicacion con modem gsm 
.................... ************************************************************************************************/ 
.................... void clear_var(char* sms)  /*borra el buffer sms */ 
.................... {  
*
0AD0:  MOVLB  3
0AD2:  CLRF   xFE
....................   int erase = 0;  
....................   while(erase < SZ_SMSTXT) { 
0AD4:  MOVF   xFE,W
0AD6:  SUBLW  A4
0AD8:  BNC   0AEE
.................... 	sms[erase] = '\0'; 
0ADA:  CLRF   03
0ADC:  MOVF   xFE,W
0ADE:  ADDWF  xFC,W
0AE0:  MOVWF  FE9
0AE2:  MOVF   xFD,W
0AE4:  ADDWFC 03,W
0AE6:  MOVWF  FEA
0AE8:  CLRF   FEF
.................... 	erase++; 
0AEA:  INCF   xFE,F
....................   } 
0AEC:  BRA    0AD4
.................... }  
0AEE:  MOVLB  0
0AF0:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... | Inicializa la EEPROM 
.................... ************************************************************************************************/ 
.................... void inicializa_eeprom(void) 
.................... { 
.................... 	contData = 0; 
*
3FAE:  MOVLB  2
3FB0:  CLRF   xE7
3FB2:  CLRF   xE6
.................... 	memoryFull = 0;  
3FB4:  MOVLB  1
3FB6:  CLRF   x71
.................... 	address = CN_MEMDATA_L; 
3FB8:  MOVLB  2
3FBA:  CLRF   xE5
3FBC:  CLRF   xE4
.................... 	write_ext_eeprom(address, 0); 
3FBE:  MOVFF  2E5,393
3FC2:  MOVFF  2E4,392
3FC6:  MOVLB  3
3FC8:  CLRF   x94
3FCA:  MOVLB  0
3FCC:  CALL   27CE
.................... 	address = CN_MEMDATA_H; 
3FD0:  MOVLB  2
3FD2:  CLRF   xE5
3FD4:  MOVLW  01
3FD6:  MOVWF  xE4
.................... 	write_ext_eeprom(address, 0); 
3FD8:  MOVFF  2E5,393
3FDC:  MOVFF  2E4,392
3FE0:  MOVLB  3
3FE2:  CLRF   x94
3FE4:  MOVLB  0
3FE6:  CALL   27CE
.................... } 
3FEA:  GOTO   4806 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | Verifica si la memoria EEPROM esta llena o no 
.................... ************************************************************************************************/ 
.................... void verifica_eeprom(void)  /*borra el buffer sms */ 
.................... {  
.................... 	//--- Verifica condicion de memoria al inicio 
.................... 	address = CN_MEMDATA_L; 
.................... 	contData = read_ext_eeprom(address); 
.................... 	address = CN_MEMDATA_H; 
.................... 	contData += (read_ext_eeprom(address) * 256); 
.................... 	if (contData > MAX_LOG_CNT){ 
.................... 		memoryFull = 1;     
.................... 	} 
.................... 	//--- Verifica condicion de memoria al inicio 
.................... }  
....................  
....................  
.................... /************************************************************************************************ 
.................... | int  ProcessMessage(char *msg) 
.................... | Analiza el string del mensaje recibido y procesa el comando correspondiente 
.................... | 
.................... ************************************************************************************************/ 
.................... int  ProcessMessage(char *msg) 
.................... { 
.................... 	char 	aux[30], aux2[8], sepCh[2], *ptr, *telnumaux; 
.................... 	BYTE  	hora, min, dia, mes, year; 
.................... 	BYTE	typeAlrm, i, done; 
.................... 	float	maxAlrm, minAlrm; 
.................... 	 
.................... 	memset(aux, 0, sizeof(aux)); 
3FEE:  MOVLW  03
3FF0:  MOVWF  FEA
3FF2:  MOVLW  56
3FF4:  MOVWF  FE9
3FF6:  MOVLB  3
3FF8:  CLRF   x92
3FFA:  CLRF   x94
3FFC:  MOVLW  1E
3FFE:  MOVWF  x93
4000:  MOVLB  0
4002:  BRA    3BC4
.................... 	strcpy(aux, msg); 
4004:  MOVLW  03
4006:  MOVWF  FEA
4008:  MOVLW  56
400A:  MOVWF  FE9
400C:  MOVFF  355,FE2
4010:  MOVFF  354,FE1
4014:  MOVF   FE7,F
4016:  MOVFF  FE6,FEE
401A:  BNZ   4014
.................... 	strcpy(sepCh, "|"); 
401C:  MOVLW  03
401E:  MOVWF  FEA
4020:  MOVLW  7C
4022:  MOVWF  FE9
4024:  MOVFF  FF2,392
4028:  BCF    FF2.7
402A:  MOVLW  00
402C:  CALL   0118
4030:  TBLRD*-
4032:  TBLRD*+
4034:  MOVF   FF5,W
4036:  MOVWF  FEE
4038:  IORLW  00
403A:  BNZ   4032
403C:  MOVLB  3
403E:  BTFSC  x92.7
4040:  BSF    FF2.7
.................... 	ptr = strtok(aux, sepCh); 
4042:  MOVLW  03
4044:  MOVWF  x93
4046:  MOVLW  56
4048:  MOVWF  x92
404A:  MOVLW  03
404C:  MOVWF  x95
404E:  MOVLW  7C
4050:  MOVWF  x94
4052:  MOVLB  0
4054:  RCALL  388E
4056:  MOVFF  02,37F
405A:  MOVFF  01,37E
.................... 	strcpy(aux2, "AA"); 
405E:  MOVLW  03
4060:  MOVWF  FEA
4062:  MOVLW  74
4064:  MOVWF  FE9
4066:  MOVFF  FF2,392
406A:  BCF    FF2.7
406C:  MOVLW  00
406E:  CALL   0134
4072:  TBLRD*-
4074:  TBLRD*+
4076:  MOVF   FF5,W
4078:  MOVWF  FEE
407A:  IORLW  00
407C:  BNZ   4074
407E:  MOVLB  3
4080:  BTFSC  x92.7
4082:  BSF    FF2.7
.................... 	if (strcmp(ptr, aux2) == 0) { 
4084:  MOVFF  37F,393
4088:  MOVFF  37E,392
408C:  MOVLW  03
408E:  MOVWF  x95
4090:  MOVLW  74
4092:  MOVWF  x94
4094:  MOVLB  0
4096:  RCALL  3BE4
4098:  MOVF   01,F
409A:  BTFSS  FD8.2
409C:  BRA    43E0
.................... 		//------------------------------------ Procesa Alta de alarma -------------------------------- 
.................... 		ptr = strtok(null, sepCh); 
409E:  MOVLB  3
40A0:  CLRF   x93
40A2:  CLRF   x92
40A4:  MOVLW  03
40A6:  MOVWF  x95
40A8:  MOVLW  7C
40AA:  MOVWF  x94
40AC:  MOVLB  0
40AE:  CALL   388E
40B2:  MOVFF  02,37F
40B6:  MOVFF  01,37E
.................... 		if (ptr != NULL) typeAlrm = *ptr;		// Tipo alarma 
40BA:  MOVLB  3
40BC:  MOVF   x7E,F
40BE:  BNZ   40C4
40C0:  MOVF   x7F,F
40C2:  BZ    40D2
40C4:  MOVFF  37E,FE9
40C8:  MOVFF  37F,FEA
40CC:  MOVFF  FEF,387
.................... 		else return TYP_SMS_ERR; 
40D0:  BRA    40DA
40D2:  MOVLW  F0
40D4:  MOVWF  01
40D6:  GOTO   4A04
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
40DA:  CLRF   x93
40DC:  CLRF   x92
40DE:  MOVLW  03
40E0:  MOVWF  x95
40E2:  MOVLW  7C
40E4:  MOVWF  x94
40E6:  MOVLB  0
40E8:  CALL   388E
40EC:  MOVFF  02,37F
40F0:  MOVFF  01,37E
.................... 		if (ptr != NULL) maxAlrm = atof(ptr);	// Valor maximo 
40F4:  MOVLB  3
40F6:  MOVF   x7E,F
40F8:  BNZ   40FE
40FA:  MOVF   x7F,F
40FC:  BZ    4122
40FE:  MOVFF  37F,393
4102:  MOVFF  37E,392
4106:  CLRF   x95
4108:  CLRF   x94
410A:  MOVLB  0
410C:  RCALL  3C5C
410E:  MOVFF  03,38D
4112:  MOVFF  02,38C
4116:  MOVFF  01,38B
411A:  MOVFF  00,38A
.................... 		else return TYP_SMS_ERR; 
411E:  BRA    412A
4120:  MOVLB  3
4122:  MOVLW  F0
4124:  MOVWF  01
4126:  GOTO   4A04
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
412A:  MOVLB  3
412C:  CLRF   x93
412E:  CLRF   x92
4130:  MOVLW  03
4132:  MOVWF  x95
4134:  MOVLW  7C
4136:  MOVWF  x94
4138:  MOVLB  0
413A:  CALL   388E
413E:  MOVFF  02,37F
4142:  MOVFF  01,37E
.................... 		if (ptr != NULL) minAlrm = atof(ptr);	// Valor minimo 
4146:  MOVLB  3
4148:  MOVF   x7E,F
414A:  BNZ   4150
414C:  MOVF   x7F,F
414E:  BZ    4174
4150:  MOVFF  37F,393
4154:  MOVFF  37E,392
4158:  CLRF   x95
415A:  CLRF   x94
415C:  MOVLB  0
415E:  RCALL  3C5C
4160:  MOVFF  03,391
4164:  MOVFF  02,390
4168:  MOVFF  01,38F
416C:  MOVFF  00,38E
.................... 		else return TYP_SMS_ERR; 
4170:  BRA    417C
4172:  MOVLB  3
4174:  MOVLW  F0
4176:  MOVWF  01
4178:  GOTO   4A04
.................... 		// 
.................... 		ptr = strtok(null, sepCh); 
417C:  MOVLB  3
417E:  CLRF   x93
4180:  CLRF   x92
4182:  MOVLW  03
4184:  MOVWF  x95
4186:  MOVLW  7C
4188:  MOVWF  x94
418A:  MOVLB  0
418C:  CALL   388E
4190:  MOVFF  02,37F
4194:  MOVFF  01,37E
.................... 		if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4198:  MOVLB  3
419A:  MOVF   x7E,F
419C:  BNZ   41A2
419E:  MOVF   x7F,F
41A0:  BZ    41BC
41A2:  MOVLW  01
41A4:  MOVWF  FEA
41A6:  MOVLW  7C
41A8:  MOVWF  FE9
41AA:  MOVFF  37F,FE2
41AE:  MOVFF  37E,FE1
41B2:  MOVF   FE7,F
41B4:  MOVFF  FE6,FEE
41B8:  BNZ   41B2
.................... 		else return TYP_SMS_ERR; 
41BA:  BRA    41C4
41BC:  MOVLW  F0
41BE:  MOVWF  01
41C0:  GOTO   4A04
.................... 		// 
.................... 		done = 0; 
41C4:  CLRF   x89
.................... 		for (i = 0; i < 5; i++){ 
41C6:  CLRF   x88
41C8:  MOVF   x88,W
41CA:  SUBLW  04
41CC:  BTFSS  FD8.0
41CE:  BRA    42CA
.................... 			if (alarm[i].variable == typeAlrm){ 
41D0:  MOVF   x88,W
41D2:  MULLW  0B
41D4:  MOVF   FF3,W
41D6:  CLRF   x93
41D8:  MOVWF  x92
41DA:  MOVLW  01
41DC:  ADDWF  x92,W
41DE:  MOVWF  01
41E0:  MOVLW  00
41E2:  ADDWFC x93,W
41E4:  MOVWF  03
41E6:  MOVF   01,W
41E8:  ADDLW  18
41EA:  MOVWF  FE9
41EC:  MOVLW  03
41EE:  ADDWFC 03,W
41F0:  MOVWF  FEA
41F2:  MOVF   x87,W
41F4:  SUBWF  FEF,W
41F6:  BNZ   42C6
.................... 				alarm[i].activa 	= 1; 
41F8:  MOVF   x88,W
41FA:  MULLW  0B
41FC:  MOVF   FF3,W
41FE:  CLRF   x93
4200:  MOVWF  x92
4202:  MOVLW  18
4204:  ADDWF  x92,W
4206:  MOVWF  FE9
4208:  MOVLW  03
420A:  ADDWFC x93,W
420C:  MOVWF  FEA
420E:  MOVLW  01
4210:  MOVWF  FEF
.................... 				alarm[i].variable 	= typeAlrm; 
4212:  MOVF   x88,W
4214:  MULLW  0B
4216:  MOVF   FF3,W
4218:  CLRF   x93
421A:  MOVWF  x92
421C:  MOVLW  01
421E:  ADDWF  x92,W
4220:  MOVWF  01
4222:  MOVLW  00
4224:  ADDWFC x93,W
4226:  MOVWF  03
4228:  MOVF   01,W
422A:  ADDLW  18
422C:  MOVWF  FE9
422E:  MOVLW  03
4230:  ADDWFC 03,W
4232:  MOVWF  FEA
4234:  MOVFF  387,FEF
.................... 				alarm[i].max_value 	= maxAlrm; 
4238:  MOVF   x88,W
423A:  MULLW  0B
423C:  MOVF   FF3,W
423E:  CLRF   x93
4240:  MOVWF  x92
4242:  MOVLW  02
4244:  ADDWF  x92,W
4246:  MOVWF  01
4248:  MOVLW  00
424A:  ADDWFC x93,W
424C:  MOVWF  03
424E:  MOVF   01,W
4250:  ADDLW  18
4252:  MOVWF  FE9
4254:  MOVLW  03
4256:  ADDWFC 03,W
4258:  MOVWF  FEA
425A:  MOVFF  38A,FEF
425E:  MOVFF  38B,FEC
4262:  MOVFF  38C,FEC
4266:  MOVFF  38D,FEC
.................... 				alarm[i].min_value 	= minAlrm; 
426A:  MOVF   x88,W
426C:  MULLW  0B
426E:  MOVF   FF3,W
4270:  CLRF   x93
4272:  MOVWF  x92
4274:  MOVLW  06
4276:  ADDWF  x92,W
4278:  MOVWF  01
427A:  MOVLW  00
427C:  ADDWFC x93,W
427E:  MOVWF  03
4280:  MOVF   01,W
4282:  ADDLW  18
4284:  MOVWF  FE9
4286:  MOVLW  03
4288:  ADDWFC 03,W
428A:  MOVWF  FEA
428C:  MOVFF  38E,FEF
4290:  MOVFF  38F,FEC
4294:  MOVFF  390,FEC
4298:  MOVFF  391,FEC
.................... 				alarm[i].cnValid	= 0; 
429C:  MOVF   x88,W
429E:  MULLW  0B
42A0:  MOVF   FF3,W
42A2:  CLRF   x93
42A4:  MOVWF  x92
42A6:  MOVLW  0A
42A8:  ADDWF  x92,W
42AA:  MOVWF  01
42AC:  MOVLW  00
42AE:  ADDWFC x93,W
42B0:  MOVWF  03
42B2:  MOVF   01,W
42B4:  ADDLW  18
42B6:  MOVWF  FE9
42B8:  MOVLW  03
42BA:  ADDWFC 03,W
42BC:  MOVWF  FEA
42BE:  CLRF   FEF
.................... 				done = 1; 
42C0:  MOVLW  01
42C2:  MOVWF  x89
.................... 				break; 
42C4:  BRA    42CA
.................... 			} 
.................... 		} 
42C6:  INCF   x88,F
42C8:  BRA    41C8
.................... 		if (done == 0){								// No existe variable en tabla de alarmas  
42CA:  MOVF   x89,F
42CC:  BTFSS  FD8.2
42CE:  BRA    43C6
.................... 			for (i = 0; i < 5; i++){ 
42D0:  CLRF   x88
42D2:  MOVF   x88,W
42D4:  SUBLW  04
42D6:  BNC   43C4
.................... 				if (alarm[i].activa == 0){			// Actualiza valores de alarma y la activa 
42D8:  MOVF   x88,W
42DA:  MULLW  0B
42DC:  MOVF   FF3,W
42DE:  CLRF   x93
42E0:  MOVWF  x92
42E2:  MOVLW  18
42E4:  ADDWF  x92,W
42E6:  MOVWF  FE9
42E8:  MOVLW  03
42EA:  ADDWFC x93,W
42EC:  MOVWF  FEA
42EE:  MOVF   FEF,F
42F0:  BNZ   43C0
.................... 					alarm[i].activa 	= 1; 
42F2:  MOVF   x88,W
42F4:  MULLW  0B
42F6:  MOVF   FF3,W
42F8:  CLRF   x93
42FA:  MOVWF  x92
42FC:  MOVLW  18
42FE:  ADDWF  x92,W
4300:  MOVWF  FE9
4302:  MOVLW  03
4304:  ADDWFC x93,W
4306:  MOVWF  FEA
4308:  MOVLW  01
430A:  MOVWF  FEF
.................... 					alarm[i].variable 	= typeAlrm; 
430C:  MOVF   x88,W
430E:  MULLW  0B
4310:  MOVF   FF3,W
4312:  CLRF   x93
4314:  MOVWF  x92
4316:  MOVLW  01
4318:  ADDWF  x92,W
431A:  MOVWF  01
431C:  MOVLW  00
431E:  ADDWFC x93,W
4320:  MOVWF  03
4322:  MOVF   01,W
4324:  ADDLW  18
4326:  MOVWF  FE9
4328:  MOVLW  03
432A:  ADDWFC 03,W
432C:  MOVWF  FEA
432E:  MOVFF  387,FEF
.................... 					alarm[i].max_value 	= maxAlrm; 
4332:  MOVF   x88,W
4334:  MULLW  0B
4336:  MOVF   FF3,W
4338:  CLRF   x93
433A:  MOVWF  x92
433C:  MOVLW  02
433E:  ADDWF  x92,W
4340:  MOVWF  01
4342:  MOVLW  00
4344:  ADDWFC x93,W
4346:  MOVWF  03
4348:  MOVF   01,W
434A:  ADDLW  18
434C:  MOVWF  FE9
434E:  MOVLW  03
4350:  ADDWFC 03,W
4352:  MOVWF  FEA
4354:  MOVFF  38A,FEF
4358:  MOVFF  38B,FEC
435C:  MOVFF  38C,FEC
4360:  MOVFF  38D,FEC
.................... 					alarm[i].min_value 	= minAlrm; 
4364:  MOVF   x88,W
4366:  MULLW  0B
4368:  MOVF   FF3,W
436A:  CLRF   x93
436C:  MOVWF  x92
436E:  MOVLW  06
4370:  ADDWF  x92,W
4372:  MOVWF  01
4374:  MOVLW  00
4376:  ADDWFC x93,W
4378:  MOVWF  03
437A:  MOVF   01,W
437C:  ADDLW  18
437E:  MOVWF  FE9
4380:  MOVLW  03
4382:  ADDWFC 03,W
4384:  MOVWF  FEA
4386:  MOVFF  38E,FEF
438A:  MOVFF  38F,FEC
438E:  MOVFF  390,FEC
4392:  MOVFF  391,FEC
.................... 					alarm[i].cnValid	= 0; 
4396:  MOVF   x88,W
4398:  MULLW  0B
439A:  MOVF   FF3,W
439C:  CLRF   x93
439E:  MOVWF  x92
43A0:  MOVLW  0A
43A2:  ADDWF  x92,W
43A4:  MOVWF  01
43A6:  MOVLW  00
43A8:  ADDWFC x93,W
43AA:  MOVWF  03
43AC:  MOVF   01,W
43AE:  ADDLW  18
43B0:  MOVWF  FE9
43B2:  MOVLW  03
43B4:  ADDWFC 03,W
43B6:  MOVWF  FEA
43B8:  CLRF   FEF
.................... 					done = 1; 
43BA:  MOVLW  01
43BC:  MOVWF  x89
.................... 					break; 
43BE:  BRA    43C4
.................... 				} 
.................... 			} 
43C0:  INCF   x88,F
43C2:  BRA    42D2
.................... 		} 
.................... 		else { 
43C4:  BRA    43CC
.................... 			return TYP_SMS_AA;	 
43C6:  MOVLW  02
43C8:  MOVWF  01
43CA:  BRA    4A04
.................... 		} 
.................... 		if (done == 0) return TYP_SMS_ERR;		// Si no encuentra lugar libre para alarma sale con error 
43CC:  MOVF   x89,F
43CE:  BNZ   43D6
43D0:  MOVLW  F0
43D2:  MOVWF  01
43D4:  BRA    4A04
.................... 		//-------------------------------------------------------------------------------------------- 
.................... 		return TYP_SMS_AA; 
43D6:  MOVLW  02
43D8:  MOVWF  01
43DA:  BRA    4A04
.................... 	} 
.................... 	else{ 
43DC:  BRA    4A04
43DE:  MOVLB  0
.................... 		strcpy(aux2, "BA"); 
43E0:  MOVLW  03
43E2:  MOVWF  FEA
43E4:  MOVLW  74
43E6:  MOVWF  FE9
43E8:  MOVFF  FF2,392
43EC:  BCF    FF2.7
43EE:  MOVLW  00
43F0:  CALL   0152
43F4:  TBLRD*-
43F6:  TBLRD*+
43F8:  MOVF   FF5,W
43FA:  MOVWF  FEE
43FC:  IORLW  00
43FE:  BNZ   43F6
4400:  MOVLB  3
4402:  BTFSC  x92.7
4404:  BSF    FF2.7
.................... 		if (strcmp(ptr, aux2) == 0) { 
4406:  MOVFF  37F,393
440A:  MOVFF  37E,392
440E:  MOVLW  03
4410:  MOVWF  x95
4412:  MOVLW  74
4414:  MOVWF  x94
4416:  MOVLB  0
4418:  CALL   3BE4
441C:  MOVF   01,F
441E:  BTFSS  FD8.2
4420:  BRA    452C
.................... 			//-------------------------------- Procesa Baja de alarma -------------------------------- 
.................... 			ptr = strtok(null, sepCh); 
4422:  MOVLB  3
4424:  CLRF   x93
4426:  CLRF   x92
4428:  MOVLW  03
442A:  MOVWF  x95
442C:  MOVLW  7C
442E:  MOVWF  x94
4430:  MOVLB  0
4432:  CALL   388E
4436:  MOVFF  02,37F
443A:  MOVFF  01,37E
.................... 			if (ptr != NULL) typeAlrm = *ptr;		// Tipo alarma 
443E:  MOVLB  3
4440:  MOVF   x7E,F
4442:  BNZ   4448
4444:  MOVF   x7F,F
4446:  BZ    4456
4448:  MOVFF  37E,FE9
444C:  MOVFF  37F,FEA
4450:  MOVFF  FEF,387
.................... 			else return TYP_SMS_ERR; 
4454:  BRA    445C
4456:  MOVLW  F0
4458:  MOVWF  01
445A:  BRA    4A04
.................... 			// 
.................... 			ptr = strtok(null, sepCh); 
445C:  CLRF   x93
445E:  CLRF   x92
4460:  MOVLW  03
4462:  MOVWF  x95
4464:  MOVLW  7C
4466:  MOVWF  x94
4468:  MOVLB  0
446A:  CALL   388E
446E:  MOVFF  02,37F
4472:  MOVFF  01,37E
.................... 			if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4476:  MOVLB  3
4478:  MOVF   x7E,F
447A:  BNZ   4480
447C:  MOVF   x7F,F
447E:  BZ    449A
4480:  MOVLW  01
4482:  MOVWF  FEA
4484:  MOVLW  7C
4486:  MOVWF  FE9
4488:  MOVFF  37F,FE2
448C:  MOVFF  37E,FE1
4490:  MOVF   FE7,F
4492:  MOVFF  FE6,FEE
4496:  BNZ   4490
.................... 			else return TYP_SMS_ERR; 
4498:  BRA    44A0
449A:  MOVLW  F0
449C:  MOVWF  01
449E:  BRA    4A04
.................... 			// 
.................... 			done = 0; 
44A0:  CLRF   x89
.................... 			for (i = 0; i < 5; i++){ 
44A2:  CLRF   x88
44A4:  MOVF   x88,W
44A6:  SUBLW  04
44A8:  BNC   4518
.................... 				if (alarm[i].variable == typeAlrm){		// Busca alarma para eliminar 
44AA:  MOVF   x88,W
44AC:  MULLW  0B
44AE:  MOVF   FF3,W
44B0:  CLRF   x93
44B2:  MOVWF  x92
44B4:  MOVLW  01
44B6:  ADDWF  x92,W
44B8:  MOVWF  01
44BA:  MOVLW  00
44BC:  ADDWFC x93,W
44BE:  MOVWF  03
44C0:  MOVF   01,W
44C2:  ADDLW  18
44C4:  MOVWF  FE9
44C6:  MOVLW  03
44C8:  ADDWFC 03,W
44CA:  MOVWF  FEA
44CC:  MOVF   x87,W
44CE:  SUBWF  FEF,W
44D0:  BNZ   4514
.................... 					alarm[i].activa 	= 0; 
44D2:  MOVF   x88,W
44D4:  MULLW  0B
44D6:  MOVF   FF3,W
44D8:  CLRF   x93
44DA:  MOVWF  x92
44DC:  MOVLW  18
44DE:  ADDWF  x92,W
44E0:  MOVWF  FE9
44E2:  MOVLW  03
44E4:  ADDWFC x93,W
44E6:  MOVWF  FEA
44E8:  CLRF   FEF
.................... 					alarm[i].cnValid	= 0; 
44EA:  MOVF   x88,W
44EC:  MULLW  0B
44EE:  MOVF   FF3,W
44F0:  CLRF   x93
44F2:  MOVWF  x92
44F4:  MOVLW  0A
44F6:  ADDWF  x92,W
44F8:  MOVWF  01
44FA:  MOVLW  00
44FC:  ADDWFC x93,W
44FE:  MOVWF  03
4500:  MOVF   01,W
4502:  ADDLW  18
4504:  MOVWF  FE9
4506:  MOVLW  03
4508:  ADDWFC 03,W
450A:  MOVWF  FEA
450C:  CLRF   FEF
.................... 					done = 1; 
450E:  MOVLW  01
4510:  MOVWF  x89
.................... 					break; 
4512:  BRA    4518
.................... 				} 
.................... 			} 
4514:  INCF   x88,F
4516:  BRA    44A4
.................... 			if (done == 0) return TYP_SMS_ERR;		// Si no encuentra alarma sale con error 
4518:  MOVF   x89,F
451A:  BNZ   4522
451C:  MOVLW  F0
451E:  MOVWF  01
4520:  BRA    4A04
.................... 			//---------------------------------------------------------------------------------------- 
.................... 			return TYP_SMS_BA; 
4522:  MOVLW  03
4524:  MOVWF  01
4526:  BRA    4A04
.................... 		} 
.................... 		else{ 
4528:  BRA    4A04
452A:  MOVLB  0
.................... 			strcpy(aux2, "CLIMA"); 
452C:  MOVLW  03
452E:  MOVWF  FEA
4530:  MOVLW  74
4532:  MOVWF  FE9
4534:  MOVFF  FF2,392
4538:  BCF    FF2.7
453A:  MOVLW  00
453C:  CALL   0170
4540:  TBLRD*-
4542:  TBLRD*+
4544:  MOVF   FF5,W
4546:  MOVWF  FEE
4548:  IORLW  00
454A:  BNZ   4542
454C:  MOVLB  3
454E:  BTFSC  x92.7
4550:  BSF    FF2.7
.................... 			if (strcmp(ptr, aux2) == 0) { 
4552:  MOVFF  37F,393
4556:  MOVFF  37E,392
455A:  MOVLW  03
455C:  MOVWF  x95
455E:  MOVLW  74
4560:  MOVWF  x94
4562:  MOVLB  0
4564:  CALL   3BE4
4568:  MOVF   01,F
456A:  BNZ   45BC
.................... 				//---------------------------- Procesa Pedido de medicion ---------------------------- 
.................... 				ptr = strtok(null, sepCh); 
456C:  MOVLB  3
456E:  CLRF   x93
4570:  CLRF   x92
4572:  MOVLW  03
4574:  MOVWF  x95
4576:  MOVLW  7C
4578:  MOVWF  x94
457A:  MOVLB  0
457C:  CALL   388E
4580:  MOVFF  02,37F
4584:  MOVFF  01,37E
.................... 				if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4588:  MOVLB  3
458A:  MOVF   x7E,F
458C:  BNZ   4592
458E:  MOVF   x7F,F
4590:  BZ    45AC
4592:  MOVLW  01
4594:  MOVWF  FEA
4596:  MOVLW  7C
4598:  MOVWF  FE9
459A:  MOVFF  37F,FE2
459E:  MOVFF  37E,FE1
45A2:  MOVF   FE7,F
45A4:  MOVFF  FE6,FEE
45A8:  BNZ   45A2
.................... 				else return TYP_SMS_ERR; 
45AA:  BRA    45B2
45AC:  MOVLW  F0
45AE:  MOVWF  01
45B0:  BRA    4A04
.................... 				//------------------------------------------------------------------------------------ 
.................... 				return TYP_SMS_CON; 
45B2:  MOVLW  01
45B4:  MOVWF  01
45B6:  BRA    4A04
.................... 			} 
.................... 			else { 
45B8:  BRA    4A04
45BA:  MOVLB  0
.................... 				strcpy(aux2, "SETRTC"); 
45BC:  MOVLW  03
45BE:  MOVWF  FEA
45C0:  MOVLW  74
45C2:  MOVWF  FE9
45C4:  MOVFF  FF2,392
45C8:  BCF    FF2.7
45CA:  MOVLW  00
45CC:  CALL   0190
45D0:  TBLRD*-
45D2:  TBLRD*+
45D4:  MOVF   FF5,W
45D6:  MOVWF  FEE
45D8:  IORLW  00
45DA:  BNZ   45D2
45DC:  MOVLB  3
45DE:  BTFSC  x92.7
45E0:  BSF    FF2.7
.................... 				if (strcmp(ptr, aux2) == 0){  
45E2:  MOVFF  37F,393
45E6:  MOVFF  37E,392
45EA:  MOVLW  03
45EC:  MOVWF  x95
45EE:  MOVLW  74
45F0:  MOVWF  x94
45F2:  MOVLB  0
45F4:  CALL   3BE4
45F8:  MOVF   01,F
45FA:  BTFSS  FD8.2
45FC:  BRA    47C2
.................... 					//------------------------ Procesa Puesta en hora de RTC ------------------------- 
.................... 					ptr = strtok(NULL, sepCh); 
45FE:  MOVLB  3
4600:  CLRF   x93
4602:  CLRF   x92
4604:  MOVLW  03
4606:  MOVWF  x95
4608:  MOVLW  7C
460A:  MOVWF  x94
460C:  MOVLB  0
460E:  CALL   388E
4612:  MOVFF  02,37F
4616:  MOVFF  01,37E
.................... 					if (ptr != NULL) hora = atoi(ptr); 
461A:  MOVLB  3
461C:  MOVF   x7E,F
461E:  BNZ   4624
4620:  MOVF   x7F,F
4622:  BZ    463A
4624:  MOVFF  37F,3FE
4628:  MOVFF  37E,3FD
462C:  MOVLB  0
462E:  CALL   0B40
4632:  MOVFF  01,382
.................... 					else return TYP_SMS_ERR; 
4636:  BRA    4640
4638:  MOVLB  3
463A:  MOVLW  F0
463C:  MOVWF  01
463E:  BRA    4A04
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
4640:  MOVLB  3
4642:  CLRF   x93
4644:  CLRF   x92
4646:  MOVLW  03
4648:  MOVWF  x95
464A:  MOVLW  7C
464C:  MOVWF  x94
464E:  MOVLB  0
4650:  CALL   388E
4654:  MOVFF  02,37F
4658:  MOVFF  01,37E
.................... 					if (ptr != NULL) min = atoi(ptr); 
465C:  MOVLB  3
465E:  MOVF   x7E,F
4660:  BNZ   4666
4662:  MOVF   x7F,F
4664:  BZ    467C
4666:  MOVFF  37F,3FE
466A:  MOVFF  37E,3FD
466E:  MOVLB  0
4670:  CALL   0B40
4674:  MOVFF  01,383
.................... 					else return TYP_SMS_ERR; 
4678:  BRA    4682
467A:  MOVLB  3
467C:  MOVLW  F0
467E:  MOVWF  01
4680:  BRA    4A04
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
4682:  MOVLB  3
4684:  CLRF   x93
4686:  CLRF   x92
4688:  MOVLW  03
468A:  MOVWF  x95
468C:  MOVLW  7C
468E:  MOVWF  x94
4690:  MOVLB  0
4692:  CALL   388E
4696:  MOVFF  02,37F
469A:  MOVFF  01,37E
.................... 					if (ptr != NULL) dia = atoi(ptr); 
469E:  MOVLB  3
46A0:  MOVF   x7E,F
46A2:  BNZ   46A8
46A4:  MOVF   x7F,F
46A6:  BZ    46BE
46A8:  MOVFF  37F,3FE
46AC:  MOVFF  37E,3FD
46B0:  MOVLB  0
46B2:  CALL   0B40
46B6:  MOVFF  01,384
.................... 					else return TYP_SMS_ERR; 
46BA:  BRA    46C4
46BC:  MOVLB  3
46BE:  MOVLW  F0
46C0:  MOVWF  01
46C2:  BRA    4A04
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
46C4:  MOVLB  3
46C6:  CLRF   x93
46C8:  CLRF   x92
46CA:  MOVLW  03
46CC:  MOVWF  x95
46CE:  MOVLW  7C
46D0:  MOVWF  x94
46D2:  MOVLB  0
46D4:  CALL   388E
46D8:  MOVFF  02,37F
46DC:  MOVFF  01,37E
.................... 					if (ptr != NULL) mes = atoi(ptr); 
46E0:  MOVLB  3
46E2:  MOVF   x7E,F
46E4:  BNZ   46EA
46E6:  MOVF   x7F,F
46E8:  BZ    4700
46EA:  MOVFF  37F,3FE
46EE:  MOVFF  37E,3FD
46F2:  MOVLB  0
46F4:  CALL   0B40
46F8:  MOVFF  01,385
.................... 					else return TYP_SMS_ERR; 
46FC:  BRA    4706
46FE:  MOVLB  3
4700:  MOVLW  F0
4702:  MOVWF  01
4704:  BRA    4A04
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
4706:  MOVLB  3
4708:  CLRF   x93
470A:  CLRF   x92
470C:  MOVLW  03
470E:  MOVWF  x95
4710:  MOVLW  7C
4712:  MOVWF  x94
4714:  MOVLB  0
4716:  CALL   388E
471A:  MOVFF  02,37F
471E:  MOVFF  01,37E
.................... 					if (ptr != NULL) year = atoi(ptr+2); 
4722:  MOVLB  3
4724:  MOVF   x7E,F
4726:  BNZ   472C
4728:  MOVF   x7F,F
472A:  BZ    474C
472C:  MOVLW  02
472E:  ADDWF  x7E,W
4730:  MOVWF  x92
4732:  MOVLW  00
4734:  ADDWFC x7F,W
4736:  MOVWF  x93
4738:  MOVWF  xFE
473A:  MOVFF  392,3FD
473E:  MOVLB  0
4740:  CALL   0B40
4744:  MOVFF  01,386
.................... 					else return TYP_SMS_ERR; 
4748:  BRA    4752
474A:  MOVLB  3
474C:  MOVLW  F0
474E:  MOVWF  01
4750:  BRA    4A04
.................... 					// 
.................... 					ptr = strtok(NULL, sepCh); 
4752:  MOVLB  3
4754:  CLRF   x93
4756:  CLRF   x92
4758:  MOVLW  03
475A:  MOVWF  x95
475C:  MOVLW  7C
475E:  MOVWF  x94
4760:  MOVLB  0
4762:  CALL   388E
4766:  MOVFF  02,37F
476A:  MOVFF  01,37E
.................... 					if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
476E:  MOVLB  3
4770:  MOVF   x7E,F
4772:  BNZ   4778
4774:  MOVF   x7F,F
4776:  BZ    4792
4778:  MOVLW  01
477A:  MOVWF  FEA
477C:  MOVLW  7C
477E:  MOVWF  FE9
4780:  MOVFF  37F,FE2
4784:  MOVFF  37E,FE1
4788:  MOVF   FE7,F
478A:  MOVFF  FE6,FEE
478E:  BNZ   4788
.................... 					else return TYP_SMS_ERR; 
4790:  BRA    4798
4792:  MOVLW  F0
4794:  MOVWF  01
4796:  BRA    4A04
....................  
.................... 					rtc_set_datetime(dia, mes, year, 1, hora, min); 
4798:  MOVFF  384,392
479C:  MOVFF  385,393
47A0:  MOVFF  386,394
47A4:  MOVLW  01
47A6:  MOVWF  x95
47A8:  MOVFF  382,396
47AC:  MOVFF  383,397
47B0:  MOVLB  0
47B2:  GOTO   3EF2
....................  
.................... 					return TYP_SMS_RTC; 
47B6:  MOVLW  05
47B8:  MOVWF  01
47BA:  MOVLB  3
47BC:  BRA    4A04
.................... 				} 
.................... 				else { 
47BE:  BRA    4A04
47C0:  MOVLB  0
.................... 					// 
.................... 					strcpy(aux2, "INITMEM"); 
47C2:  MOVLW  03
47C4:  MOVWF  FEA
47C6:  MOVLW  74
47C8:  MOVWF  FE9
47CA:  MOVFF  FF2,392
47CE:  BCF    FF2.7
47D0:  MOVLW  00
47D2:  CALL   01B2
47D6:  TBLRD*-
47D8:  TBLRD*+
47DA:  MOVF   FF5,W
47DC:  MOVWF  FEE
47DE:  IORLW  00
47E0:  BNZ   47D8
47E2:  MOVLB  3
47E4:  BTFSC  x92.7
47E6:  BSF    FF2.7
.................... 					if (strcmp(ptr, aux2) == 0){  
47E8:  MOVFF  37F,393
47EC:  MOVFF  37E,392
47F0:  MOVLW  03
47F2:  MOVWF  x95
47F4:  MOVLW  74
47F6:  MOVWF  x94
47F8:  MOVLB  0
47FA:  CALL   3BE4
47FE:  MOVF   01,F
4800:  BNZ   484E
.................... 						inicializa_eeprom(); 						// Inicializa memoria eeprom  
4802:  GOTO   3FAE
.................... 						ptr = strtok(NULL, sepCh); 
4806:  MOVLB  3
4808:  CLRF   x93
480A:  CLRF   x92
480C:  MOVLW  03
480E:  MOVWF  x95
4810:  MOVLW  7C
4812:  MOVWF  x94
4814:  MOVLB  0
4816:  CALL   388E
481A:  MOVFF  02,37F
481E:  MOVFF  01,37E
.................... 					    if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4822:  MOVLB  3
4824:  MOVF   x7E,F
4826:  BNZ   482C
4828:  MOVF   x7F,F
482A:  BZ    4844
482C:  MOVLW  01
482E:  MOVWF  FEA
4830:  MOVLW  7C
4832:  MOVWF  FE9
4834:  MOVFF  37F,FE2
4838:  MOVFF  37E,FE1
483C:  MOVF   FE7,F
483E:  MOVFF  FE6,FEE
4842:  BNZ   483C
.................... 						 
.................... 						return TYP_SMS_INI; 
4844:  MOVLW  04
4846:  MOVWF  01
4848:  BRA    4A04
.................... 					} 
.................... 					else { 
484A:  BRA    4A04
484C:  MOVLB  0
.................... 						// 
.................... 						strcpy(aux2, "CNUMSRV"); 
484E:  MOVLW  03
4850:  MOVWF  FEA
4852:  MOVLW  74
4854:  MOVWF  FE9
4856:  MOVFF  FF2,392
485A:  BCF    FF2.7
485C:  MOVLW  00
485E:  CALL   01D4
4862:  TBLRD*-
4864:  TBLRD*+
4866:  MOVF   FF5,W
4868:  MOVWF  FEE
486A:  IORLW  00
486C:  BNZ   4864
486E:  MOVLB  3
4870:  BTFSC  x92.7
4872:  BSF    FF2.7
.................... 						strcpy(telaux, telnum); 
4874:  MOVLW  02
4876:  MOVWF  FEA
4878:  MOVLW  CC
487A:  MOVWF  FE9
487C:  MOVLW  01
487E:  MOVWF  FE2
4880:  MOVLW  48
4882:  MOVWF  FE1
4884:  MOVF   FE7,F
4886:  MOVFF  FE6,FEE
488A:  BNZ   4884
.................... 						if (strcmp(ptr, aux2) == 0){ 
488C:  MOVFF  37F,393
4890:  MOVFF  37E,392
4894:  MOVLW  03
4896:  MOVWF  x95
4898:  MOVLW  74
489A:  MOVWF  x94
489C:  MOVLB  0
489E:  CALL   3BE4
48A2:  MOVF   01,F
48A4:  BTFSS  FD8.2
48A6:  BRA    49C0
.................... 							ptr = strtok(NULL, sepCh); 
48A8:  MOVLB  3
48AA:  CLRF   x93
48AC:  CLRF   x92
48AE:  MOVLW  03
48B0:  MOVWF  x95
48B2:  MOVLW  7C
48B4:  MOVWF  x94
48B6:  MOVLB  0
48B8:  CALL   388E
48BC:  MOVFF  02,37F
48C0:  MOVFF  01,37E
.................... 							if (ptr != NULL) telnumaux = ptr; // Numero recibido 
48C4:  MOVLB  3
48C6:  MOVF   x7E,F
48C8:  BNZ   48CE
48CA:  MOVF   x7F,F
48CC:  BZ    48D8
48CE:  MOVFF  37F,381
48D2:  MOVFF  37E,380
.................... 							else return TYP_SMS_ERR; 
48D6:  BRA    48DE
48D8:  MOVLW  F0
48DA:  MOVWF  01
48DC:  BRA    4A04
.................... 							//Escribir el tel num nuevo 
.................... 							for (i = 0; i < SZ_TELEFONO; i++){ 
48DE:  CLRF   x88
48E0:  MOVF   x88,W
48E2:  SUBLW  0D
48E4:  BNC   4932
.................... 								 write_eeprom(ADDR_TELEF1+i,*telnumaux); 
48E6:  MOVLW  0A
48E8:  ADDWF  x88,W
48EA:  MOVWF  x92
48EC:  MOVFF  381,03
48F0:  MOVF   x80,W
48F2:  MOVWF  FE9
48F4:  MOVFF  03,FEA
48F8:  MOVFF  FEF,393
48FC:  MOVFF  392,FA9
4900:  MOVFF  393,FA8
4904:  BCF    FA6.6
4906:  BCF    FA6.7
4908:  BSF    FA6.2
490A:  MOVF   FF2,W
490C:  MOVWF  00
490E:  BCF    FF2.7
4910:  MOVLB  F
4912:  MOVLW  55
4914:  MOVWF  FA7
4916:  MOVLW  AA
4918:  MOVWF  FA7
491A:  BSF    FA6.1
491C:  BTFSC  FA6.1
491E:  BRA    491C
4920:  BCF    FA6.2
4922:  MOVF   00,W
4924:  IORWF  FF2,F
.................... 								 telnumaux++; 
4926:  MOVLB  3
4928:  INCF   x80,F
492A:  BTFSC  FD8.2
492C:  INCF   x81,F
.................... 							} 
492E:  INCF   x88,F
4930:  BRA    48E0
.................... 							//Leeer el num de tel nuevo 
.................... 							for (i = 0; i < SZ_TELEFONO; i++){ 
4932:  CLRF   x88
4934:  MOVF   x88,W
4936:  SUBLW  0D
4938:  BNC   497A
.................... 								telnum[i] = '\0'; 
493A:  CLRF   03
493C:  MOVF   x88,W
493E:  ADDLW  48
4940:  MOVWF  FE9
4942:  MOVLW  01
4944:  ADDWFC 03,W
4946:  MOVWF  FEA
4948:  CLRF   FEF
.................... 								telnum[i] = read_eeprom(ADDR_TELEF1+i); 
494A:  CLRF   03
494C:  MOVF   x88,W
494E:  ADDLW  48
4950:  MOVWF  FE9
4952:  MOVLW  01
4954:  ADDWFC 03,W
4956:  MOVWF  FEA
4958:  MOVLW  0A
495A:  ADDWF  x88,W
495C:  MOVWF  x94
495E:  MOVFF  FF2,395
4962:  BCF    FF2.7
4964:  MOVFF  394,FA9
4968:  BCF    FA6.6
496A:  BCF    FA6.7
496C:  BSF    FA6.0
496E:  MOVF   FA8,W
4970:  BTFSC  x95.7
4972:  BSF    FF2.7
4974:  MOVWF  FEF
.................... 							} 
4976:  INCF   x88,F
4978:  BRA    4934
.................... 							ptr = strtok(NULL, sepCh); 
497A:  CLRF   x93
497C:  CLRF   x92
497E:  MOVLW  03
4980:  MOVWF  x95
4982:  MOVLW  7C
4984:  MOVWF  x94
4986:  MOVLB  0
4988:  CALL   388E
498C:  MOVFF  02,37F
4990:  MOVFF  01,37E
.................... 							if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
4994:  MOVLB  3
4996:  MOVF   x7E,F
4998:  BNZ   499E
499A:  MOVF   x7F,F
499C:  BZ    49B6
499E:  MOVLW  01
49A0:  MOVWF  FEA
49A2:  MOVLW  7C
49A4:  MOVWF  FE9
49A6:  MOVFF  37F,FE2
49AA:  MOVFF  37E,FE1
49AE:  MOVF   FE7,F
49B0:  MOVFF  FE6,FEE
49B4:  BNZ   49AE
.................... 							return TYP_SMS_CSERV; 
49B6:  MOVLW  06
49B8:  MOVWF  01
49BA:  BRA    4A04
.................... 						}else{  
49BC:  BRA    4A04
49BE:  MOVLB  0
.................... 							ptr = strtok(NULL, sepCh); 
49C0:  MOVLB  3
49C2:  CLRF   x93
49C4:  CLRF   x92
49C6:  MOVLW  03
49C8:  MOVWF  x95
49CA:  MOVLW  7C
49CC:  MOVWF  x94
49CE:  MOVLB  0
49D0:  CALL   388E
49D4:  MOVFF  02,37F
49D8:  MOVFF  01,37E
.................... 							if (ptr != NULL) strcpy(tokenSrv, ptr);	// Valor de token enviado por servidor 
49DC:  MOVLB  3
49DE:  MOVF   x7E,F
49E0:  BNZ   49E6
49E2:  MOVF   x7F,F
49E4:  BZ    49FE
49E6:  MOVLW  01
49E8:  MOVWF  FEA
49EA:  MOVLW  7C
49EC:  MOVWF  FE9
49EE:  MOVFF  37F,FE2
49F2:  MOVFF  37E,FE1
49F6:  MOVF   FE7,F
49F8:  MOVFF  FE6,FEE
49FC:  BNZ   49F6
.................... 							return TYP_SMS_ERR; 
49FE:  MOVLW  F0
4A00:  MOVWF  01
4A02:  BRA    4A04
.................... 						} 
.................... 					}				 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
.................... } 
4A04:  MOVLB  0
4A06:  GOTO   5066 (RETURN)
....................  
.................... /************************************************************************************************ 
.................... | void GenerateToken(void) 
.................... | Crea el token para enviar por la estacion 
.................... ************************************************************************************************/ 
.................... void GenerateToken(void) 
.................... { 
.................... 	int valTkn; 
.................... 	tokenEma[2] = 0; 
*
0E3E:  MOVLB  1
0E40:  CLRF   x81
.................... 	valTkn = atoi(tokenEma); 
0E42:  MOVLW  01
0E44:  MOVLB  3
0E46:  MOVWF  xFE
0E48:  MOVLW  7F
0E4A:  MOVWF  xFD
0E4C:  MOVLB  0
0E4E:  RCALL  0B40
0E50:  MOVFF  01,3FC
.................... 	valTkn++; 
0E54:  MOVLB  3
0E56:  INCF   xFC,F
.................... 	if (valTkn > 99) valTkn = 0; 
0E58:  MOVF   xFC,W
0E5A:  SUBLW  63
0E5C:  BTFSS  FD8.0
0E5E:  CLRF   xFC
.................... 	sprintf(tokenEma, "%02d", valTkn); 
0E60:  MOVLW  01
0E62:  MOVLB  1
0E64:  MOVWF  x47
0E66:  MOVLW  7F
0E68:  MOVWF  x46
0E6A:  MOVFF  3FC,3FD
0E6E:  MOVLW  01
0E70:  MOVLB  3
0E72:  MOVWF  xFE
0E74:  MOVLB  0
0E76:  RCALL  0D44
.................... } 
0E78:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------- 
.................... // 
.................... //------------------------------ Comienzo del programa principal -------------------------------- 
.................... // 
.................... //----------------------------------------------------------------------------------------------- 
.................... void main() 
.................... { 
*
4AFA:  CLRF   FF8
4AFC:  BCF    FD0.7
4AFE:  BSF    07.7
4B00:  CLRF   FEA
4B02:  CLRF   FE9
4B04:  MOVLW  0C
4B06:  MOVWF  FAF
4B08:  MOVLW  A2
4B0A:  MOVWF  FAC
4B0C:  MOVLW  90
4B0E:  MOVWF  FAB
4B10:  MOVLB  1
4B12:  CLRF   x17
4B14:  BSF    FC1.0
4B16:  BSF    FC1.1
4B18:  BSF    FC1.2
4B1A:  BCF    FC1.3
4B1C:  CLRF   16
4B1E:  CLRF   x1A
4B20:  CLRF   x1B
4B22:  MOVLW  4F
4B24:  MOVWF  x20
4B26:  MOVLW  4B
4B28:  MOVWF  x21
4B2A:  CLRF   x22
4B2C:  MOVLW  52
4B2E:  MOVWF  x23
4B30:  MOVLW  44
4B32:  MOVWF  x24
4B34:  MOVLW  59
4B36:  MOVWF  x25
4B38:  CLRF   x26
4B3A:  MOVLW  55
4B3C:  MOVWF  x27
4B3E:  MOVLW  4E
4B40:  MOVWF  x28
4B42:  MOVLW  52
4B44:  MOVWF  x29
4B46:  MOVLW  45
4B48:  MOVWF  x2A
4B4A:  MOVLW  41
4B4C:  MOVWF  x2B
4B4E:  MOVLW  44
4B50:  MOVWF  x2C
4B52:  CLRF   x2D
4B54:  MOVLW  3E
4B56:  MOVWF  x2E
4B58:  CLRF   x2F
4B5A:  CLRF   x46
4B5C:  CLRF   x47
4B5E:  MOVLW  2B
4B60:  MOVWF  x48
4B62:  MOVLW  35
4B64:  MOVWF  x49
4B66:  MOVLW  34
4B68:  MOVWF  x4A
4B6A:  MOVLW  39
4B6C:  MOVWF  x4B
4B6E:  MOVLW  33
4B70:  MOVWF  x4C
4B72:  MOVLW  34
4B74:  MOVWF  x4D
4B76:  MOVLW  31
4B78:  MOVWF  x4E
4B7A:  MOVLW  36
4B7C:  MOVWF  x4F
4B7E:  MOVLW  35
4B80:  MOVWF  x50
4B82:  MOVLW  32
4B84:  MOVWF  x51
4B86:  MOVLW  37
4B88:  MOVWF  x52
4B8A:  MOVLW  31
4B8C:  MOVWF  x53
4B8E:  MOVLW  30
4B90:  MOVWF  x54
4B92:  MOVLW  35
4B94:  MOVWF  x55
4B96:  CLRF   x56
4B98:  MOVLW  2A
4B9A:  MOVWF  x57
4B9C:  CLRF   x58
.................... 	int i; 
.................... 	// Desactivamos las interrupciones. 
.................... 	disable_interrupts(GLOBAL); 
4B9E:  BCF    FF2.6
4BA0:  BCF    FF2.7
4BA2:  BTFSC  FF2.7
4BA4:  BRA    4BA0
.................... 	disable_interrupts(INT_rda); 
4BA6:  BCF    F9D.5
.................... 	disable_interrupts(INT_EXT2); 
4BA8:  BCF    FF0.4
.................... 	//------------------------ Inicializar puertos -------------------	 
.................... 	set_tris_a(KIOPTOA); 
4BAA:  MOVLW  F3
4BAC:  MOVWF  F92
....................     set_tris_b(KIOPTOB); 
4BAE:  MOVLW  F7
4BB0:  MOVWF  F93
....................     set_tris_c(KIOPTOC); 
4BB2:  MOVLW  81
4BB4:  MOVWF  F94
....................  
.................... 	//Habilito el WatchDog 
.................... 	setup_wdt(WDT_ON); 
4BB6:  BSF    FD1.0
.................... 	// Configuramos el oscilador. 
.................... 	setup_oscillator(OSC_NORMAL);     
4BB8:  CLRF   FD3
.................... 	port_b_pullups(TRUE); 
4BBA:  BCF    FF1.7
.................... 	// Configuramos el conversor AD. 
.................... 	setup_adc(ADC_CLOCK_INTERNAL);  
4BBC:  BCF    FC1.6
4BBE:  BSF    FC2.6
4BC0:  BSF    FC2.7
4BC2:  BSF    FC1.7
4BC4:  BSF    FC2.0
.................... 	//setup_adc_ports(AN0_TO_AN1|VSS_VDD);      
....................     setup_adc_ports(AN0);  
4BC6:  BCF    FC1.0
4BC8:  BSF    FC1.1
4BCA:  BSF    FC1.2
4BCC:  BSF    FC1.3
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32);        //1.0 s overflow 
4BCE:  MOVLW  84
4BD0:  MOVWF  FD5
....................     setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
4BD2:  CLRF   FB1
....................     // 
.................... 	if (input(INP_PREC) == 0){   		// Estado inicial 
4BD4:  BTFSC  F81.2
4BD6:  BRA    4BDE
....................    		ext_int_edge(2, L_TO_H);  	// Configuro flanco de subida 
4BD8:  BSF    FF1.4
....................   		flagInt2Edge = 0;    		// Indico que el siguiente flanco será de Subida 
4BDA:  BCF    x59.0
....................  	}  
.................... 	else {    
4BDC:  BRA    4BE2
.................... 		ext_int_edge(2, H_TO_L);  	// Configuro flanco de Bajada 
4BDE:  BCF    FF1.4
....................   		flagInt2Edge = 1;    		// Indico que el siguiente flanco será de Bajada 
4BE0:  BSF    x59.0
....................  	}	 
....................  
.................... 	//----------------------- Inicializar variables ------------------ 
.................... 	runOk 		= 1; 
4BE2:  MOVLW  01
4BE4:  MOVWF  x6E
.................... 	guia        = 1; 
4BE6:  MOVWF  x30
.................... 	address 	= 0; 
4BE8:  MOVLB  2
4BEA:  CLRF   xE5
4BEC:  CLRF   xE4
.................... 	data 		= 0b10101010; 
4BEE:  MOVLW  AA
4BF0:  MOVWF  xE8
.................... 	temp		= 0; 
4BF2:  CLRF   xE9
.................... 	adc_val 	= 0; 
4BF4:  MOVLB  1
4BF6:  CLRF   x5B
4BF8:  CLRF   x5A
.................... 	secUltMed   = 0; 
4BFA:  CLRF   x7A
4BFC:  CLRF   x79
4BFE:  CLRF   x78
4C00:  CLRF   x77
.................... 	sensorHab 	= read_eeprom(ADDR_HAB_L);  
4C02:  MOVFF  FF2,354
4C06:  BCF    FF2.7
4C08:  CLRF   FA9
4C0A:  BCF    FA6.6
4C0C:  BCF    FA6.7
4C0E:  BSF    FA6.0
4C10:  MOVF   FA8,W
4C12:  MOVLB  3
4C14:  BTFSC  x54.7
4C16:  BSF    FF2.7
4C18:  MOVLB  1
4C1A:  MOVWF  x7B
.................... 	timeMed 	= read_eeprom(ADDR_TMED_L) + (read_eeprom(ADDR_TMED_H) * 256); 
4C1C:  MOVFF  FF2,354
4C20:  BCF    FF2.7
4C22:  MOVLW  02
4C24:  MOVWF  FA9
4C26:  BCF    FA6.6
4C28:  BCF    FA6.7
4C2A:  BSF    FA6.0
4C2C:  MOVF   FA8,W
4C2E:  MOVLB  3
4C30:  BTFSC  x54.7
4C32:  BSF    FF2.7
4C34:  MOVWF  x55
4C36:  MOVFF  FF2,356
4C3A:  BCF    FF2.7
4C3C:  MOVLW  03
4C3E:  MOVWF  FA9
4C40:  BCF    FA6.6
4C42:  BCF    FA6.7
4C44:  BSF    FA6.0
4C46:  MOVF   FA8,W
4C48:  BTFSC  x56.7
4C4A:  BSF    FF2.7
4C4C:  MOVWF  x58
4C4E:  CLRF   x7F
4C50:  MOVFF  358,37E
4C54:  MOVLW  01
4C56:  MOVWF  x81
4C58:  CLRF   x80
4C5A:  MOVLB  0
4C5C:  CALL   0418
4C60:  MOVFF  02,03
4C64:  MOVF   01,W
4C66:  MOVLB  3
4C68:  ADDWF  x55,W
4C6A:  MOVLB  1
4C6C:  MOVWF  x5E
4C6E:  MOVLW  00
4C70:  ADDWFC 03,W
4C72:  MOVWF  x5F
.................... 	timeMedTmp 	= timeMed; 
4C74:  MOVFF  15F,161
4C78:  MOVFF  15E,160
.................... 	timeChk		= read_eeprom(ADDR_TCHK_L) + (read_eeprom(ADDR_TCHK_H) * 256); 
4C7C:  MOVFF  FF2,354
4C80:  BCF    FF2.7
4C82:  MOVLW  04
4C84:  MOVWF  FA9
4C86:  BCF    FA6.6
4C88:  BCF    FA6.7
4C8A:  BSF    FA6.0
4C8C:  MOVF   FA8,W
4C8E:  MOVLB  3
4C90:  BTFSC  x54.7
4C92:  BSF    FF2.7
4C94:  MOVWF  x55
4C96:  MOVFF  FF2,356
4C9A:  BCF    FF2.7
4C9C:  MOVLW  05
4C9E:  MOVWF  FA9
4CA0:  BCF    FA6.6
4CA2:  BCF    FA6.7
4CA4:  BSF    FA6.0
4CA6:  MOVF   FA8,W
4CA8:  BTFSC  x56.7
4CAA:  BSF    FF2.7
4CAC:  MOVWF  x58
4CAE:  CLRF   x7F
4CB0:  MOVFF  358,37E
4CB4:  MOVLW  01
4CB6:  MOVWF  x81
4CB8:  CLRF   x80
4CBA:  MOVLB  0
4CBC:  CALL   0418
4CC0:  MOVFF  02,03
4CC4:  MOVF   01,W
4CC6:  MOVLB  3
4CC8:  ADDWF  x55,W
4CCA:  MOVLB  1
4CCC:  MOVWF  x66
4CCE:  MOVLW  00
4CD0:  ADDWFC 03,W
4CD2:  MOVWF  x67
.................... 	timeChkTmp  = timeChk; 
4CD4:  MOVFF  167,165
4CD8:  MOVFF  166,164
.................... 	ctePluv 	= KTE_PLUV; 	//ctePluv		= read_eeprom(ADDR_KPLUV_L) + (read_eeprom(ADDR_KPLUV_H) * 256); 
4CDC:  MOVLW  AE
4CDE:  MOVWF  x6D
4CE0:  MOVLW  47
4CE2:  MOVWF  x6C
4CE4:  MOVLW  61
4CE6:  MOVWF  x6B
4CE8:  MOVLW  7D
4CEA:  MOVWF  x6A
.................... 	timeRestart = K_TIME_RESTART; 
4CEC:  MOVLW  17
4CEE:  MOVWF  x69
4CF0:  MOVLW  70
4CF2:  MOVWF  x68
.................... 	 
.................... 	//Escribir el telnum por defecto en la eeprom 
.................... 	for (i = 0; i < SZ_TELEFONO; i++){ 
4CF4:  MOVLB  3
4CF6:  CLRF   x4F
4CF8:  MOVF   x4F,W
4CFA:  SUBLW  0D
4CFC:  BNC   4D46
.................... 		 write_eeprom(ADDR_TELEF1+i, telnum[i]); 
4CFE:  MOVLW  0A
4D00:  ADDWF  x4F,W
4D02:  MOVWF  x54
4D04:  CLRF   03
4D06:  MOVF   x4F,W
4D08:  ADDLW  48
4D0A:  MOVWF  FE9
4D0C:  MOVLW  01
4D0E:  ADDWFC 03,W
4D10:  MOVWF  FEA
4D12:  MOVFF  FEF,355
4D16:  MOVFF  354,FA9
4D1A:  MOVFF  355,FA8
4D1E:  BCF    FA6.6
4D20:  BCF    FA6.7
4D22:  BSF    FA6.2
4D24:  MOVF   FF2,W
4D26:  MOVWF  00
4D28:  BCF    FF2.7
4D2A:  MOVLB  F
4D2C:  MOVLW  55
4D2E:  MOVWF  FA7
4D30:  MOVLW  AA
4D32:  MOVWF  FA7
4D34:  BSF    FA6.1
4D36:  BTFSC  FA6.1
4D38:  BRA    4D36
4D3A:  BCF    FA6.2
4D3C:  MOVF   00,W
4D3E:  IORWF  FF2,F
.................... 	} 
4D40:  MOVLB  3
4D42:  INCF   x4F,F
4D44:  BRA    4CF8
.................... 							 
.................... 	contData	= 0; 
4D46:  MOVLB  2
4D48:  CLRF   xE7
4D4A:  CLRF   xE6
.................... 	ReadAlarmStruct();					// Lee alarmas guardadas en eeprom interna 
4D4C:  MOVLB  0
4D4E:  GOTO   043A
.................... 	//----------------------- Flags --------------------------------- 
.................... 	flagInt2Edge 	= 0;				// Indica flanco pluviometro 
4D52:  MOVLB  1
4D54:  BCF    x59.0
.................... 	memoryFull      = 0;                // Indica cuando no hay mas memoria 
4D56:  CLRF   x71
.................... 	startMeasure 	= 0;				// Indica tiempo de iniciar mediciones 
4D58:  CLRF   x73
.................... 	startCheck	 	= 0;				// Indica tiempo de iniciar chequeo interno 
4D5A:  CLRF   x74
....................  	startRestart 	= 0;				// Indica tiempo de iniciar reinicio de modem 
4D5C:  CLRF   x75
.................... 	countPrec 		= 0;				// Contador de precipitaciones 
4D5E:  CLRF   x5D
4D60:  CLRF   x5C
.................... 	smsMemSnd		= 0;				// Indica mensaje de memoria llena enviado 
4D62:  CLRF   x72
.................... 	llueveAhora     = 0; 		//Indica si esta lloviendo en este momento 
4D64:  CLRF   x76
.................... 	//---------------------------------------------------------------- 
.................... 	//------------------------ Habilitar Interrupciones -------------- 
.................... 	enable_interrupts(INT_TIMER0); 
4D66:  BSF    FF2.5
....................    	enable_interrupts(INT_EXT2); 
4D68:  BSF    FF0.4
....................     enable_interrupts(INT_RDA); 
4D6A:  BSF    F9D.5
.................... 	clear_interrupt(INT_TIMER0); 
4D6C:  BCF    FF2.2
.................... 	clear_interrupt(INT_EXT2); 
4D6E:  BCF    FF0.1
.................... 	clear_interrupt(INT_RDA); 
....................     enable_interrupts(GLOBAL); 
4D70:  MOVLW  C0
4D72:  IORWF  FF2,F
.................... 	//------------------------ Inicializar dispositivos -------------- 
....................     rtc_init(); 
4D74:  MOVLB  0
4D76:  GOTO   0516
....................     sht_init(); 
4D7A:  GOTO   0604
....................     init_ext_eeprom(); 
4D7E:  GOTO   0614
....................     output_bit(LED1, 1); 
4D82:  BSF    F89.3
....................     output_bit(LED2, 1); 
4D84:  BSF    F89.2
.................... 	delay_ms(500); 
4D86:  MOVLW  02
4D88:  MOVLB  3
4D8A:  MOVWF  x54
4D8C:  MOVLW  FA
4D8E:  MOVWF  x74
4D90:  MOVLB  0
4D92:  CALL   05D4
4D96:  MOVLB  3
4D98:  DECFSZ x54,F
4D9A:  BRA    4D8C
....................     output_bit(LED1, 0); 
4D9C:  BCF    F89.3
....................     output_bit(LED2, 0); 
4D9E:  BCF    F89.2
....................     delay_ms(500); 
4DA0:  MOVLW  02
4DA2:  MOVWF  x54
4DA4:  MOVLW  FA
4DA6:  MOVWF  x74
4DA8:  MOVLB  0
4DAA:  CALL   05D4
4DAE:  MOVLB  3
4DB0:  DECFSZ x54,F
4DB2:  BRA    4DA4
.................... 	modulo_gsm_init();   		// inicio modem GSM 
4DB4:  MOVLB  0
4DB6:  CALL   07C0
....................     delay_ms(90000);            // 90 segundos de yapa 
4DBA:  MOVLW  8B
4DBC:  MOVLB  3
4DBE:  MOVWF  x54
4DC0:  MOVLW  B0
4DC2:  MOVWF  x74
4DC4:  MOVLB  0
4DC6:  CALL   05D4
4DCA:  MOVLB  3
4DCC:  DECFSZ x54,F
4DCE:  BRA    4DC0
4DD0:  CLRF   x74
4DD2:  MOVLB  0
4DD4:  CALL   05D4
.................... 	output_bit(LED1, 1); 
4DD8:  BSF    F89.3
.................... 	borrar_sms_inicio(); 
4DDA:  GOTO   0A76
....................     clear_var(smsText);	    	//Inicializo smsText 
4DDE:  MOVLW  01
4DE0:  MOVLB  3
4DE2:  MOVWF  xFD
4DE4:  MOVLW  82
4DE6:  MOVWF  xFC
4DE8:  MOVLB  0
4DEA:  CALL   0AD0
.................... 	reinicioOK(); 
4DEE:  GOTO   141A
....................  
....................     do{ 
.................... 		restart_wdt(); 
4DF2:  CLRWDT
.................... 		if ((startMeasure) && (!memoryFull)){ 
4DF4:  MOVLB  1
4DF6:  MOVF   x73,F
4DF8:  BZ    4E44
4DFA:  MOVF   x71,F
4DFC:  BNZ   4E44
.................... 			startMeasure = 0; 
4DFE:  CLRF   x73
.................... 			Leer_sensores(1);					// LLena la estructura de medicion con los valores sin convertir 
4E00:  MOVLW  01
4E02:  MOVLB  3
4E04:  MOVWF  x60
4E06:  MOVLB  0
4E08:  CALL   232E
.................... 			StoreMed2EEPROM();					// Guarda en memoria los valores medidos junto a la fecha y hora 
4E0C:  GOTO   2898
.................... 			construirTextoSms(smsOut,1); 
4E10:  MOVLW  02
4E12:  MOVLB  3
4E14:  MOVWF  x55
4E16:  MOVLW  27
4E18:  MOVWF  x54
4E1A:  MOVLW  01
4E1C:  MOVWF  x56
4E1E:  MOVLB  0
4E20:  CALL   2C88
.................... 			idLastSmsOut = EnviarSms(smsOut, telnum);		 
4E24:  MOVLW  02
4E26:  MOVLB  3
4E28:  MOVWF  x61
4E2A:  MOVLW  27
4E2C:  MOVWF  x60
4E2E:  MOVLW  01
4E30:  MOVWF  x63
4E32:  MOVLW  48
4E34:  MOVWF  x62
4E36:  MOVLB  0
4E38:  CALL   1380
4E3C:  MOVFF  01,170
.................... 		} 
.................... 		else{ 
4E40:  BRA    4F0A
4E42:  MOVLB  1
.................... 			if (memoryFull){ 
4E44:  MOVF   x71,F
4E46:  BZ    4F0A
.................... 				//Ver accion en caso de memoria llena lo ideal seria un comando de inicializacion 
.................... 				if (smsMemSnd == 0){ 
4E48:  MOVF   x72,F
4E4A:  BNZ   4F0A
.................... 				    CurrDateTime(); 
4E4C:  MOVLB  0
4E4E:  CALL   11B4
.................... 					GenerateToken(); 
4E52:  CALL   0E3E
.................... 					clear_var(smsOut); 
4E56:  MOVLW  02
4E58:  MOVLB  3
4E5A:  MOVWF  xFD
4E5C:  MOVLW  27
4E5E:  MOVWF  xFC
4E60:  MOVLB  0
4E62:  CALL   0AD0
.................... 					sprintf(smsOut, "EST|%s|%s|MEMFULL|%ld|%c%c", dtFecha, dtHora, contData, tokenEma[0], tokenEma[1]); 
4E66:  MOVLW  02
4E68:  MOVLB  1
4E6A:  MOVWF  x47
4E6C:  MOVLW  27
4E6E:  MOVWF  x46
4E70:  MOVLW  A8
4E72:  MOVWF  FF6
4E74:  MOVLW  03
4E76:  MOVWF  FF7
4E78:  MOVLW  04
4E7A:  MOVLB  3
4E7C:  MOVWF  x60
4E7E:  MOVLB  0
4E80:  CALL   1304
4E84:  MOVLW  01
4E86:  MOVWF  FEA
4E88:  MOVLW  32
4E8A:  MOVWF  FE9
4E8C:  CALL   132C
4E90:  MOVLW  7C
4E92:  MOVLB  4
4E94:  MOVWF  x0D
4E96:  MOVLB  0
4E98:  CALL   0D22
4E9C:  MOVLW  01
4E9E:  MOVWF  FEA
4EA0:  MOVLW  3C
4EA2:  MOVWF  FE9
4EA4:  CALL   132C
4EA8:  MOVLW  B1
4EAA:  MOVWF  FF6
4EAC:  MOVLW  03
4EAE:  MOVWF  FF7
4EB0:  MOVLW  09
4EB2:  MOVLB  3
4EB4:  MOVWF  x60
4EB6:  MOVLB  0
4EB8:  CALL   1304
4EBC:  MOVLW  10
4EBE:  MOVWF  FE9
4EC0:  MOVFF  2E7,355
4EC4:  MOVFF  2E6,354
4EC8:  GOTO   2FA6
4ECC:  MOVLW  7C
4ECE:  MOVLB  4
4ED0:  MOVWF  x0D
4ED2:  MOVLB  0
4ED4:  CALL   0D22
4ED8:  MOVFF  17F,40D
4EDC:  CALL   0D22
4EE0:  MOVFF  180,40D
4EE4:  CALL   0D22
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
4EE8:  MOVLW  02
4EEA:  MOVLB  3
4EEC:  MOVWF  x61
4EEE:  MOVLW  27
4EF0:  MOVWF  x60
4EF2:  MOVLW  01
4EF4:  MOVWF  x63
4EF6:  MOVLW  48
4EF8:  MOVWF  x62
4EFA:  MOVLB  0
4EFC:  CALL   1380
4F00:  MOVFF  01,170
.................... 					smsMemSnd = 1; 
4F04:  MOVLW  01
4F06:  MOVLB  1
4F08:  MOVWF  x72
.................... 				} 
.................... 			} 
.................... 		} 
.................... 		if (startCheck){									// Verifica variables por alarmas 
4F0A:  MOVLB  1
4F0C:  MOVF   x74,F
4F0E:  BZ    5006
.................... 			CurrDateTime(); 
4F10:  MOVLB  0
4F12:  CALL   11B4
.................... 			float tempInt; 
.................... 			startCheck = 0; 
4F16:  MOVLB  1
4F18:  CLRF   x74
.................... 			CheckAlarmValues(); 
4F1A:  MOVLB  0
4F1C:  GOTO   309E
.................... 			if (tempInt != 0){									// Verifica estado del equipo 
4F20:  MOVFF  353,37A
4F24:  MOVFF  352,379
4F28:  MOVFF  351,378
4F2C:  MOVFF  350,377
4F30:  MOVLB  3
4F32:  CLRF   x7E
4F34:  CLRF   x7D
4F36:  CLRF   x7C
4F38:  CLRF   x7B
4F3A:  MOVLB  0
4F3C:  CALL   1A38
4F40:  BZ    5004
.................... 				GenerateToken(); 
4F42:  CALL   0E3E
.................... 				clear_var(smsOut); 
4F46:  MOVLW  02
4F48:  MOVLB  3
4F4A:  MOVWF  xFD
4F4C:  MOVLW  27
4F4E:  MOVWF  xFC
4F50:  MOVLB  0
4F52:  CALL   0AD0
.................... 				sprintf(smsOut, "EST|%s|%s|TEMP|%02.1f|%c%c", dtFecha, dtHora, tempInt,tokenEma[0], tokenEma[1]); 
4F56:  MOVLW  02
4F58:  MOVLB  1
4F5A:  MOVWF  x47
4F5C:  MOVLW  27
4F5E:  MOVWF  x46
4F60:  MOVLW  C4
4F62:  MOVWF  FF6
4F64:  MOVLW  03
4F66:  MOVWF  FF7
4F68:  MOVLW  04
4F6A:  MOVLB  3
4F6C:  MOVWF  x60
4F6E:  MOVLB  0
4F70:  CALL   1304
4F74:  MOVLW  01
4F76:  MOVWF  FEA
4F78:  MOVLW  32
4F7A:  MOVWF  FE9
4F7C:  CALL   132C
4F80:  MOVLW  7C
4F82:  MOVLB  4
4F84:  MOVWF  x0D
4F86:  MOVLB  0
4F88:  CALL   0D22
4F8C:  MOVLW  01
4F8E:  MOVWF  FEA
4F90:  MOVLW  3C
4F92:  MOVWF  FE9
4F94:  CALL   132C
4F98:  MOVLW  CD
4F9A:  MOVWF  FF6
4F9C:  MOVLW  03
4F9E:  MOVWF  FF7
4FA0:  MOVLW  06
4FA2:  MOVLB  3
4FA4:  MOVWF  x60
4FA6:  MOVLB  0
4FA8:  CALL   1304
4FAC:  MOVLW  41
4FAE:  MOVWF  FE9
4FB0:  MOVFF  353,3FF
4FB4:  MOVFF  352,3FE
4FB8:  MOVFF  351,3FD
4FBC:  MOVFF  350,3FC
4FC0:  MOVLW  01
4FC2:  MOVLB  4
4FC4:  MOVWF  x00
4FC6:  MOVLB  0
4FC8:  CALL   29EE
4FCC:  MOVLW  7C
4FCE:  MOVLB  4
4FD0:  MOVWF  x0D
4FD2:  MOVLB  0
4FD4:  CALL   0D22
4FD8:  MOVFF  17F,40D
4FDC:  CALL   0D22
4FE0:  MOVFF  180,40D
4FE4:  CALL   0D22
.................... 				idLastSmsOut = EnviarSms(smsOut, telnum);	// Alarma por temp. gabinete alta o baja 
4FE8:  MOVLW  02
4FEA:  MOVLB  3
4FEC:  MOVWF  x61
4FEE:  MOVLW  27
4FF0:  MOVWF  x60
4FF2:  MOVLW  01
4FF4:  MOVWF  x63
4FF6:  MOVLW  48
4FF8:  MOVWF  x62
4FFA:  MOVLB  0
4FFC:  CALL   1380
5000:  MOVFF  01,170
5004:  MOVLB  1
.................... 			} 
.................... 		} 
.................... 		if (startRestart){ 
5006:  MOVF   x75,F
5008:  BZ    5034
.................... 			modulo_gsm_init();   		// inicio modem GSM 
500A:  MOVLB  0
500C:  CALL   07C0
.................... 			delay_ms(90000);            // 90 segundos de yapa 
5010:  MOVLW  8B
5012:  MOVLB  3
5014:  MOVWF  x54
5016:  MOVLW  B0
5018:  MOVWF  x74
501A:  MOVLB  0
501C:  CALL   05D4
5020:  MOVLB  3
5022:  DECFSZ x54,F
5024:  BRA    5016
5026:  CLRF   x74
5028:  MOVLB  0
502A:  CALL   05D4
.................... 			output_bit(LED1, 1); 
502E:  BSF    F89.3
.................... 			startRestart = 0; 
5030:  MOVLB  1
5032:  CLRF   x75
.................... 		} 
.................... 		currSmsId = LeerSmsCmd(smsText);		// Lee sms y obtiene ID para su proceso posterior (borrado) 
5034:  MOVLW  01
5036:  MOVLB  3
5038:  MOVWF  x55
503A:  MOVLW  82
503C:  MOVWF  x54
503E:  MOVLB  0
5040:  GOTO   39C0
5044:  MOVFF  02,163
5048:  MOVFF  01,162
.................... 		if (currSmsId){									// Bandera que indica sms recibido 
504C:  MOVLB  1
504E:  MOVF   x62,W
5050:  IORWF  x63,W
5052:  BTFSC  FD8.2
5054:  BRA    52D4
.................... 			resProc = ProcessMessage(smsText); 
5056:  MOVLW  01
5058:  MOVLB  3
505A:  MOVWF  x55
505C:  MOVLW  82
505E:  MOVWF  x54
5060:  MOVLB  0
5062:  GOTO   3FEE
5066:  MOVFF  01,16F
.................... 			clear_var(smsOut); 
506A:  MOVLW  02
506C:  MOVLB  3
506E:  MOVWF  xFD
5070:  MOVLW  27
5072:  MOVWF  xFC
5074:  MOVLB  0
5076:  CALL   0AD0
.................... 			switch (resProc){ 
507A:  MOVLB  1
507C:  MOVF   x6F,W
507E:  XORLW  04
5080:  MOVLB  0
5082:  BZ    50A4
5084:  XORLW  01
5086:  BZ    50A4
5088:  XORLW  07
508A:  BZ    5120
508C:  XORLW  01
508E:  BZ    5120
5090:  XORLW  05
5092:  BTFSC  FD8.2
5094:  BRA    519E
5096:  XORLW  07
5098:  BTFSC  FD8.2
509A:  BRA    521A
509C:  XORLW  F1
509E:  BTFSC  FD8.2
50A0:  BRA    5254
50A2:  BRA    5254
.................... 				case TYP_SMS_INI: 
.................... 				case TYP_SMS_RTC: 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
50A4:  MOVLW  02
50A6:  MOVLB  1
50A8:  MOVWF  x47
50AA:  MOVLW  27
50AC:  MOVWF  x46
50AE:  MOVLW  E0
50B0:  MOVWF  FF6
50B2:  MOVLW  03
50B4:  MOVWF  FF7
50B6:  MOVLW  04
50B8:  MOVLB  3
50BA:  MOVWF  x60
50BC:  MOVLB  0
50BE:  CALL   1304
50C2:  MOVLW  01
50C4:  MOVLB  3
50C6:  MOVWF  x54
50C8:  MOVLW  30
50CA:  MOVLB  4
50CC:  MOVWF  x0D
50CE:  MOVLB  0
50D0:  CALL   0D22
50D4:  MOVLB  3
50D6:  DECFSZ x54,F
50D8:  BRA    50C8
50DA:  MOVFF  16F,354
50DE:  MOVLW  03
50E0:  MOVWF  x55
50E2:  MOVLB  0
50E4:  RCALL  4A0A
50E6:  MOVLW  7C
50E8:  MOVLB  4
50EA:  MOVWF  x0D
50EC:  MOVLB  0
50EE:  CALL   0D22
50F2:  MOVFF  17C,40D
50F6:  CALL   0D22
50FA:  MOVFF  17D,40D
50FE:  CALL   0D22
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
5102:  MOVLW  02
5104:  MOVLB  3
5106:  MOVWF  x61
5108:  MOVLW  27
510A:  MOVWF  x60
510C:  MOVLW  01
510E:  MOVWF  x63
5110:  MOVLW  48
5112:  MOVWF  x62
5114:  MOVLB  0
5116:  CALL   1380
511A:  MOVFF  01,170
.................... 					break; 
511E:  BRA    52D2
.................... 				case TYP_SMS_AA: 
.................... 				case TYP_SMS_BA: 
.................... 					WriteAlarmStruct(); 
5120:  BRA    4A90
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
5122:  MOVLW  02
5124:  MOVLB  1
5126:  MOVWF  x47
5128:  MOVLW  27
512A:  MOVWF  x46
512C:  MOVLW  EE
512E:  MOVWF  FF6
5130:  MOVLW  03
5132:  MOVWF  FF7
5134:  MOVLW  04
5136:  MOVLB  3
5138:  MOVWF  x60
513A:  MOVLB  0
513C:  CALL   1304
5140:  MOVLW  01
5142:  MOVLB  3
5144:  MOVWF  x54
5146:  MOVLW  30
5148:  MOVLB  4
514A:  MOVWF  x0D
514C:  MOVLB  0
514E:  CALL   0D22
5152:  MOVLB  3
5154:  DECFSZ x54,F
5156:  BRA    5146
5158:  MOVFF  16F,354
515C:  MOVLW  03
515E:  MOVWF  x55
5160:  MOVLB  0
5162:  RCALL  4A0A
5164:  MOVLW  7C
5166:  MOVLB  4
5168:  MOVWF  x0D
516A:  MOVLB  0
516C:  CALL   0D22
5170:  MOVFF  17C,40D
5174:  CALL   0D22
5178:  MOVFF  17D,40D
517C:  CALL   0D22
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
5180:  MOVLW  02
5182:  MOVLB  3
5184:  MOVWF  x61
5186:  MOVLW  27
5188:  MOVWF  x60
518A:  MOVLW  01
518C:  MOVWF  x63
518E:  MOVLW  48
5190:  MOVWF  x62
5192:  MOVLB  0
5194:  CALL   1380
5198:  MOVFF  01,170
.................... 					break; 
519C:  BRA    52D2
.................... 				case TYP_SMS_CSERV: 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
519E:  MOVLW  02
51A0:  MOVLB  1
51A2:  MOVWF  x47
51A4:  MOVLW  27
51A6:  MOVWF  x46
51A8:  MOVLW  FC
51AA:  MOVWF  FF6
51AC:  MOVLW  03
51AE:  MOVWF  FF7
51B0:  MOVLW  04
51B2:  MOVLB  3
51B4:  MOVWF  x60
51B6:  MOVLB  0
51B8:  CALL   1304
51BC:  MOVLW  01
51BE:  MOVLB  3
51C0:  MOVWF  x54
51C2:  MOVLW  30
51C4:  MOVLB  4
51C6:  MOVWF  x0D
51C8:  MOVLB  0
51CA:  CALL   0D22
51CE:  MOVLB  3
51D0:  DECFSZ x54,F
51D2:  BRA    51C2
51D4:  MOVFF  16F,354
51D8:  MOVLW  03
51DA:  MOVWF  x55
51DC:  MOVLB  0
51DE:  RCALL  4A0A
51E0:  MOVLW  7C
51E2:  MOVLB  4
51E4:  MOVWF  x0D
51E6:  MOVLB  0
51E8:  CALL   0D22
51EC:  MOVFF  17C,40D
51F0:  CALL   0D22
51F4:  MOVFF  17D,40D
51F8:  CALL   0D22
.................... 					idLastSmsOut = EnviarSms(smsOut, telaux); 
51FC:  MOVLW  02
51FE:  MOVLB  3
5200:  MOVWF  x61
5202:  MOVLW  27
5204:  MOVWF  x60
5206:  MOVLW  02
5208:  MOVWF  x63
520A:  MOVLW  CC
520C:  MOVWF  x62
520E:  MOVLB  0
5210:  CALL   1380
5214:  MOVFF  01,170
.................... 					break; 
5218:  BRA    52D2
.................... 				case TYP_SMS_CON:	 
.................... 			        Leer_sensores(0);		//Lee las medidas de este momento 
521A:  MOVLB  3
521C:  CLRF   x60
521E:  MOVLB  0
5220:  CALL   232E
.................... 					construirTextoSms(smsOut,0); 
5224:  MOVLW  02
5226:  MOVLB  3
5228:  MOVWF  x55
522A:  MOVLW  27
522C:  MOVWF  x54
522E:  CLRF   x56
5230:  MOVLB  0
5232:  CALL   2C88
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
5236:  MOVLW  02
5238:  MOVLB  3
523A:  MOVWF  x61
523C:  MOVLW  27
523E:  MOVWF  x60
5240:  MOVLW  01
5242:  MOVWF  x63
5244:  MOVLW  48
5246:  MOVWF  x62
5248:  MOVLB  0
524A:  CALL   1380
524E:  MOVFF  01,170
.................... 					break; 
5252:  BRA    52D2
.................... 				case TYP_SMS_ERR:	 
.................... 				default:	 
.................... 					sprintf(smsOut, "RTA|%04u|%c%c", resProc, tokenSrv[0], tokenSrv[1]); 
5254:  MOVLW  02
5256:  MOVLB  1
5258:  MOVWF  x47
525A:  MOVLW  27
525C:  MOVWF  x46
525E:  MOVLW  0A
5260:  MOVWF  FF6
5262:  MOVLW  04
5264:  MOVWF  FF7
5266:  MOVLW  04
5268:  MOVLB  3
526A:  MOVWF  x60
526C:  MOVLB  0
526E:  CALL   1304
5272:  MOVLW  01
5274:  MOVLB  3
5276:  MOVWF  x54
5278:  MOVLW  30
527A:  MOVLB  4
527C:  MOVWF  x0D
527E:  MOVLB  0
5280:  CALL   0D22
5284:  MOVLB  3
5286:  DECFSZ x54,F
5288:  BRA    5278
528A:  MOVFF  16F,354
528E:  MOVLW  03
5290:  MOVWF  x55
5292:  MOVLB  0
5294:  CALL   4A0A
5298:  MOVLW  7C
529A:  MOVLB  4
529C:  MOVWF  x0D
529E:  MOVLB  0
52A0:  CALL   0D22
52A4:  MOVFF  17C,40D
52A8:  CALL   0D22
52AC:  MOVFF  17D,40D
52B0:  CALL   0D22
.................... 					idLastSmsOut = EnviarSms(smsOut, telnum); 
52B4:  MOVLW  02
52B6:  MOVLB  3
52B8:  MOVWF  x61
52BA:  MOVLW  27
52BC:  MOVWF  x60
52BE:  MOVLW  01
52C0:  MOVWF  x63
52C2:  MOVLW  48
52C4:  MOVWF  x62
52C6:  MOVLB  0
52C8:  CALL   1380
52CC:  MOVFF  01,170
.................... 					break; 
52D0:  BRA    52D2
52D2:  MOVLB  1
.................... 			} 
.................... 		} 
....................     } while(runOk); 
52D4:  MOVF   x6E,F
52D6:  BTFSC  FD8.2
52D8:  BRA    52DE
52DA:  MOVLB  0
52DC:  BRA    4DF2
.................... } 
.................... //--------------------------------- 
52DE:  BRA    52DE

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0D   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0000  
   Word  4: 0001   STVREN DEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 0F 00 CC 06 DC 05 

F00032: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00042: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00052: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00062: 00 00 00 00 00 00 00 00 
